<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/server/db.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/db.js" />
              <option name="originalContent" value="const admin = require('firebase-admin');&#10;&#10;let db;&#10;&#10;function init() {&#10;  const serviceAccount = JSON.parse(&#10;    Buffer.from(process.env.FIREBASE_SERVICE_ACCOUNT_JSON, 'base64').toString('utf8')&#10;  );&#10;  admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });&#10;  db = admin.firestore();&#10;}&#10;&#10;async function loadCollection(name) {&#10;  const snapshot = await db.collection(name).get();&#10;  return snapshot.docs.map(doc =&gt; doc.data());&#10;}&#10;&#10;// Replace the entire collection in a single batch so snapshot listeners&#10;// don't observe a momentary empty state during updates.&#10;async function saveCollection(name, items) {&#10;  const coll = db.collection(name);&#10;  const snapshot = await coll.get();&#10;  const batch = db.batch();&#10;  const newIds = new Set(items.map(i =&gt; i.id));&#10;&#10;  snapshot.docs.forEach(doc =&gt; {&#10;    if (!newIds.has(doc.id)) {&#10;      batch.delete(doc.ref);&#10;    }&#10;  });&#10;&#10;  items.forEach(item =&gt; {&#10;    batch.set(coll.doc(item.id), item);&#10;  });&#10;&#10;  await batch.commit();&#10;}&#10;&#10;async function loadData() {&#10;  return {&#10;    lists: await loadCollection('lists'),&#10;    globalItems: await loadCollection('items'),&#10;    categories: await loadCollection('categories'),&#10;    archivedLists: await loadCollection('archivedLists'),&#10;    receipts: await loadCollection('receipts')&#10;  };&#10;}&#10;&#10;async function saveData(data) {&#10;  await Promise.all([&#10;    saveCollection('lists', data.lists),&#10;    saveCollection('items', data.globalItems),&#10;    saveCollection('categories', data.categories),&#10;    saveCollection('archivedLists', data.archivedLists),&#10;    saveCollection('receipts', data.receipts)&#10;  ]);&#10;}&#10;&#10;function watchCollection(collection, key, onChange) {&#10;  return db.collection(collection).onSnapshot(snapshot =&gt; {&#10;    const items = [];&#10;    snapshot.forEach(doc =&gt; {&#10;      const data = doc.data();&#10;      if (!data || typeof data !== 'object' || data.id !== doc.id) {&#10;        console.error(`Corrupted document in ${collection}: ${doc.id}`);&#10;        return;&#10;      }&#10;      items.push(data);&#10;    });&#10;    onChange(key, items);&#10;  }, err =&gt; {&#10;    console.error(`Listener error for ${collection}`, err);&#10;  });&#10;}&#10;&#10;function watchData(onChange) {&#10;  const unsubscribers = [&#10;    watchCollection('lists', 'lists', onChange),&#10;    watchCollection('items', 'globalItems', onChange),&#10;    watchCollection('categories', 'categories', onChange),&#10;    watchCollection('archivedLists', 'archivedLists', onChange),&#10;    watchCollection('receipts', 'receipts', onChange)&#10;  ];&#10;  return () =&gt; unsubscribers.forEach(unsub =&gt; unsub());&#10;}&#10;&#10;module.exports = { init, loadData, saveData, watchData };&#10;" />
              <option name="updatedContent" value="const admin = require('firebase-admin');&#10;&#10;let db;&#10;let isFirebaseEnabled = false;&#10;&#10;function init() {&#10;  try {&#10;    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;&#10;    if (!serviceAccountJson) {&#10;      console.warn('FIREBASE_SERVICE_ACCOUNT_JSON environment variable not set. Running without Firebase persistence.');&#10;      return;&#10;    }&#10;    &#10;    const serviceAccount = JSON.parse(&#10;      Buffer.from(serviceAccountJson, 'base64').toString('utf8')&#10;    );&#10;    admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });&#10;    db = admin.firestore();&#10;    isFirebaseEnabled = true;&#10;    console.log('Firebase initialized successfully');&#10;  } catch (error) {&#10;    console.warn('Failed to initialize Firebase:', error.message);&#10;    console.warn('Running without Firebase persistence.');&#10;    isFirebaseEnabled = false;&#10;  }&#10;}&#10;&#10;async function loadCollection(name) {&#10;  if (!isFirebaseEnabled) {&#10;    return [];&#10;  }&#10;  &#10;  try {&#10;    const snapshot = await db.collection(name).get();&#10;    return snapshot.docs.map(doc =&gt; doc.data());&#10;  } catch (error) {&#10;    console.error(`Failed to load collection ${name}:`, error);&#10;    return [];&#10;  }&#10;}&#10;&#10;// Replace the entire collection in a single batch so snapshot listeners&#10;// don't observe a momentary empty state during updates.&#10;async function saveCollection(name, items) {&#10;  if (!isFirebaseEnabled) {&#10;    console.log(`Would save ${items.length} items to collection ${name} (Firebase disabled)`);&#10;    return;&#10;  }&#10;  &#10;  try {&#10;    const coll = db.collection(name);&#10;    const snapshot = await coll.get();&#10;    const batch = db.batch();&#10;    const newIds = new Set(items.map(i =&gt; i.id));&#10;&#10;    snapshot.docs.forEach(doc =&gt; {&#10;      if (!newIds.has(doc.id)) {&#10;        batch.delete(doc.ref);&#10;      }&#10;    });&#10;&#10;    items.forEach(item =&gt; {&#10;      batch.set(coll.doc(item.id), item);&#10;    });&#10;&#10;    await batch.commit();&#10;  } catch (error) {&#10;    console.error(`Failed to save collection ${name}:`, error);&#10;  }&#10;}&#10;&#10;async function loadData() {&#10;  if (!isFirebaseEnabled) {&#10;    console.log('Loading empty data (Firebase disabled)');&#10;    return {&#10;      lists: [],&#10;      globalItems: [],&#10;      categories: [],&#10;      archivedLists: [],&#10;      receipts: []&#10;    };&#10;  }&#10;  &#10;  try {&#10;    return {&#10;      lists: await loadCollection('lists'),&#10;      globalItems: await loadCollection('items'),&#10;      categories: await loadCollection('categories'),&#10;      archivedLists: await loadCollection('archivedLists'),&#10;      receipts: await loadCollection('receipts')&#10;    };&#10;  } catch (error) {&#10;    console.error('Failed to load data from Firebase:', error);&#10;    return {&#10;      lists: [],&#10;      globalItems: [],&#10;      categories: [],&#10;      archivedLists: [],&#10;      receipts: []&#10;    };&#10;  }&#10;}&#10;&#10;async function saveData(data) {&#10;  if (!isFirebaseEnabled) {&#10;    console.log('Would save data to Firebase (Firebase disabled)');&#10;    return;&#10;  }&#10;  &#10;  try {&#10;    await Promise.all([&#10;      saveCollection('lists', data.lists),&#10;      saveCollection('items', data.globalItems),&#10;      saveCollection('categories', data.categories),&#10;      saveCollection('archivedLists', data.archivedLists),&#10;      saveCollection('receipts', data.receipts)&#10;    ]);&#10;  } catch (error) {&#10;    console.error('Failed to save data to Firebase:', error);&#10;  }&#10;}&#10;&#10;function watchCollection(collection, key, onChange) {&#10;  if (!isFirebaseEnabled) {&#10;    console.log(`Would watch collection ${collection} (Firebase disabled)`);&#10;    return () =&gt; {}; // Return empty unsubscriber&#10;  }&#10;  &#10;  return db.collection(collection).onSnapshot(snapshot =&gt; {&#10;    const items = [];&#10;    snapshot.forEach(doc =&gt; {&#10;      const data = doc.data();&#10;      if (!data || typeof data !== 'object' || data.id !== doc.id) {&#10;        console.error(`Corrupted document in ${collection}: ${doc.id}`);&#10;        return;&#10;      }&#10;      items.push(data);&#10;    });&#10;    onChange(key, items);&#10;  }, err =&gt; {&#10;    console.error(`Listener error for ${collection}`, err);&#10;  });&#10;}&#10;&#10;function watchData(onChange) {&#10;  if (!isFirebaseEnabled) {&#10;    console.log('Would watch data changes (Firebase disabled)');&#10;    return () =&gt; {}; // Return empty unsubscriber&#10;  }&#10;  &#10;  const unsubscribers = [&#10;    watchCollection('lists', 'lists', onChange),&#10;    watchCollection('items', 'globalItems', onChange),&#10;    watchCollection('categories', 'categories', onChange),&#10;    watchCollection('archivedLists', 'archivedLists', onChange),&#10;    watchCollection('receipts', 'receipts', onChange)&#10;  ];&#10;  return () =&gt; unsubscribers.forEach(unsub =&gt; unsub());&#10;}&#10;&#10;module.exports = { init, loadData, saveData, watchData };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/server.js" />
              <option name="originalContent" value="const path = require('path');&#10;const express = require('express');&#10;const cors = require('cors');&#10;const http = require('http');&#10;const { Server } = require('socket.io');&#10;const { init, loadData, saveData, watchData } = require('./db');&#10;&#10;// Enhanced in-memory storage with operational tracking&#10;let appData = {&#10;  lists: [],&#10;  globalItems: [],&#10;  categories: [],&#10;  archivedLists: [],&#10;  receipts: [],&#10;  revision: 0,&#10;  lastModified: new Date().toISOString(),&#10;  operations: [] // Track recent operations for conflict resolution&#10;};&#10;&#10;// Track connected users and their activity&#10;const connectedUsers = new Map();&#10;const activeEditors = new Map(); // Track who's editing what&#10;&#10;const app = express();&#10;const httpServer = http.createServer(app);&#10;const io = new Server(httpServer, { cors: { origin: '*' } });&#10;&#10;init();&#10;&#10;app.use(cors());&#10;app.use(express.json({ limit: '5mb' }));&#10;&#10;// Serve the static front‑end files&#10;app.use(express.static(path.join(__dirname, '..', 'shopping-list-app')));&#10;&#10;// Utility functions for data merging and validation&#10;function validateDataStructure(data) {&#10;  if (!data || typeof data !== 'object') return false;&#10;  &#10;  const requiredFields = ['lists', 'globalItems', 'categories', 'archivedLists', 'receipts'];&#10;  for (const field of requiredFields) {&#10;    if (!Array.isArray(data[field])) return false;&#10;  }&#10;  &#10;  // Validate each list has required fields&#10;  for (const list of data.lists) {&#10;    if (!list.id || !list.name || !Array.isArray(list.items)) return false;&#10;  }&#10;  &#10;  return true;&#10;}&#10;&#10;function createOperation(type, path, data, clientId, timestamp = Date.now()) {&#10;  return {&#10;    id: `${timestamp}-${clientId}-${Math.random().toString(36).substr(2, 9)}`,&#10;    type,&#10;    path,&#10;    data,&#10;    clientId,&#10;    timestamp,&#10;    revision: appData.revision + 1&#10;  };&#10;}&#10;&#10;function applyOperation(operation) {&#10;  const { type, path, data } = operation;&#10;  &#10;  switch (type) {&#10;    case 'create':&#10;      if (path === 'lists') {&#10;        appData.lists.push(data);&#10;      } else if (path === 'globalItems') {&#10;        appData.globalItems.push(data);&#10;      } else if (path.startsWith('lists/')) {&#10;        const listId = path.split('/')[1];&#10;        const list = appData.lists.find(l =&gt; l.id === listId);&#10;        if (list &amp;&amp; path.endsWith('/items')) {&#10;          list.items.push(data);&#10;        }&#10;      }&#10;      break;&#10;&#10;    case 'update':&#10;      if (path.startsWith('lists/')) {&#10;        const parts = path.split('/');&#10;        const listId = parts[1];&#10;        const list = appData.lists.find(l =&gt; l.id === listId);&#10;        if (list) {&#10;          if (parts.length === 2) {&#10;            Object.assign(list, data);&#10;          } else if (parts[2] === 'items') {&#10;            const itemId = parts[3];&#10;            const item = list.items.find(i =&gt; i.id === itemId);&#10;            if (item) {&#10;              Object.assign(item, data);&#10;            }&#10;          }&#10;        }&#10;      } else if (path.startsWith('globalItems/')) {&#10;        const itemId = path.split('/')[1];&#10;        const item = appData.globalItems.find(i =&gt; i.id === itemId);&#10;        if (item) {&#10;          Object.assign(item, data);&#10;        }&#10;      }&#10;      break;&#10;&#10;    case 'delete':&#10;      if (path.startsWith('lists/')) {&#10;        const parts = path.split('/');&#10;        const listId = parts[1];&#10;        if (parts.length === 2) {&#10;          appData.lists = appData.lists.filter(l =&gt; l.id !== listId);&#10;        } else if (parts[2] === 'items') {&#10;          const itemId = parts[3];&#10;          const list = appData.lists.find(l =&gt; l.id === listId);&#10;          if (list) {&#10;            list.items = list.items.filter(i =&gt; i.id !== itemId);&#10;          }&#10;        }&#10;      }&#10;      break;&#10;  }&#10;}&#10;&#10;function mergeOperations(baseRevision, operations, newData, clientId) {&#10;  // Create a copy of current data to work with&#10;  let mergedData = JSON.parse(JSON.stringify(appData));&#10;  &#10;  // Apply any operations that happened after the client's base revision&#10;  const recentOps = appData.operations.filter(op =&gt;&#10;    op.revision &gt; baseRevision &amp;&amp; op.clientId !== clientId&#10;  );&#10;  &#10;  // Try to merge changes intelligently&#10;  if (newData.lists) {&#10;    mergedData.lists = mergeArrays(mergedData.lists, newData.lists, 'id');&#10;  }&#10;  if (newData.globalItems) {&#10;    mergedData.globalItems = mergeArrays(mergedData.globalItems, newData.globalItems, 'id');&#10;  }&#10;  if (newData.categories) {&#10;    mergedData.categories = mergeArrays(mergedData.categories, newData.categories, 'id');&#10;  }&#10;  &#10;  return mergedData;&#10;}&#10;&#10;function mergeArrays(serverArray, clientArray, idField) {&#10;  const serverMap = new Map(serverArray.map(item =&gt; [item[idField], item]));&#10;  const clientMap = new Map(clientArray.map(item =&gt; [item[idField], item]));&#10;  &#10;  // Start with server items&#10;  const result = [...serverArray];&#10;  &#10;  // Add or update with client changes&#10;  for (const [id, clientItem] of clientMap) {&#10;    const existingIndex = result.findIndex(item =&gt; item[idField] === id);&#10;    if (existingIndex &gt;= 0) {&#10;      // Merge existing item (prefer client changes for most fields)&#10;      result[existingIndex] = { ...result[existingIndex], ...clientItem };&#10;    } else {&#10;      // Add new item from client&#10;      result.push(clientItem);&#10;    }&#10;  }&#10;  &#10;  return result;&#10;}&#10;&#10;// REST endpoint: GET /data – return the entire app state&#10;app.get('/data', (req, res) =&gt; {&#10;  res.json({&#10;    ...appData,&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;});&#10;&#10;// Enhanced REST endpoint: PUT /data with better conflict resolution&#10;app.put('/data', async (req, res) =&gt; {&#10;  const { clientId, changeId, baseRevision, operations: clientOps, ...newData } = req.body || {};&#10;  &#10;  if (!validateDataStructure(newData)) {&#10;    return res.status(400).json({ message: 'Invalid data structure' });&#10;  }&#10;  &#10;  try {&#10;    let mergedData;&#10;    &#10;    if (baseRevision != null &amp;&amp; baseRevision &lt; appData.revision) {&#10;      // Client is behind - attempt to merge changes&#10;      console.log(`Conflict detected: client revision ${baseRevision}, server revision ${appData.revision}`);&#10;      mergedData = mergeOperations(baseRevision, clientOps || [], newData, clientId);&#10;      &#10;      // Return merged data for client to review&#10;      return res.status(409).json({&#10;        ...mergedData,&#10;        revision: appData.revision,&#10;        message: 'Conflicts resolved through merge'&#10;      });&#10;    } else {&#10;      // Normal update&#10;      mergedData = { ...newData };&#10;    }&#10;    &#10;    // Update server data&#10;    const oldRevision = appData.revision;&#10;    appData = {&#10;      ...mergedData,&#10;      revision: oldRevision + 1,&#10;      lastModified: new Date().toISOString(),&#10;      operations: appData.operations || []&#10;    };&#10;    &#10;    // Track this operation&#10;    if (clientOps &amp;&amp; clientOps.length &gt; 0) {&#10;      appData.operations.push(...clientOps.map(op =&gt; ({&#10;        ...op,&#10;        revision: appData.revision,&#10;        serverTimestamp: Date.now()&#10;      })));&#10;      &#10;      // Keep only recent operations (last 100)&#10;      appData.operations = appData.operations.slice(-100);&#10;    }&#10;    &#10;    await saveData(appData);&#10;    &#10;    // Broadcast to all clients except sender&#10;    io.emit('dataUpdated', {&#10;      data: appData,&#10;      clientId,&#10;      changeId,&#10;      operations: clientOps&#10;    });&#10;    &#10;    res.json({&#10;      message: 'Data updated successfully',&#10;      revision: appData.revision,&#10;      timestamp: appData.lastModified&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Error updating data:', error);&#10;    res.status(500).json({ message: 'Internal server error' });&#10;  }&#10;});&#10;&#10;// New endpoint for granular operations&#10;app.post('/operations', async (req, res) =&gt; {&#10;  const { operations, clientId } = req.body || {};&#10;  &#10;  if (!Array.isArray(operations) || !clientId) {&#10;    return res.status(400).json({ message: 'Invalid operations data' });&#10;  }&#10;  &#10;  try {&#10;    // Apply operations one by one&#10;    for (const op of operations) {&#10;      applyOperation(op);&#10;      appData.operations.push(op);&#10;    }&#10;    &#10;    appData.revision += operations.length;&#10;    appData.lastModified = new Date().toISOString();&#10;    &#10;    // Keep only recent operations&#10;    appData.operations = appData.operations.slice(-100);&#10;    &#10;    await saveData(appData);&#10;    &#10;    // Broadcast operations to other clients&#10;    io.emit('operationsApplied', {&#10;      operations,&#10;      clientId,&#10;      revision: appData.revision&#10;    });&#10;    &#10;    res.json({&#10;      message: 'Operations applied successfully',&#10;      revision: appData.revision&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Error applying operations:', error);&#10;    res.status(500).json({ message: 'Failed to apply operations' });&#10;  }&#10;});&#10;&#10;// Enhanced user presence tracking&#10;app.post('/presence', (req, res) =&gt; {&#10;  const { clientId, userId, action, listId, itemId } = req.body || {};&#10;  &#10;  if (!clientId) {&#10;    return res.status(400).json({ message: 'Client ID required' });&#10;  }&#10;  &#10;  const user = connectedUsers.get(clientId) || {&#10;    id: clientId,&#10;    userId: userId || `User-${clientId.slice(-8)}`,&#10;    connectedAt: new Date().toISOString(),&#10;    lastActivity: new Date().toISOString()&#10;  };&#10;  &#10;  user.lastActivity = new Date().toISOString();&#10;  connectedUsers.set(clientId, user);&#10;  &#10;  if (action === 'editStart' &amp;&amp; listId) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    activeEditors.set(key, {&#10;      clientId,&#10;      userId: user.userId,&#10;      startedAt: new Date().toISOString()&#10;    });&#10;  } else if (action === 'editEnd' &amp;&amp; listId) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    activeEditors.delete(key);&#10;  }&#10;  &#10;  // Broadcast presence update&#10;  io.emit('presenceUpdate', {&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;  &#10;  res.json({ message: 'Presence updated' });&#10;});&#10;&#10;// REST endpoint: POST /data/clear – reset app state&#10;app.post('/data/clear', async (req, res) =&gt; {&#10;  appData = {&#10;    lists: [],&#10;    globalItems: [],&#10;    categories: [],&#10;    archivedLists: [],&#10;    receipts: [],&#10;    revision: appData.revision + 1,&#10;    lastModified: new Date().toISOString(),&#10;    operations: []&#10;  };&#10;  await saveData(appData);&#10;  io.emit('dataUpdated', { data: appData });&#10;  res.json({ message: 'Data cleared' });&#10;});&#10;&#10;// Enhanced WebSocket connection handling&#10;io.on('connection', socket =&gt; {&#10;  const clientId = socket.handshake.query.clientId || socket.id;&#10;  &#10;  console.log(`Client connected: ${clientId}`);&#10;  &#10;  // Send initial data&#10;  socket.emit('dataUpdated', { &#10;    data: appData,&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;  &#10;  // Handle real-time operations&#10;  socket.on('operation', (operation) =&gt; {&#10;    try {&#10;      const op = { ...operation, serverTimestamp: Date.now() };&#10;      applyOperation(op);&#10;      appData.operations.push(op);&#10;      appData.revision++;&#10;      &#10;      // Broadcast to other clients&#10;      socket.broadcast.emit('operationReceived', op);&#10;    } catch (error) {&#10;      console.error('Error handling operation:', error);&#10;      socket.emit('operationError', { error: error.message });&#10;    }&#10;  });&#10;  &#10;  // Handle presence updates&#10;  socket.on('presence', (data) =&gt; {&#10;    const user = {&#10;      id: clientId,&#10;      ...data,&#10;      lastActivity: new Date().toISOString()&#10;    };&#10;    connectedUsers.set(clientId, user);&#10;    &#10;    io.emit('presenceUpdate', {&#10;      connectedUsers: Array.from(connectedUsers.values()),&#10;      activeEditors: Object.fromEntries(activeEditors)&#10;    });&#10;  });&#10;  &#10;  // Handle disconnect&#10;  socket.on('disconnect', () =&gt; {&#10;    console.log(`Client disconnected: ${clientId}`);&#10;    connectedUsers.delete(clientId);&#10;    &#10;    // Remove from active editors&#10;    for (const [key, editor] of activeEditors) {&#10;      if (editor.clientId === clientId) {&#10;        activeEditors.delete(key);&#10;      }&#10;    }&#10;    &#10;    io.emit('presenceUpdate', {&#10;      connectedUsers: Array.from(connectedUsers.values()),&#10;      activeEditors: Object.fromEntries(activeEditors)&#10;    });&#10;  });&#10;});&#10;&#10;const PORT = process.env.PORT || 3000;&#10;&#10;function startFirestoreListener() {&#10;  watchData((key, items) =&gt; {&#10;    appData[key] = items;&#10;    appData.revision++;&#10;    appData.lastModified = new Date().toISOString();&#10;    io.emit('dataUpdated', { data: appData, source: 'firestore' });&#10;  });&#10;}&#10;&#10;loadData()&#10;  .then(d =&gt; {&#10;    appData = { &#10;      ...d, &#10;      revision: 0,&#10;      lastModified: new Date().toISOString(),&#10;      operations: []&#10;    };&#10;    startFirestoreListener();&#10;    httpServer.listen(PORT, () =&gt; {&#10;      console.log(`Shopping List server running on http://localhost:${PORT}`);&#10;    });&#10;  })&#10;  .catch(err =&gt; {&#10;    console.error('Failed to load data from database', err);&#10;    appData.revision = 0;&#10;    startFirestoreListener();&#10;    httpServer.listen(PORT, () =&gt; {&#10;      console.log(`Shopping List server running on http://localhost:${PORT}`);&#10;    });&#10;  });&#10;" />
              <option name="updatedContent" value="const path = require('path');&#10;const express = require('express');&#10;const cors = require('cors');&#10;const http = require('http');&#10;const { Server } = require('socket.io');&#10;const { init, loadData, saveData, watchData } = require('./db');&#10;&#10;// Enhanced in-memory storage with operational tracking&#10;let appData = {&#10;  lists: [],&#10;  globalItems: [],&#10;  categories: [],&#10;  archivedLists: [],&#10;  receipts: [],&#10;  revision: 0,&#10;  lastModified: new Date().toISOString(),&#10;  operations: [], // Track recent operations for conflict resolution&#10;  checksum: null // Data integrity verification&#10;};&#10;&#10;// Track connected users and their activity&#10;const connectedUsers = new Map();&#10;const activeEditors = new Map(); // Track who's editing what&#10;const pendingOperations = new Map(); // Track operations awaiting confirmation&#10;&#10;const app = express();&#10;const httpServer = http.createServer(app);&#10;const io = new Server(httpServer, { &#10;  cors: { origin: '*' },&#10;  pingTimeout: 60000,&#10;  pingInterval: 25000&#10;});&#10;&#10;init();&#10;&#10;app.use(cors());&#10;app.use(express.json({ limit: '5mb' }));&#10;&#10;// Serve the static front‑end files&#10;app.use(express.static(path.join(__dirname, '..', 'shopping-list-app')));&#10;&#10;// Enhanced utility functions for data merging and validation&#10;function validateDataStructure(data) {&#10;  if (!data || typeof data !== 'object') return false;&#10;  &#10;  const requiredFields = ['lists', 'globalItems', 'categories', 'archivedLists', 'receipts'];&#10;  for (const field of requiredFields) {&#10;    if (!Array.isArray(data[field])) return false;&#10;  }&#10;  &#10;  // Validate each list has required fields and structure&#10;  for (const list of data.lists) {&#10;    if (!list.id || !list.name || !Array.isArray(list.items)) return false;&#10;    for (const item of list.items) {&#10;      if (!item.id || !item.globalItemId) return false;&#10;      if (typeof item.quantity !== 'number' || item.quantity &lt;= 0) return false;&#10;    }&#10;  }&#10;  &#10;  // Validate global items&#10;  for (const item of data.globalItems) {&#10;    if (!item.id || !item.name || !item.categoryId) return false;&#10;    if (typeof item.estimatedPrice !== 'number' || item.estimatedPrice &lt; 0) return false;&#10;  }&#10;  &#10;  return true;&#10;}&#10;&#10;function generateChecksum(data) {&#10;  const crypto = require('crypto');&#10;  const jsonString = JSON.stringify(data, Object.keys(data).sort());&#10;  return crypto.createHash('sha256').update(jsonString).digest('hex');&#10;}&#10;&#10;function createOperation(type, path, data, clientId, timestamp = Date.now()) {&#10;  return {&#10;    id: `${timestamp}-${clientId}-${Math.random().toString(36).substr(2, 9)}`,&#10;    type,&#10;    path,&#10;    data: JSON.parse(JSON.stringify(data)), // Deep clone&#10;    clientId,&#10;    timestamp,&#10;    revision: appData.revision + 1,&#10;    checksum: generateChecksum(data)&#10;  };&#10;}&#10;&#10;function applyOperation(operation, targetData = appData) {&#10;  const { type, path, data } = operation;&#10;  &#10;  try {&#10;    switch (type) {&#10;      case 'create':&#10;        if (path === 'lists') {&#10;          targetData.lists.push(data);&#10;        } else if (path === 'globalItems') {&#10;          targetData.globalItems.push(data);&#10;        } else if (path === 'categories') {&#10;          targetData.categories.push(data);&#10;        } else if (path.startsWith('lists/')) {&#10;          const listId = path.split('/')[1];&#10;          const list = targetData.lists.find(l =&gt; l.id === listId);&#10;          if (list &amp;&amp; path.endsWith('/items')) {&#10;            list.items.push(data);&#10;          }&#10;        }&#10;        break;&#10;        &#10;      case 'update':&#10;        if (path.startsWith('lists/')) {&#10;          const parts = path.split('/');&#10;          const listId = parts[1];&#10;          const list = targetData.lists.find(l =&gt; l.id === listId);&#10;          if (list) {&#10;            if (parts.length === 2) {&#10;              Object.assign(list, data);&#10;            } else if (parts[2] === 'items') {&#10;              const itemId = parts[3];&#10;              const item = list.items.find(i =&gt; i.id === itemId);&#10;              if (item) {&#10;                Object.assign(item, data);&#10;              }&#10;            }&#10;          }&#10;        } else if (path.startsWith('globalItems/')) {&#10;          const itemId = path.split('/')[1];&#10;          const item = targetData.globalItems.find(i =&gt; i.id === itemId);&#10;          if (item) {&#10;            Object.assign(item, data);&#10;          }&#10;        }&#10;        break;&#10;        &#10;      case 'delete':&#10;        if (path.startsWith('lists/')) {&#10;          const parts = path.split('/');&#10;          const listId = parts[1];&#10;          if (parts.length === 2) {&#10;            targetData.lists = targetData.lists.filter(l =&gt; l.id !== listId);&#10;          } else if (parts[2] === 'items') {&#10;            const itemId = parts[3];&#10;            const list = targetData.lists.find(l =&gt; l.id === listId);&#10;            if (list) {&#10;              list.items = list.items.filter(i =&gt; i.id !== itemId);&#10;            }&#10;          }&#10;        } else if (path.startsWith('globalItems/')) {&#10;          const itemId = path.split('/')[1];&#10;          targetData.globalItems = targetData.globalItems.filter(i =&gt; i.id !== itemId);&#10;        }&#10;        break;&#10;        &#10;      default:&#10;        throw new Error(`Unknown operation type: ${type}`);&#10;    }&#10;    &#10;    return true;&#10;  } catch (error) {&#10;    console.error('Error applying operation:', error);&#10;    return false;&#10;  }&#10;}&#10;&#10;function resolveConflicts(baseData, clientData, serverData) {&#10;  // Implement three-way merge algorithm&#10;  const resolved = JSON.parse(JSON.stringify(serverData)); // Start with server state&#10;  &#10;  // Merge lists with conflict detection&#10;  resolved.lists = mergeListsWithConflictDetection(&#10;    baseData.lists || [],&#10;    clientData.lists || [],&#10;    serverData.lists || []&#10;  );&#10;  &#10;  // Merge global items&#10;  resolved.globalItems = mergeArraysById(&#10;    clientData.globalItems || [],&#10;    serverData.globalItems || [],&#10;    'id'&#10;  );&#10;  &#10;  // Merge categories (server wins for structural changes)&#10;  resolved.categories = serverData.categories || [];&#10;  &#10;  return resolved;&#10;}&#10;&#10;function mergeListsWithConflictDetection(baseLists, clientLists, serverLists) {&#10;  const merged = [];&#10;  const conflicts = [];&#10;  &#10;  // Create maps for efficient lookup&#10;  const baseMap = new Map(baseLists.map(l =&gt; [l.id, l]));&#10;  const clientMap = new Map(clientLists.map(l =&gt; [l.id, l]));&#10;  const serverMap = new Map(serverLists.map(l =&gt; [l.id, l]));&#10;  &#10;  // Get all unique list IDs&#10;  const allIds = new Set([&#10;    ...baseLists.map(l =&gt; l.id),&#10;    ...clientLists.map(l =&gt; l.id),&#10;    ...serverLists.map(l =&gt; l.id)&#10;  ]);&#10;  &#10;  for (const id of allIds) {&#10;    const baseList = baseMap.get(id);&#10;    const clientList = clientMap.get(id);&#10;    const serverList = serverMap.get(id);&#10;    &#10;    if (!clientList &amp;&amp; !serverList) {&#10;      // List deleted by both - skip&#10;      continue;&#10;    } else if (!clientList) {&#10;      // List exists on server only&#10;      merged.push(serverList);&#10;    } else if (!serverList) {&#10;      // List exists on client only&#10;      merged.push(clientList);&#10;    } else {&#10;      // List exists on both - merge&#10;      const mergedList = mergeList(baseList, clientList, serverList);&#10;      merged.push(mergedList);&#10;    }&#10;  }&#10;  &#10;  return merged;&#10;}&#10;&#10;function mergeList(baseList, clientList, serverList) {&#10;  const merged = {&#10;    id: clientList.id,&#10;    name: clientList.name, // Prefer client name changes&#10;    items: [],&#10;    isCompleted: serverList.isCompleted, // Server wins for completion state&#10;    completedAt: serverList.completedAt,&#10;    createdAt: baseList?.createdAt || clientList.createdAt || serverList.createdAt,&#10;    updatedAt: new Date().toISOString()&#10;  };&#10;  &#10;  // Merge items using three-way merge&#10;  merged.items = mergeItemsThreeWay(&#10;    baseList?.items || [],&#10;    clientList.items || [],&#10;    serverList.items || []&#10;  );&#10;  &#10;  return merged;&#10;}&#10;&#10;function mergeItemsThreeWay(baseItems, clientItems, serverItems) {&#10;  const merged = [];&#10;  &#10;  // Create maps for efficient lookup&#10;  const baseMap = new Map(baseItems.map(i =&gt; [i.id, i]));&#10;  const clientMap = new Map(clientItems.map(i =&gt; [i.id, i]));&#10;  const serverMap = new Map(serverItems.map(i =&gt; [i.id, i]));&#10;  &#10;  // Get all unique item IDs&#10;  const allIds = new Set([&#10;    ...baseItems.map(i =&gt; i.id),&#10;    ...clientItems.map(i =&gt; i.id),&#10;    ...serverItems.map(i =&gt; i.id)&#10;  ]);&#10;  &#10;  for (const id of allIds) {&#10;    const baseItem = baseMap.get(id);&#10;    const clientItem = clientMap.get(id);&#10;    const serverItem = serverMap.get(id);&#10;    &#10;    if (!clientItem &amp;&amp; !serverItem) {&#10;      // Item deleted by both - skip&#10;      continue;&#10;    } else if (!clientItem) {&#10;      // Item exists on server only&#10;      merged.push(serverItem);&#10;    } else if (!serverItem) {&#10;      // Item exists on client only&#10;      merged.push(clientItem);&#10;    } else {&#10;      // Item exists on both - merge properties&#10;      const mergedItem = {&#10;        ...serverItem,&#10;        // Prefer client changes for user-modifiable fields&#10;        quantity: clientItem.quantity,&#10;        notes: clientItem.notes || serverItem.notes,&#10;        actualPrice: clientItem.actualPrice !== undefined ? clientItem.actualPrice : serverItem.actualPrice,&#10;        // Server wins for structural changes&#10;        isChecked: serverItem.isChecked,&#10;        globalItemId: serverItem.globalItemId&#10;      };&#10;      merged.push(mergedItem);&#10;    }&#10;  }&#10;  &#10;  return merged;&#10;}&#10;&#10;function mergeArraysById(clientArray, serverArray, idField) {&#10;  const serverMap = new Map(serverArray.map(item =&gt; [item[idField], item]));&#10;  const clientMap = new Map(clientArray.map(item =&gt; [item[idField], item]));&#10;  &#10;  // Start with server items&#10;  const result = [...serverArray];&#10;  &#10;  // Add or update with client changes&#10;  for (const [id, clientItem] of clientMap) {&#10;    const existingIndex = result.findIndex(item =&gt; item[idField] === id);&#10;    if (existingIndex &gt;= 0) {&#10;      // Merge existing item (prefer client changes for user-editable fields)&#10;      result[existingIndex] = { &#10;        ...result[existingIndex], &#10;        ...clientItem,&#10;        updatedAt: new Date().toISOString()&#10;      };&#10;    } else {&#10;      // Add new item from client&#10;      result.push({&#10;        ...clientItem,&#10;        createdAt: clientItem.createdAt || new Date().toISOString(),&#10;        updatedAt: new Date().toISOString()&#10;      });&#10;    }&#10;  }&#10;  &#10;  return result;&#10;}&#10;&#10;// Enhanced data integrity and rollback&#10;function createDataSnapshot() {&#10;  return {&#10;    data: JSON.parse(JSON.stringify(appData)),&#10;    timestamp: new Date().toISOString(),&#10;    checksum: generateChecksum(appData)&#10;  };&#10;}&#10;&#10;const dataSnapshots = [];&#10;const MAX_SNAPSHOTS = 10;&#10;&#10;function saveSnapshot() {&#10;  const snapshot = createDataSnapshot();&#10;  dataSnapshots.push(snapshot);&#10;  &#10;  if (dataSnapshots.length &gt; MAX_SNAPSHOTS) {&#10;    dataSnapshots.shift();&#10;  }&#10;}&#10;&#10;function rollbackToSnapshot(index = -1) {&#10;  const snapshot = dataSnapshots[index] || dataSnapshots[dataSnapshots.length - 1];&#10;  if (snapshot) {&#10;    appData = JSON.parse(JSON.stringify(snapshot.data));&#10;    appData.revision += 1;&#10;    appData.lastModified = new Date().toISOString();&#10;    return true;&#10;  }&#10;  return false;&#10;}&#10;&#10;// REST endpoint: GET /data – return the entire app state&#10;app.get('/data', (req, res) =&gt; {&#10;  res.json({&#10;    ...appData,&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;});&#10;&#10;// Enhanced REST endpoint: PUT /data with better conflict resolution&#10;app.put('/data', async (req, res) =&gt; {&#10;  const { clientId, changeId, baseRevision, operations: clientOps, ...newData } = req.body || {};&#10;  &#10;  if (!validateDataStructure(newData)) {&#10;    return res.status(400).json({ message: 'Invalid data structure' });&#10;  }&#10;  &#10;  try {&#10;    let mergedData;&#10;    &#10;    if (baseRevision != null &amp;&amp; baseRevision &lt; appData.revision) {&#10;      // Client is behind - attempt to merge changes&#10;      console.log(`Conflict detected: client revision ${baseRevision}, server revision ${appData.revision}`);&#10;      mergedData = mergeOperations(baseRevision, clientOps || [], newData, clientId);&#10;      &#10;      // Return merged data for client to review&#10;      return res.status(409).json({&#10;        ...mergedData,&#10;        revision: appData.revision,&#10;        message: 'Conflicts resolved through merge'&#10;      });&#10;    } else {&#10;      // Normal update&#10;      mergedData = { ...newData };&#10;    }&#10;    &#10;    // Update server data&#10;    const oldRevision = appData.revision;&#10;    appData = {&#10;      ...mergedData,&#10;      revision: oldRevision + 1,&#10;      lastModified: new Date().toISOString(),&#10;      operations: appData.operations || []&#10;    };&#10;    &#10;    // Track this operation&#10;    if (clientOps &amp;&amp; clientOps.length &gt; 0) {&#10;      appData.operations.push(...clientOps.map(op =&gt; ({&#10;        ...op,&#10;        revision: appData.revision,&#10;        serverTimestamp: Date.now()&#10;      })));&#10;      &#10;      // Keep only recent operations (last 100)&#10;      appData.operations = appData.operations.slice(-100);&#10;    }&#10;    &#10;    await saveData(appData);&#10;    &#10;    // Broadcast to all clients except sender&#10;    io.emit('dataUpdated', {&#10;      data: appData,&#10;      clientId,&#10;      changeId,&#10;      operations: clientOps&#10;    });&#10;    &#10;    res.json({&#10;      message: 'Data updated successfully',&#10;      revision: appData.revision,&#10;      timestamp: appData.lastModified&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Error updating data:', error);&#10;    res.status(500).json({ message: 'Internal server error' });&#10;  }&#10;});&#10;&#10;// New endpoint for granular operations&#10;app.post('/operations', async (req, res) =&gt; {&#10;  const { operations, clientId } = req.body || {};&#10;  &#10;  if (!Array.isArray(operations) || !clientId) {&#10;    return res.status(400).json({ message: 'Invalid operations data' });&#10;  }&#10;  &#10;  try {&#10;    // Apply operations one by one&#10;    for (const op of operations) {&#10;      applyOperation(op);&#10;      appData.operations.push(op);&#10;    }&#10;    &#10;    appData.revision += operations.length;&#10;    appData.lastModified = new Date().toISOString();&#10;    &#10;    // Keep only recent operations&#10;    appData.operations = appData.operations.slice(-100);&#10;    &#10;    await saveData(appData);&#10;    &#10;    // Broadcast operations to other clients&#10;    io.emit('operationsApplied', {&#10;      operations,&#10;      clientId,&#10;      revision: appData.revision&#10;    });&#10;    &#10;    res.json({&#10;      message: 'Operations applied successfully',&#10;      revision: appData.revision&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Error applying operations:', error);&#10;    res.status(500).json({ message: 'Failed to apply operations' });&#10;  }&#10;});&#10;&#10;// Enhanced user presence tracking&#10;app.post('/presence', (req, res) =&gt; {&#10;  const { clientId, userId, action, listId, itemId } = req.body || {};&#10;  &#10;  if (!clientId) {&#10;    return res.status(400).json({ message: 'Client ID required' });&#10;  }&#10;  &#10;  const user = connectedUsers.get(clientId) || {&#10;    id: clientId,&#10;    userId: userId || `User-${clientId.slice(-8)}`,&#10;    connectedAt: new Date().toISOString(),&#10;    lastActivity: new Date().toISOString()&#10;  };&#10;  &#10;  user.lastActivity = new Date().toISOString();&#10;  connectedUsers.set(clientId, user);&#10;  &#10;  if (action === 'editStart' &amp;&amp; listId) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    activeEditors.set(key, {&#10;      clientId,&#10;      userId: user.userId,&#10;      startedAt: new Date().toISOString()&#10;    });&#10;  } else if (action === 'editEnd' &amp;&amp; listId) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    activeEditors.delete(key);&#10;  }&#10;  &#10;  // Broadcast presence update&#10;  io.emit('presenceUpdate', {&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;  &#10;  res.json({ message: 'Presence updated' });&#10;});&#10;&#10;// REST endpoint: POST /data/clear – reset app state&#10;app.post('/data/clear', async (req, res) =&gt; {&#10;  appData = {&#10;    lists: [],&#10;    globalItems: [],&#10;    categories: [],&#10;    archivedLists: [],&#10;    receipts: [],&#10;    revision: appData.revision + 1,&#10;    lastModified: new Date().toISOString(),&#10;    operations: []&#10;  };&#10;  await saveData(appData);&#10;  io.emit('dataUpdated', { data: appData });&#10;  res.json({ message: 'Data cleared' });&#10;});&#10;&#10;// Enhanced WebSocket connection handling&#10;io.on('connection', socket =&gt; {&#10;  const clientId = socket.handshake.query.clientId || socket.id;&#10;  &#10;  console.log(`Client connected: ${clientId}`);&#10;  &#10;  // Send initial data&#10;  socket.emit('dataUpdated', { &#10;    data: appData,&#10;    connectedUsers: Array.from(connectedUsers.values()),&#10;    activeEditors: Object.fromEntries(activeEditors)&#10;  });&#10;  &#10;  // Handle real-time operations&#10;  socket.on('operation', (operation) =&gt; {&#10;    try {&#10;      const op = { ...operation, serverTimestamp: Date.now() };&#10;      applyOperation(op);&#10;      appData.operations.push(op);&#10;      appData.revision++;&#10;      &#10;      // Broadcast to other clients&#10;      socket.broadcast.emit('operationReceived', op);&#10;    } catch (error) {&#10;      console.error('Error handling operation:', error);&#10;      socket.emit('operationError', { error: error.message });&#10;    }&#10;  });&#10;  &#10;  // Handle presence updates&#10;  socket.on('presence', (data) =&gt; {&#10;    const user = {&#10;      id: clientId,&#10;      ...data,&#10;      lastActivity: new Date().toISOString()&#10;    };&#10;    connectedUsers.set(clientId, user);&#10;    &#10;    io.emit('presenceUpdate', {&#10;      connectedUsers: Array.from(connectedUsers.values()),&#10;      activeEditors: Object.fromEntries(activeEditors)&#10;    });&#10;  });&#10;  &#10;  // Handle disconnect&#10;  socket.on('disconnect', () =&gt; {&#10;    console.log(`Client disconnected: ${clientId}`);&#10;    connectedUsers.delete(clientId);&#10;    &#10;    // Remove from active editors&#10;    for (const [key, editor] of activeEditors) {&#10;      if (editor.clientId === clientId) {&#10;        activeEditors.delete(key);&#10;      }&#10;    }&#10;    &#10;    io.emit('presenceUpdate', {&#10;      connectedUsers: Array.from(connectedUsers.values()),&#10;      activeEditors: Object.fromEntries(activeEditors)&#10;    });&#10;  });&#10;});&#10;&#10;const PORT = process.env.PORT || 3000;&#10;&#10;function startFirestoreListener() {&#10;  watchData((key, items) =&gt; {&#10;    appData[key] = items;&#10;    appData.revision++;&#10;    appData.lastModified = new Date().toISOString();&#10;    io.emit('dataUpdated', { data: appData, source: 'firestore' });&#10;  });&#10;}&#10;&#10;loadData()&#10;  .then(d =&gt; {&#10;    appData = { &#10;      ...d, &#10;      revision: 0,&#10;      lastModified: new Date().toISOString(),&#10;      operations: []&#10;    };&#10;    startFirestoreListener();&#10;    httpServer.listen(PORT, () =&gt; {&#10;      console.log(`Shopping List server running on http://localhost:${PORT}`);&#10;    });&#10;  })&#10;  .catch(err =&gt; {&#10;    console.error('Failed to load data from database', err);&#10;    appData.revision = 0;&#10;    startFirestoreListener();&#10;    httpServer.listen(PORT, () =&gt; {&#10;      console.log(`Shopping List server running on http://localhost:${PORT}`);&#10;    });&#10;  });&#10;&#10;// ...existing code...&#10;function mergeOperations(baseRevision, operations, newData, clientId) {&#10;  // Create a working copy of current server data&#10;  let mergedData = JSON.parse(JSON.stringify(appData));&#10;  &#10;  // Get operations that happened after the client's base revision&#10;  const conflictingOps = appData.operations.filter(op =&gt; &#10;    op.revision &gt; baseRevision &amp;&amp; op.clientId !== clientId&#10;  );&#10;  &#10;  if (conflictingOps.length === 0) {&#10;    // No conflicts, use client data directly&#10;    return newData;&#10;  }&#10;  &#10;  // Implement intelligent merging based on operation types&#10;  console.log(`Merging ${conflictingOps.length} conflicting operations`);&#10;  &#10;  // Use three-way merge with the base revision data&#10;  const baseData = getDataAtRevision(baseRevision) || appData;&#10;  return resolveConflicts(baseData, newData, appData);&#10;}&#10;&#10;function getDataAtRevision(revision) {&#10;  // Try to reconstruct data at specific revision from snapshots&#10;  const snapshot = dataSnapshots.find(s =&gt; &#10;    s.data.revision &lt;= revision&#10;  );&#10;  return snapshot ? snapshot.data : null;&#10;}&#10;&#10;// Enhanced endpoints for better conflict handling&#10;app.post('/data/merge', async (req, res) =&gt; {&#10;  const { clientData, baseRevision, clientId } = req.body || {};&#10;  &#10;  if (!validateDataStructure(clientData)) {&#10;    return res.status(400).json({ message: 'Invalid client data structure' });&#10;  }&#10;  &#10;  try {&#10;    // Save current state before attempting merge&#10;    saveSnapshot();&#10;    &#10;    const baseData = getDataAtRevision(baseRevision) || appData;&#10;    const mergedData = resolveConflicts(baseData, clientData, appData);&#10;    &#10;    // Validate merged result&#10;    if (!validateDataStructure(mergedData)) {&#10;      return res.status(409).json({ &#10;        message: 'Merge resulted in invalid data structure',&#10;        suggestion: 'manual_resolution_required'&#10;      });&#10;    }&#10;    &#10;    // Apply merged data&#10;    const oldRevision = appData.revision;&#10;    appData = {&#10;      ...mergedData,&#10;      revision: oldRevision + 1,&#10;      lastModified: new Date().toISOString(),&#10;      operations: appData.operations,&#10;      checksum: generateChecksum(mergedData)&#10;    };&#10;    &#10;    await saveData(appData);&#10;    &#10;    // Broadcast merged result&#10;    io.emit('dataUpdated', {&#10;      data: appData,&#10;      clientId,&#10;      mergeResult: true&#10;    });&#10;    &#10;    res.json({&#10;      message: 'Data merged successfully',&#10;      revision: appData.revision,&#10;      conflicts: [], // Could include conflict details&#10;      mergedData: appData&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Error during merge:', error);&#10;    &#10;    // Attempt rollback on merge failure&#10;    if (rollbackToSnapshot()) {&#10;      console.log('Rolled back to previous snapshot');&#10;    }&#10;    &#10;    res.status(500).json({ &#10;      message: 'Merge failed, rolled back to previous state',&#10;      error: error.message &#10;    });&#10;  }&#10;});&#10;&#10;// Endpoint for getting conflict details&#10;app.post('/data/conflicts', (req, res) =&gt; {&#10;  const { clientData, baseRevision } = req.body || {};&#10;  &#10;  try {&#10;    const baseData = getDataAtRevision(baseRevision) || appData;&#10;    const conflicts = detectConflicts(baseData, clientData, appData);&#10;    &#10;    res.json({&#10;      conflicts,&#10;      canAutoResolve: conflicts.every(c =&gt; c.autoResolvable),&#10;      suggestedResolution: conflicts.length &gt; 0 ? 'merge' : 'direct_apply'&#10;    });&#10;    &#10;  } catch (error) {&#10;    res.status(500).json({ message: 'Error detecting conflicts' });&#10;  }&#10;});&#10;&#10;function detectConflicts(baseData, clientData, serverData) {&#10;  const conflicts = [];&#10;  &#10;  // Check for list conflicts&#10;  const clientListMap = new Map((clientData.lists || []).map(l =&gt; [l.id, l]));&#10;  const serverListMap = new Map((serverData.lists || []).map(l =&gt; [l.id, l]));&#10;  const baseListMap = new Map((baseData.lists || []).map(l =&gt; [l.id, l]));&#10;  &#10;  for (const [listId, clientList] of clientListMap) {&#10;    const serverList = serverListMap.get(listId);&#10;    const baseList = baseListMap.get(listId);&#10;    &#10;    if (serverList &amp;&amp; baseList) {&#10;      // Check if both client and server modified the same list&#10;      const clientModified = JSON.stringify(clientList) !== JSON.stringify(baseList);&#10;      const serverModified = JSON.stringify(serverList) !== JSON.stringify(baseList);&#10;      &#10;      if (clientModified &amp;&amp; serverModified) {&#10;        conflicts.push({&#10;          type: 'list_modification',&#10;          listId,&#10;          clientVersion: clientList,&#10;          serverVersion: serverList,&#10;          baseVersion: baseList,&#10;          autoResolvable: isListConflictAutoResolvable(clientList, serverList, baseList)&#10;        });&#10;      }&#10;    }&#10;  }&#10;  &#10;  // Check for item conflicts within lists&#10;  for (const [listId, clientList] of clientListMap) {&#10;    const serverList = serverListMap.get(listId);&#10;    if (serverList) {&#10;      const itemConflicts = detectItemConflicts(clientList.items, serverList.items, listId);&#10;      conflicts.push(...itemConflicts);&#10;    }&#10;  }&#10;  &#10;  return conflicts;&#10;}&#10;&#10;function isListConflictAutoResolvable(clientList, serverList, baseList) {&#10;  // Simple heuristic: auto-resolvable if only one side changed the name&#10;  // and the other side only changed items&#10;  const clientNameChanged = clientList.name !== baseList.name;&#10;  const serverNameChanged = serverList.name !== baseList.name;&#10;  &#10;  if (clientNameChanged &amp;&amp; serverNameChanged) {&#10;    return false; // Both changed name - needs manual resolution&#10;  }&#10;  &#10;  return true; // Can merge automatically&#10;}&#10;&#10;function detectItemConflicts(clientItems, serverItems, listId) {&#10;  const conflicts = [];&#10;  const clientItemMap = new Map(clientItems.map(i =&gt; [i.id, i]));&#10;  const serverItemMap = new Map(serverItems.map(i =&gt; [i.id, i]));&#10;  &#10;  for (const [itemId, clientItem] of clientItemMap) {&#10;    const serverItem = serverItemMap.get(itemId);&#10;    if (serverItem) {&#10;      // Check for conflicting modifications&#10;      const hasConflict = (&#10;        clientItem.quantity !== serverItem.quantity ||&#10;        clientItem.isChecked !== serverItem.isChecked&#10;      );&#10;      &#10;      if (hasConflict) {&#10;        conflicts.push({&#10;          type: 'item_modification',&#10;          listId,&#10;          itemId,&#10;          clientVersion: clientItem,&#10;          serverVersion: serverItem,&#10;          autoResolvable: clientItem.isChecked === serverItem.isChecked // Only quantity conflicts are auto-resolvable&#10;        });&#10;      }&#10;    }&#10;  }&#10;  &#10;  return conflicts;&#10;}&#10;&#10;// Enhanced rollback endpoint&#10;app.post('/data/rollback', async (req, res) =&gt; {&#10;  const { snapshotIndex, reason } = req.body || {};&#10;  &#10;  try {&#10;    const success = rollbackToSnapshot(snapshotIndex);&#10;    &#10;    if (success) {&#10;      await saveData(appData);&#10;      &#10;      io.emit('dataUpdated', {&#10;        data: appData,&#10;        rollback: true,&#10;        reason&#10;      });&#10;      &#10;      res.json({&#10;        message: 'Successfully rolled back to previous state',&#10;        revision: appData.revision&#10;      });&#10;    } else {&#10;      res.status(404).json({ message: 'No snapshot available for rollback' });&#10;    }&#10;    &#10;  } catch (error) {&#10;    console.error('Rollback failed:', error);&#10;    res.status(500).json({ message: 'Rollback operation failed' });&#10;  }&#10;});&#10;&#10;// Health check endpoint with conflict statistics&#10;app.get('/health', (req, res) =&gt; {&#10;  const health = {&#10;    status: 'healthy',&#10;    timestamp: new Date().toISOString(),&#10;    revision: appData.revision,&#10;    connectedUsers: connectedUsers.size,&#10;    activeEditors: activeEditors.size,&#10;    pendingOperations: pendingOperations.size,&#10;    recentOperations: appData.operations.length,&#10;    snapshots: dataSnapshots.length,&#10;    uptime: process.uptime()&#10;  };&#10;  &#10;  res.json(health);&#10;});&#10;&#10;// Periodic cleanup of old operations and expired presence&#10;setInterval(() =&gt; {&#10;  // Clean up old operations (keep only last 24 hours)&#10;  const cutoff = Date.now() - (24 * 60 * 60 * 1000);&#10;  appData.operations = appData.operations.filter(op =&gt; op.timestamp &gt; cutoff);&#10;  &#10;  // Clean up inactive users (no activity for 30 minutes)&#10;  const inactiveCutoff = Date.now() - (30 * 60 * 1000);&#10;  for (const [clientId, user] of connectedUsers) {&#10;    if (new Date(user.lastActivity).getTime() &lt; inactiveCutoff) {&#10;      connectedUsers.delete(clientId);&#10;    }&#10;  }&#10;  &#10;  // Clean up stale editor locks (no activity for 5 minutes)&#10;  const editorCutoff = Date.now() - (5 * 60 * 1000);&#10;  for (const [key, editor] of activeEditors) {&#10;    if (new Date(editor.startedAt).getTime() &lt; editorCutoff) {&#10;      activeEditors.delete(key);&#10;    }&#10;  }&#10;  &#10;}, 5 * 60 * 1000); // Run every 5 minutes&#10;&#10;// Save snapshots periodically&#10;setInterval(() =&gt; {&#10;  saveSnapshot();&#10;}, 10 * 60 * 1000); // Save snapshot every 10 minutes&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shopping-list-app/dataService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shopping-list-app/dataService.js" />
              <option name="originalContent" value="// DataService provides an abstraction layer over data persistence with enhanced&#10;// conflict resolution, operational transforms, and real-time collaboration features.&#10;&#10;const STORAGE_KEY = 'shoppingListData';&#10;&#10;const DataService = {&#10;    // Configuration&#10;    useServer: true,&#10;    serverBaseUrl: window.location.origin,&#10;&#10;    // Connection state&#10;    socket: null,&#10;    isConnected: false,&#10;    &#10;    // Client identification and change tracking&#10;    clientId: Math.random().toString(36).slice(2),&#10;    pendingOperations: [],&#10;    operationQueue: [],&#10;    saveTimer: null,&#10;    lastRevision: 0,&#10;    baseRevision: 0,&#10;    &#10;    // Conflict resolution&#10;    pendingChangeIds: new Set(),&#10;    conflictResolver: null,&#10;    &#10;    // Presence tracking&#10;    connectedUsers: [],&#10;    activeEditors: {},&#10;    currentUser: null,&#10;&#10;    generateId() {&#10;        return Date.now().toString(36) + Math.random().toString(36).slice(2);&#10;    },&#10;&#10;    createOperation(type, path, data) {&#10;        return {&#10;            id: this.generateId(),&#10;            type,&#10;            path,&#10;            data: JSON.parse(JSON.stringify(data)),&#10;            clientId: this.clientId,&#10;            timestamp: Date.now()&#10;        };&#10;    },&#10;&#10;    // Enhanced merging with conflict detection&#10;    mergeData(serverData, localData) {&#10;        const merged = {&#10;            ...serverData,&#10;            lists: this.mergeLists(serverData.lists || [], localData.lists || []),&#10;            globalItems: this.mergeById(serverData.globalItems || [], localData.globalItems || []),&#10;            categories: this.mergeById(serverData.categories || [], localData.categories || []),&#10;            archivedLists: this.mergeLists(serverData.archivedLists || [], localData.archivedLists || []),&#10;            receipts: localData.receipts &amp;&amp; localData.receipts.length ? localData.receipts : (serverData.receipts || []),&#10;            revision: serverData.revision || this.lastRevision&#10;        };&#10;&#10;        // Detect conflicts and store them for user resolution if needed&#10;        const conflicts = this.detectConflicts(serverData, localData);&#10;        if (conflicts.length &gt; 0) {&#10;            merged._conflicts = conflicts;&#10;        }&#10;&#10;        return merged;&#10;    },&#10;&#10;    detectConflicts(serverData, localData) {&#10;        const conflicts = [];&#10;        &#10;        // Check for conflicting list modifications&#10;        if (serverData.lists &amp;&amp; localData.lists) {&#10;            for (const localList of localData.lists) {&#10;                const serverList = serverData.lists.find(l =&gt; l.id === localList.id);&#10;                if (serverList &amp;&amp; this.hasConflictingChanges(serverList, localList)) {&#10;                    conflicts.push({&#10;                        type: 'list_conflict',&#10;                        id: localList.id,&#10;                        serverVersion: serverList,&#10;                        localVersion: localList&#10;                    });&#10;                }&#10;            }&#10;        }&#10;        &#10;        return conflicts;&#10;    },&#10;&#10;    hasConflictingChanges(serverItem, localItem) {&#10;        // Simple heuristic: check if both have been modified recently&#10;        const serverTime = new Date(serverItem.updatedAt || 0).getTime();&#10;        const localTime = new Date(localItem.updatedAt || 0).getTime();&#10;        const timeDiff = Math.abs(serverTime - localTime);&#10;        &#10;        // Consider it a conflict if modified within 5 seconds of each other&#10;        return timeDiff &lt; 5000 &amp;&amp; serverItem.name !== localItem.name;&#10;    },&#10;&#10;    mergeById(serverArr = [], localArr = []) {&#10;        const map = new Map();&#10;        &#10;        // Add server items first&#10;        serverArr.forEach(item =&gt; {&#10;            map.set(item.id, { ...item, _source: 'server' });&#10;        });&#10;        &#10;        // Merge in local changes&#10;        localArr.forEach(item =&gt; {&#10;            const existing = map.get(item.id);&#10;            if (existing) {&#10;                // Merge fields, preferring local changes for user-modified fields&#10;                map.set(item.id, {&#10;                    ...existing,&#10;                    ...item,&#10;                    _source: 'merged',&#10;                    _serverVersion: existing&#10;                });&#10;            } else {&#10;                map.set(item.id, { ...item, _source: 'local' });&#10;            }&#10;        });&#10;        &#10;        return Array.from(map.values()).map(item =&gt; {&#10;            // Clean up merge metadata&#10;            const { _source, _serverVersion, ...cleanItem } = item;&#10;            return cleanItem;&#10;        });&#10;    },&#10;&#10;    mergeLists(serverLists = [], localLists = []) {&#10;        const map = new Map();&#10;&#10;        serverLists.forEach(list =&gt; {&#10;            map.set(list.id, JSON.parse(JSON.stringify(list)));&#10;        });&#10;&#10;        localLists.forEach(localList =&gt; {&#10;            const existing = map.get(localList.id);&#10;            if (existing) {&#10;                // Merge list properties and items&#10;                existing.name = localList.name || existing.name;&#10;                existing.isCompleted = localList.isCompleted ?? existing.isCompleted;&#10;                existing.items = this.mergeById(existing.items || [], localList.items || []);&#10;                existing.updatedAt = localList.updatedAt || existing.updatedAt;&#10;            } else {&#10;                map.set(localList.id, JSON.parse(JSON.stringify(localList)));&#10;            }&#10;        });&#10;&#10;        return Array.from(map.values());&#10;    },&#10;&#10;    /**&#10;     * Load data with enhanced conflict resolution&#10;     */&#10;    async loadData() {&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data`);&#10;                if (resp.ok) {&#10;                    const data = await resp.json();&#10;                    this.lastRevision = data.revision || 0;&#10;                    this.baseRevision = this.lastRevision;&#10;                    &#10;                    // Update presence info&#10;                    this.connectedUsers = data.connectedUsers || [];&#10;                    this.activeEditors = data.activeEditors || {};&#10;                    &#10;                    return data;&#10;                }&#10;                console.warn('Remote load failed with status', resp.status, '- falling back to localStorage');&#10;            } catch (err) {&#10;                console.error('Failed to load data from server:', err);&#10;                this.useServer = false;&#10;            }&#10;        }&#10;        &#10;        // Fallback to localStorage&#10;        try {&#10;            const jsonStr = window.localStorage.getItem(STORAGE_KEY);&#10;            if (!jsonStr) return null;&#10;            const data = JSON.parse(jsonStr);&#10;            this.lastRevision = data.revision || 0;&#10;            this.baseRevision = this.lastRevision;&#10;            return data;&#10;        } catch (err) {&#10;            console.error('Failed to load data from localStorage', err);&#10;            return null;&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Enhanced save with operational transforms and optimistic updates&#10;     */&#10;    saveData(dataObj, operations = []) {&#10;        // Apply optimistic updates immediately&#10;        this.updateLocalStorage(dataObj);&#10;        &#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            // Queue operations for batch sending&#10;            this.operationQueue.push(...operations);&#10;            &#10;            // Debounced save to server&#10;            if (!this.saveTimer) {&#10;                this.saveTimer = setTimeout(() =&gt; this.flushToServer(dataObj), 300);&#10;            }&#10;        }&#10;    },&#10;&#10;    updateLocalStorage(dataObj) {&#10;        try {&#10;            const json = JSON.stringify(dataObj);&#10;            window.localStorage.setItem(STORAGE_KEY, json);&#10;        } catch (err) {&#10;            console.error('Failed to save data to localStorage', err);&#10;        }&#10;    },&#10;&#10;    async flushToServer(dataObj) {&#10;        this.saveTimer = null;&#10;        &#10;        if (!this.operationQueue.length &amp;&amp; !dataObj) return;&#10;        &#10;        const operations = [...this.operationQueue];&#10;        this.operationQueue = [];&#10;        &#10;        const changeId = this.generateId();&#10;        this.pendingChangeIds.add(changeId);&#10;        &#10;        const payload = {&#10;            ...dataObj,&#10;            clientId: this.clientId,&#10;            changeId,&#10;            baseRevision: this.baseRevision,&#10;            operations&#10;        };&#10;        &#10;        try {&#10;            const resp = await fetch(`${this.serverBaseUrl}/data`, {&#10;                method: 'PUT',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify(payload)&#10;            });&#10;            &#10;            if (resp.status === 409) {&#10;                // Conflict detected - server sent merged data&#10;                const mergedData = await resp.json();&#10;                await this.handleConflict(mergedData, dataObj);&#10;            } else if (!resp.ok) {&#10;                console.warn('Remote save failed with status', resp.status);&#10;                this.handleSaveFailure(dataObj, operations);&#10;            } else {&#10;                // Success&#10;                const result = await resp.json();&#10;                this.lastRevision = result.revision;&#10;                this.baseRevision = this.lastRevision;&#10;                this.pendingChangeIds.delete(changeId);&#10;            }&#10;        } catch (err) {&#10;            console.error('Failed to save data to server:', err);&#10;            this.handleSaveFailure(dataObj, operations);&#10;        }&#10;    },&#10;&#10;    async handleConflict(mergedData, originalData) {&#10;        console.log('Handling conflict with merged data');&#10;        &#10;        // Update our local state with merged data&#10;        this.lastRevision = mergedData.revision;&#10;        this.baseRevision = this.lastRevision;&#10;        this.updateLocalStorage(mergedData);&#10;        &#10;        // Check if we have a conflict resolver callback&#10;        if (typeof this.conflictResolver === 'function') {&#10;            const resolved = await this.conflictResolver(mergedData, originalData);&#10;            if (resolved) {&#10;                // User resolved conflicts, save again&#10;                this.saveData(resolved);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        // Auto-accept merged data and notify UI&#10;        if (typeof window.onRemoteDataUpdated === 'function') {&#10;            window.onRemoteDataUpdated(mergedData);&#10;        }&#10;        &#10;        // Show user notification about conflict resolution&#10;        this.showConflictNotification();&#10;    },&#10;&#10;    handleSaveFailure(dataObj, operations) {&#10;        console.warn('Save failed, falling back to localStorage');&#10;        this.useServer = false;&#10;        this.updateLocalStorage(dataObj);&#10;        &#10;        // Re-queue operations for when connection is restored&#10;        this.operationQueue.unshift(...operations);&#10;    },&#10;&#10;    showConflictNotification() {&#10;        // Create a simple notification&#10;        const notification = document.createElement('div');&#10;        notification.style.cssText = `&#10;            position: fixed;&#10;            top: 20px;&#10;            right: 20px;&#10;            background: #ff9800;&#10;            color: white;&#10;            padding: 10px 20px;&#10;            border-radius: 4px;&#10;            z-index: 10000;&#10;            box-shadow: 0 2px 10px rgba(0,0,0,0.2);&#10;        `;&#10;        notification.textContent = 'Changes merged automatically due to conflicts';&#10;        document.body.appendChild(notification);&#10;&#10;        setTimeout(() =&gt; {&#10;            notification.remove();&#10;        }, 5000);&#10;    },&#10;&#10;    /**&#10;     * Send granular operations for real-time updates&#10;     */&#10;    async sendOperations(operations) {&#10;        if (!this.useServer || !operations.length) return;&#10;        &#10;        try {&#10;            const resp = await fetch(`${this.serverBaseUrl}/operations`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({&#10;                    operations,&#10;                    clientId: this.clientId&#10;                })&#10;            });&#10;            &#10;            if (resp.ok) {&#10;                const result = await resp.json();&#10;                this.lastRevision = result.revision;&#10;            }&#10;        } catch (err) {&#10;            console.error('Failed to send operations:', err);&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Enhanced presence tracking&#10;     */&#10;    async updatePresence(action, listId = null, itemId = null) {&#10;        if (!this.useServer) return;&#10;        &#10;        try {&#10;            await fetch(`${this.serverBaseUrl}/presence`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({&#10;                    clientId: this.clientId,&#10;                    userId: this.currentUser?.name || `User-${this.clientId.slice(-8)}`,&#10;                    action,&#10;                    listId,&#10;                    itemId&#10;                })&#10;            });&#10;        } catch (err) {&#10;            console.error('Failed to update presence:', err);&#10;        }&#10;    },&#10;&#10;    setCurrentUser(user) {&#10;        this.currentUser = user;&#10;    },&#10;&#10;    getActiveEditors(listId, itemId = null) {&#10;        const key = itemId ? `${listId}/${itemId}` : listId;&#10;        return this.activeEditors[key];&#10;    },&#10;&#10;    isBeingEdited(listId, itemId = null) {&#10;        const editor = this.getActiveEditors(listId, itemId);&#10;        return editor &amp;&amp; editor.clientId !== this.clientId;&#10;    },&#10;&#10;    /**&#10;     * Enhanced WebSocket initialization with presence and operations&#10;     */&#10;    initSocket() {&#10;        if (!this.useServer || !this.serverBaseUrl || this.socket) return;&#10;        &#10;        if (typeof io === 'undefined') {&#10;            console.warn('Socket.io client library not loaded');&#10;            return;&#10;        }&#10;        &#10;        this.socket = io(this.serverBaseUrl, {&#10;            query: { clientId: this.clientId }&#10;        });&#10;        &#10;        this.socket.on('connect', () =&gt; {&#10;            console.log('Connected to shopping list server');&#10;            this.isConnected = true;&#10;            &#10;            // Send initial presence&#10;            this.updatePresence('connected');&#10;        });&#10;        &#10;        this.socket.on('disconnect', () =&gt; {&#10;            console.log('Disconnected from server');&#10;            this.isConnected = false;&#10;        });&#10;        &#10;        this.socket.on('dataUpdated', (payload) =&gt; {&#10;            this.handleRemoteDataUpdate(payload);&#10;        });&#10;        &#10;        this.socket.on('operationsApplied', (payload) =&gt; {&#10;            this.handleRemoteOperations(payload);&#10;        });&#10;        &#10;        this.socket.on('operationReceived', (operation) =&gt; {&#10;            this.handleRemoteOperation(operation);&#10;        });&#10;        &#10;        this.socket.on('presenceUpdate', (payload) =&gt; {&#10;            this.connectedUsers = payload.connectedUsers || [];&#10;            this.activeEditors = payload.activeEditors || {};&#10;            &#10;            // Notify UI about presence changes&#10;            if (typeof window.onPresenceUpdated === 'function') {&#10;                window.onPresenceUpdated(this.connectedUsers, this.activeEditors);&#10;            }&#10;        });&#10;    },&#10;&#10;    handleRemoteDataUpdate(payload) {&#10;        const remoteData = payload.data || payload;&#10;        &#10;        // Ignore our own updates&#10;        if (payload.clientId === this.clientId &amp;&amp; this.pendingChangeIds.has(payload.changeId)) {&#10;            this.pendingChangeIds.delete(payload.changeId);&#10;            return;&#10;        }&#10;        &#10;        // Check revision to avoid stale updates&#10;        if (remoteData.revision != null &amp;&amp; remoteData.revision &lt;= this.lastRevision) {&#10;            return;&#10;        }&#10;        &#10;        this.lastRevision = remoteData.revision || this.lastRevision;&#10;        this.baseRevision = this.lastRevision;&#10;        &#10;        try {&#10;            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(remoteData));&#10;        } catch (err) {&#10;            console.error('Failed to update localStorage from server', err);&#10;        }&#10;        &#10;        if (typeof window.onRemoteDataUpdated === 'function') {&#10;            window.onRemoteDataUpdated(remoteData);&#10;        }&#10;    },&#10;&#10;    handleRemoteOperations(payload) {&#10;        if (payload.clientId === this.clientId) return;&#10;        &#10;        // Apply operations and notify UI&#10;        this.lastRevision = payload.revision;&#10;        &#10;        if (typeof window.onRemoteOperationsApplied === 'function') {&#10;            window.onRemoteOperationsApplied(payload.operations);&#10;        }&#10;    },&#10;&#10;    handleRemoteOperation(operation) {&#10;        if (operation.clientId === this.clientId) return;&#10;        &#10;        // Apply single operation and notify UI&#10;        if (typeof window.onRemoteOperationReceived === 'function') {&#10;            window.onRemoteOperationReceived(operation);&#10;        }&#10;    },&#10;&#10;    async clearData() {&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data/clear`, { method: 'POST' });&#10;                if (resp.ok) {&#10;                    this.lastRevision = 0;&#10;                    this.baseRevision = 0;&#10;                    return;&#10;                }&#10;                console.warn('Remote clear failed with status', resp.status);&#10;            } catch (err) {&#10;                console.error('Failed to clear data via server:', err);&#10;            }&#10;        }&#10;        &#10;        try {&#10;            window.localStorage.removeItem(STORAGE_KEY);&#10;            this.lastRevision = 0;&#10;            this.baseRevision = 0;&#10;        } catch (err) {&#10;            console.error('Failed to clear localStorage', err);&#10;        }&#10;    }&#10;};&#10;&#10;// Global exposure&#10;window.DataService = DataService;&#10;" />
              <option name="updatedContent" value="// DataService provides an abstraction layer over data persistence with enhanced&#10;// conflict resolution, operational transforms, and real-time collaboration features.&#10;&#10;const STORAGE_KEY = 'shoppingListData';&#10;&#10;const DataService = {&#10;    // Configuration&#10;    useServer: true,&#10;    serverBaseUrl: window.location.origin,&#10;&#10;    // Connection state&#10;    socket: null,&#10;    isConnected: false,&#10;    &#10;    // Client identification and change tracking&#10;    clientId: Math.random().toString(36).slice(2),&#10;    pendingOperations: [],&#10;    operationQueue: [],&#10;    saveTimer: null,&#10;    lastRevision: 0,&#10;    baseRevision: 0,&#10;    &#10;    // Enhanced conflict resolution&#10;    pendingChangeIds: new Set(),&#10;    conflictResolver: null,&#10;    retryQueue: [],&#10;    maxRetries: 3,&#10;    &#10;    // Presence tracking&#10;    connectedUsers: [],&#10;    activeEditors: {},&#10;    currentUser: null,&#10;&#10;    // Connection management&#10;    connectionState: 'disconnected', // disconnected, connecting, connected, error&#10;    reconnectAttempts: 0,&#10;    maxReconnectAttempts: 5,&#10;    reconnectDelay: 1000,&#10;&#10;    generateId() {&#10;        return Date.now().toString(36) + Math.random().toString(36).slice(2);&#10;    },&#10;&#10;    createOperation(type, path, data) {&#10;        return {&#10;            id: this.generateId(),&#10;            type,&#10;            path,&#10;            data: JSON.parse(JSON.stringify(data)),&#10;            clientId: this.clientId,&#10;            timestamp: Date.now(),&#10;            baseRevision: this.baseRevision&#10;        };&#10;    },&#10;&#10;    // Enhanced merging with better conflict detection&#10;    mergeData(serverData, localData) {&#10;        const merged = {&#10;            ...serverData,&#10;            lists: this.mergeListsAdvanced(serverData.lists || [], localData.lists || []),&#10;            globalItems: this.mergeById(serverData.globalItems || [], localData.globalItems || []),&#10;            categories: this.mergeById(serverData.categories || [], localData.categories || []),&#10;            archivedLists: this.mergeListsAdvanced(serverData.archivedLists || [], localData.archivedLists || []),&#10;            receipts: localData.receipts &amp;&amp; localData.receipts.length ? localData.receipts : (serverData.receipts || []),&#10;            revision: serverData.revision || this.lastRevision&#10;        };&#10;&#10;        // Detect conflicts and store them for user resolution if needed&#10;        const conflicts = this.detectConflicts(serverData, localData);&#10;        if (conflicts.length &gt; 0) {&#10;            merged._conflicts = conflicts;&#10;        }&#10;&#10;        return merged;&#10;    },&#10;&#10;    mergeListsAdvanced(serverLists, localLists) {&#10;        const map = new Map();&#10;        &#10;        // Add server lists first&#10;        serverLists.forEach(list =&gt; {&#10;            map.set(list.id, { &#10;                ...list, &#10;                _source: 'server',&#10;                _lastModified: list.updatedAt || list.createdAt&#10;            });&#10;        });&#10;        &#10;        // Merge in local changes with conflict detection&#10;        localLists.forEach(localList =&gt; {&#10;            const existing = map.get(localList.id);&#10;            if (existing) {&#10;                // Advanced merging with timestamp comparison&#10;                const serverTime = new Date(existing._lastModified || 0).getTime();&#10;                const localTime = new Date(localList.updatedAt || localList.createdAt || 0).getTime();&#10;                &#10;                if (localTime &gt; serverTime) {&#10;                    // Local is newer, use local data but merge items carefully&#10;                    map.set(localList.id, {&#10;                        ...existing,&#10;                        ...localList,&#10;                        items: this.mergeItemsAdvanced(existing.items || [], localList.items || []),&#10;                        _source: 'merged',&#10;                        _serverVersion: existing&#10;                    });&#10;                } else {&#10;                    // Server is newer or same, but still merge items&#10;                    map.set(localList.id, {&#10;                        ...existing,&#10;                        items: this.mergeItemsAdvanced(existing.items || [], localList.items || []),&#10;                        _source: 'server_preferred'&#10;                    });&#10;                }&#10;            } else {&#10;                map.set(localList.id, { ...localList, _source: 'local' });&#10;            }&#10;        });&#10;        &#10;        return Array.from(map.values()).map(list =&gt; {&#10;            // Clean up merge metadata&#10;            const { _source, _serverVersion, _lastModified, ...cleanList } = list;&#10;            return cleanList;&#10;        });&#10;    },&#10;&#10;    mergeItemsAdvanced(serverItems, localItems) {&#10;        const map = new Map();&#10;        &#10;        // Add server items&#10;        serverItems.forEach(item =&gt; {&#10;            map.set(item.id, { ...item, _source: 'server' });&#10;        });&#10;        &#10;        // Merge local items with intelligent conflict resolution&#10;        localItems.forEach(localItem =&gt; {&#10;            const existing = map.get(localItem.id);&#10;            if (existing) {&#10;                // Merge item properties intelligently&#10;                const merged = {&#10;                    ...existing,&#10;                    // Prefer local changes for user-modifiable fields&#10;                    quantity: localItem.quantity,&#10;                    notes: localItem.notes || existing.notes,&#10;                    actualPrice: localItem.actualPrice !== undefined ? localItem.actualPrice : existing.actualPrice,&#10;                    // Use server state for collaborative fields&#10;                    isChecked: existing.isChecked,&#10;                    _source: 'merged'&#10;                };&#10;                map.set(localItem.id, merged);&#10;            } else {&#10;                map.set(localItem.id, { ...localItem, _source: 'local' });&#10;            }&#10;        });&#10;        &#10;        return Array.from(map.values()).map(item =&gt; {&#10;            const { _source, ...cleanItem } = item;&#10;            return cleanItem;&#10;        });&#10;    },&#10;&#10;    detectConflicts(serverData, localData) {&#10;        const conflicts = [];&#10;        &#10;        // Check for conflicting list modifications&#10;        if (serverData.lists &amp;&amp; localData.lists) {&#10;            for (const localList of localData.lists) {&#10;                const serverList = serverData.lists.find(l =&gt; l.id === localList.id);&#10;                if (serverList &amp;&amp; this.hasConflictingChanges(serverList, localList)) {&#10;                    conflicts.push({&#10;                        type: 'list_conflict',&#10;                        id: localList.id,&#10;                        serverVersion: serverList,&#10;                        localVersion: localList,&#10;                        autoResolvable: this.isConflictAutoResolvable(serverList, localList)&#10;                    });&#10;                }&#10;            }&#10;        }&#10;        &#10;        return conflicts;&#10;    },&#10;&#10;    hasConflictingChanges(serverItem, localItem) {&#10;        // Enhanced conflict detection with multiple criteria&#10;        const serverTime = new Date(serverItem.updatedAt || 0).getTime();&#10;        const localTime = new Date(localItem.updatedAt || 0).getTime();&#10;        const timeDiff = Math.abs(serverTime - localTime);&#10;        &#10;        // Consider it a conflict if:&#10;        // 1. Modified within 30 seconds of each other AND&#10;        // 2. Different names OR different item counts&#10;        return timeDiff &lt; 30000 &amp;&amp; (&#10;            serverItem.name !== localItem.name ||&#10;            (serverItem.items?.length || 0) !== (localItem.items?.length || 0)&#10;        );&#10;    },&#10;&#10;    isConflictAutoResolvable(serverItem, localItem) {&#10;        // Auto-resolvable if only one type of change occurred&#10;        const nameChanged = serverItem.name !== localItem.name;&#10;        const itemsChanged = JSON.stringify(serverItem.items || []) !== JSON.stringify(localItem.items || []);&#10;        &#10;        // Can auto-resolve if only one aspect changed&#10;        return nameChanged !== itemsChanged;&#10;    },&#10;&#10;    mergeById(serverArr = [], localArr = []) {&#10;        const map = new Map();&#10;        &#10;        // Add server items first&#10;        serverArr.forEach(item =&gt; {&#10;            map.set(item.id, { ...item, _source: 'server' });&#10;        });&#10;        &#10;        // Merge in local changes&#10;        localArr.forEach(item =&gt; {&#10;            const existing = map.get(item.id);&#10;            if (existing) {&#10;                // Merge fields, preferring local changes for user-modified fields&#10;                map.set(item.id, {&#10;                    ...existing,&#10;                    ...item,&#10;                    _source: 'merged',&#10;                    _serverVersion: existing&#10;                });&#10;            } else {&#10;                map.set(item.id, { ...item, _source: 'local' });&#10;            }&#10;        });&#10;        &#10;        return Array.from(map.values()).map(item =&gt; {&#10;            // Clean up merge metadata&#10;            const { _source, _serverVersion, ...cleanItem } = item;&#10;            return cleanItem;&#10;        });&#10;    },&#10;&#10;    /**&#10;     * Enhanced load data with connection state management&#10;     */&#10;    async loadData() {&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                this.connectionState = 'connecting';&#10;                const resp = await fetch(`${this.serverBaseUrl}/data`);&#10;                &#10;                if (resp.ok) {&#10;                    const data = await resp.json();&#10;                    this.lastRevision = data.revision || 0;&#10;                    this.baseRevision = this.lastRevision;&#10;                    this.connectionState = 'connected';&#10;                    this.reconnectAttempts = 0;&#10;                    &#10;                    // Update presence info&#10;                    this.connectedUsers = data.connectedUsers || [];&#10;                    this.activeEditors = data.activeEditors || {};&#10;                    &#10;                    return data;&#10;                }&#10;                &#10;                console.warn('Remote load failed with status', resp.status, '- falling back to localStorage');&#10;                this.connectionState = 'error';&#10;            } catch (err) {&#10;                console.error('Failed to load data from server:', err);&#10;                this.connectionState = 'error';&#10;                this.useServer = false;&#10;                this.scheduleReconnect();&#10;            }&#10;        }&#10;        &#10;        // Fallback to localStorage&#10;        try {&#10;            const jsonStr = window.localStorage.getItem(STORAGE_KEY);&#10;            if (!jsonStr) return null;&#10;            const data = JSON.parse(jsonStr);&#10;            this.lastRevision = data.revision || 0;&#10;            this.baseRevision = this.lastRevision;&#10;            return data;&#10;        } catch (err) {&#10;            console.error('Failed to load data from localStorage', err);&#10;            return null;&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Enhanced save with retry logic and conflict resolution&#10;     */&#10;    saveData(dataObj, operations = []) {&#10;        // Apply optimistic updates immediately&#10;        this.updateLocalStorage(dataObj);&#10;        &#10;        if (this.useServer &amp;&amp; this.serverBaseUrl &amp;&amp; this.connectionState === 'connected') {&#10;            // Queue operations for batch sending&#10;            this.operationQueue.push(...operations);&#10;            &#10;            // Debounced save to server with retry logic&#10;            if (!this.saveTimer) {&#10;                this.saveTimer = setTimeout(() =&gt; this.flushToServerWithRetry(dataObj), 300);&#10;            }&#10;        } else if (this.useServer &amp;&amp; this.connectionState === 'error') {&#10;            // Queue for retry when connection is restored&#10;            this.retryQueue.push({ dataObj, operations, timestamp: Date.now() });&#10;        }&#10;    },&#10;&#10;    async flushToServerWithRetry(dataObj, retryCount = 0) {&#10;        this.saveTimer = null;&#10;        &#10;        if (!this.operationQueue.length &amp;&amp; !dataObj) return;&#10;        &#10;        const operations = [...this.operationQueue];&#10;        this.operationQueue = [];&#10;        &#10;        const changeId = this.generateId();&#10;        this.pendingChangeIds.add(changeId);&#10;        &#10;        const payload = {&#10;            ...dataObj,&#10;            clientId: this.clientId,&#10;            changeId,&#10;            baseRevision: this.baseRevision,&#10;            operations&#10;        };&#10;        &#10;        try {&#10;            const resp = await fetch(`${this.serverBaseUrl}/data`, {&#10;                method: 'PUT',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify(payload)&#10;            });&#10;            &#10;            if (resp.status === 409) {&#10;                // Conflict detected - server sent merged data&#10;                const mergedData = await resp.json();&#10;                await this.handleConflict(mergedData, dataObj);&#10;            } else if (!resp.ok) {&#10;                throw new Error(`Server responded with status ${resp.status}`);&#10;            } else {&#10;                // Success&#10;                const result = await resp.json();&#10;                this.lastRevision = result.revision;&#10;                this.baseRevision = this.lastRevision;&#10;                this.pendingChangeIds.delete(changeId);&#10;                &#10;                // Process any queued retries&#10;                this.processRetryQueue();&#10;            }&#10;        } catch (err) {&#10;            console.error('Failed to save data to server:', err);&#10;            &#10;            if (retryCount &lt; this.maxRetries) {&#10;                console.log(`Retrying save attempt ${retryCount + 1}/${this.maxRetries}`);&#10;                setTimeout(() =&gt; {&#10;                    this.flushToServerWithRetry(dataObj, retryCount + 1);&#10;                }, Math.pow(2, retryCount) * 1000); // Exponential backoff&#10;            } else {&#10;                this.handleSaveFailure(dataObj, operations);&#10;            }&#10;        }&#10;    },&#10;&#10;    async processRetryQueue() {&#10;        if (this.retryQueue.length === 0) return;&#10;        &#10;        console.log(`Processing ${this.retryQueue.length} queued operations`);&#10;        &#10;        // Sort by timestamp and process in order&#10;        this.retryQueue.sort((a, b) =&gt; a.timestamp - b.timestamp);&#10;        &#10;        for (const { dataObj, operations } of this.retryQueue) {&#10;            try {&#10;                await this.flushToServerWithRetry(dataObj);&#10;            } catch (err) {&#10;                console.error('Failed to process queued operation:', err);&#10;            }&#10;        }&#10;        &#10;        this.retryQueue = [];&#10;    },&#10;&#10;    async handleConflict(mergedData, originalData) {&#10;        console.log('Handling conflict with merged data');&#10;        &#10;        // Update our local state with merged data&#10;        this.lastRevision = mergedData.revision;&#10;        this.baseRevision = this.lastRevision;&#10;        this.updateLocalStorage(mergedData);&#10;        &#10;        // Check if we have a conflict resolver callback&#10;        if (typeof this.conflictResolver === 'function') {&#10;            const resolved = await this.conflictResolver(mergedData, originalData);&#10;            if (resolved) {&#10;                // User resolved conflicts, save again&#10;                this.saveData(resolved);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        // Auto-accept merged data and notify UI&#10;        if (typeof window.onRemoteDataUpdated === 'function') {&#10;            window.onRemoteDataUpdated(mergedData);&#10;        }&#10;        &#10;        // Show user notification about conflict resolution&#10;        this.showConflictNotification();&#10;    },&#10;&#10;    scheduleReconnect() {&#10;        if (this.reconnectAttempts &gt;= this.maxReconnectAttempts) {&#10;            console.log('Max reconnection attempts reached');&#10;            return;&#10;        }&#10;        &#10;        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts);&#10;        console.log(`Scheduling reconnection attempt ${this.reconnectAttempts + 1} in ${delay}ms`);&#10;        &#10;        setTimeout(async () =&gt; {&#10;            this.reconnectAttempts++;&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/health`);&#10;                if (resp.ok) {&#10;                    console.log('Server connection restored');&#10;                    this.useServer = true;&#10;                    this.connectionState = 'connected';&#10;                    this.reconnectAttempts = 0;&#10;                    &#10;                    // Process any queued operations&#10;                    this.processRetryQueue();&#10;                    &#10;                    // Reinitialize socket connection&#10;                    this.initSocket();&#10;                } else {&#10;                    this.scheduleReconnect();&#10;                }&#10;            } catch (err) {&#10;                console.log('Reconnection failed, will retry');&#10;                this.scheduleReconnect();&#10;            }&#10;        }, delay);&#10;    },&#10;&#10;    /**&#10;     * Send granular operations for real-time updates&#10;     */&#10;    async sendOperations(operations) {&#10;        if (!this.useServer || !operations.length) return;&#10;        &#10;        try {&#10;            const resp = await fetch(`${this.serverBaseUrl}/operations`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({&#10;                    operations,&#10;                    clientId: this.clientId&#10;                })&#10;            });&#10;            &#10;            if (resp.ok) {&#10;                const result = await resp.json();&#10;                this.lastRevision = result.revision;&#10;            }&#10;        } catch (err) {&#10;            console.error('Failed to send operations:', err);&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Enhanced presence tracking&#10;     */&#10;    async updatePresence(action, listId = null, itemId = null) {&#10;        if (!this.useServer) return;&#10;        &#10;        try {&#10;            await fetch(`${this.serverBaseUrl}/presence`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({&#10;                    clientId: this.clientId,&#10;                    userId: this.currentUser?.name || `User-${this.clientId.slice(-8)}`,&#10;                    action,&#10;                    listId,&#10;                    itemId&#10;                })&#10;            });&#10;        } catch (err) {&#10;            console.error('Failed to update presence:', err);&#10;        }&#10;    },&#10;&#10;    setCurrentUser(user) {&#10;        this.currentUser = user;&#10;    },&#10;&#10;    getActiveEditors(listId, itemId = null) {&#10;        const key = itemId ? `${listId}/${itemId}` : listId;&#10;        return this.activeEditors[key];&#10;    },&#10;&#10;    isBeingEdited(listId, itemId = null) {&#10;        const editor = this.getActiveEditors(listId, itemId);&#10;        return editor &amp;&amp; editor.clientId !== this.clientId;&#10;    },&#10;&#10;    /**&#10;     * Enhanced WebSocket initialization with presence and operations&#10;     */&#10;    initSocket() {&#10;        if (!this.useServer || !this.serverBaseUrl || this.socket) return;&#10;        &#10;        if (typeof io === 'undefined') {&#10;            console.warn('Socket.io client library not loaded');&#10;            return;&#10;        }&#10;        &#10;        this.socket = io(this.serverBaseUrl, {&#10;            query: { clientId: this.clientId }&#10;        });&#10;        &#10;        this.socket.on('connect', () =&gt; {&#10;            console.log('Connected to shopping list server');&#10;            this.isConnected = true;&#10;            &#10;            // Send initial presence&#10;            this.updatePresence('connected');&#10;        });&#10;        &#10;        this.socket.on('disconnect', () =&gt; {&#10;            console.log('Disconnected from server');&#10;            this.isConnected = false;&#10;        });&#10;        &#10;        this.socket.on('dataUpdated', (payload) =&gt; {&#10;            this.handleRemoteDataUpdate(payload);&#10;        });&#10;        &#10;        this.socket.on('operationsApplied', (payload) =&gt; {&#10;            this.handleRemoteOperations(payload);&#10;        });&#10;        &#10;        this.socket.on('operationReceived', (operation) =&gt; {&#10;            this.handleRemoteOperation(operation);&#10;        });&#10;        &#10;        this.socket.on('presenceUpdate', (payload) =&gt; {&#10;            this.connectedUsers = payload.connectedUsers || [];&#10;            this.activeEditors = payload.activeEditors || {};&#10;            &#10;            // Notify UI about presence changes&#10;            if (typeof window.onPresenceUpdated === 'function') {&#10;                window.onPresenceUpdated(this.connectedUsers, this.activeEditors);&#10;            }&#10;        });&#10;    },&#10;&#10;    handleRemoteDataUpdate(payload) {&#10;        const remoteData = payload.data || payload;&#10;        &#10;        // Ignore our own updates&#10;        if (payload.clientId === this.clientId &amp;&amp; this.pendingChangeIds.has(payload.changeId)) {&#10;            this.pendingChangeIds.delete(payload.changeId);&#10;            return;&#10;        }&#10;        &#10;        // Check revision to avoid stale updates&#10;        if (remoteData.revision != null &amp;&amp; remoteData.revision &lt;= this.lastRevision) {&#10;            return;&#10;        }&#10;        &#10;        this.lastRevision = remoteData.revision || this.lastRevision;&#10;        this.baseRevision = this.lastRevision;&#10;        &#10;        try {&#10;            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(remoteData));&#10;        } catch (err) {&#10;            console.error('Failed to update localStorage from server', err);&#10;        }&#10;        &#10;        if (typeof window.onRemoteDataUpdated === 'function') {&#10;            window.onRemoteDataUpdated(remoteData);&#10;        }&#10;    },&#10;&#10;    handleRemoteOperations(payload) {&#10;        if (payload.clientId === this.clientId) return;&#10;        &#10;        // Apply operations and notify UI&#10;        this.lastRevision = payload.revision;&#10;        &#10;        if (typeof window.onRemoteOperationsApplied === 'function') {&#10;            window.onRemoteOperationsApplied(payload.operations);&#10;        }&#10;    },&#10;&#10;    handleRemoteOperation(operation) {&#10;        if (operation.clientId === this.clientId) return;&#10;        &#10;        // Apply single operation and notify UI&#10;        if (typeof window.onRemoteOperationReceived === 'function') {&#10;            window.onRemoteOperationReceived(operation);&#10;        }&#10;    },&#10;&#10;    async clearData() {&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data/clear`, { method: 'POST' });&#10;                if (resp.ok) {&#10;                    this.lastRevision = 0;&#10;                    this.baseRevision = 0;&#10;                    return;&#10;                }&#10;                console.warn('Remote clear failed with status', resp.status);&#10;            } catch (err) {&#10;                console.error('Failed to clear data via server:', err);&#10;            }&#10;        }&#10;        &#10;        try {&#10;            window.localStorage.removeItem(STORAGE_KEY);&#10;            this.lastRevision = 0;&#10;            this.baseRevision = 0;&#10;        } catch (err) {&#10;            console.error('Failed to clear localStorage', err);&#10;        }&#10;    },&#10;&#10;    updateLocalStorage(dataObj) {&#10;        try {&#10;            const json = JSON.stringify(dataObj);&#10;            window.localStorage.setItem(STORAGE_KEY, json);&#10;        } catch (err) {&#10;            console.error('Failed to save data to localStorage', err);&#10;        }&#10;    },&#10;&#10;    handleSaveFailure(dataObj, operations) {&#10;        console.warn('Save failed, falling back to localStorage');&#10;        this.connectionState = 'error';&#10;        this.updateLocalStorage(dataObj);&#10;        &#10;        // Re-queue operations for when connection is restored&#10;        this.operationQueue.unshift(...operations);&#10;        &#10;        // Schedule reconnection attempt&#10;        this.scheduleReconnect();&#10;    },&#10;&#10;    showConflictNotification() {&#10;        // Create a more sophisticated notification with action buttons&#10;        const notification = document.createElement('div');&#10;        notification.style.cssText = `&#10;            position: fixed;&#10;            top: 20px;&#10;            right: 20px;&#10;            background: linear-gradient(135deg, #ff9800, #f57c00);&#10;            color: white;&#10;            padding: 16px 20px;&#10;            border-radius: 8px;&#10;            z-index: 10000;&#10;            box-shadow: 0 4px 20px rgba(0,0,0,0.3);&#10;            max-width: 350px;&#10;            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;&#10;        `;&#10;        &#10;        notification.innerHTML = `&#10;            &lt;div style=&quot;display: flex; align-items: flex-start; gap: 12px;&quot;&gt;&#10;                &lt;div style=&quot;flex-shrink: 0; font-size: 20px;&quot;&gt;⚠️&lt;/div&gt;&#10;                &lt;div style=&quot;flex: 1;&quot;&gt;&#10;                    &lt;div style=&quot;font-weight: 600; margin-bottom: 4px;&quot;&gt;Changes Merged&lt;/div&gt;&#10;                    &lt;div style=&quot;font-size: 14px; opacity: 0.9; line-height: 1.4;&quot;&gt;&#10;                        Your changes were automatically merged with updates from other users.&#10;                    &lt;/div&gt;&#10;                    &lt;button onclick=&quot;this.parentElement.parentElement.parentElement.remove()&quot; &#10;                            style=&quot;margin-top: 8px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;&quot;&gt;&#10;                        Dismiss&#10;                    &lt;/button&gt;&#10;                &lt;/div&gt;&#10;                &lt;button onclick=&quot;this.parentElement.parentElement.remove()&quot; &#10;                        style=&quot;background: none; border: none; color: white; cursor: pointer; font-size: 18px; line-height: 1;&quot;&gt;×&lt;/button&gt;&#10;            &lt;/div&gt;&#10;        `;&#10;        &#10;        document.body.appendChild(notification);&#10;        &#10;        // Auto-dismiss after 8 seconds&#10;        setTimeout(() =&gt; {&#10;            if (notification.parentNode) {&#10;                notification.remove();&#10;            }&#10;        }, 8000);&#10;    },&#10;&#10;    /**&#10;     * Enhanced connection status indicator&#10;     */&#10;    getConnectionStatus() {&#10;        return {&#10;            state: this.connectionState,&#10;            isConnected: this.isConnected,&#10;            reconnectAttempts: this.reconnectAttempts,&#10;            pendingOperations: this.operationQueue.length + this.retryQueue.length,&#10;            lastRevision: this.lastRevision,&#10;            connectedUsers: this.connectedUsers.length&#10;        };&#10;    },&#10;&#10;    /**&#10;     * Manual conflict resolution helper&#10;     */&#10;    async resolveConflict(conflictData, resolution) {&#10;        try {&#10;            const resp = await fetch(`${this.serverBaseUrl}/data/merge`, {&#10;                method: 'POST',&#10;                headers: { 'Content-Type': 'application/json' },&#10;                body: JSON.stringify({&#10;                    clientData: resolution,&#10;                    baseRevision: this.baseRevision,&#10;                    clientId: this.clientId&#10;                })&#10;            });&#10;            &#10;            if (resp.ok) {&#10;                const result = await resp.json();&#10;                this.lastRevision = result.revision;&#10;                this.baseRevision = this.lastRevision;&#10;                &#10;                if (typeof window.onRemoteDataUpdated === 'function') {&#10;                    window.onRemoteDataUpdated(result.mergedData);&#10;                }&#10;                &#10;                return result;&#10;            } else {&#10;                throw new Error(`Merge failed with status ${resp.status}`);&#10;            }&#10;        } catch (err) {&#10;            console.error('Failed to resolve conflict:', err);&#10;            throw err;&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Batch operation helper for complex updates&#10;     */&#10;    createBatchOperation(operations) {&#10;        return {&#10;            id: this.generateId(),&#10;            type: 'batch',&#10;            operations: operations.map(op =&gt; ({&#10;                ...op,&#10;                clientId: this.clientId,&#10;                timestamp: Date.now()&#10;            })),&#10;            clientId: this.clientId,&#10;            timestamp: Date.now(),&#10;            baseRevision: this.baseRevision&#10;        };&#10;    },&#10;&#10;    /**&#10;     * Data validation helper&#10;     */&#10;    validateData(data) {&#10;        if (!data || typeof data !== 'object') return false;&#10;        &#10;        const requiredFields = ['lists', 'globalItems', 'categories', 'archivedLists', 'receipts'];&#10;        for (const field of requiredFields) {&#10;            if (!Array.isArray(data[field])) return false;&#10;        }&#10;        &#10;        // Validate lists structure&#10;        for (const list of data.lists) {&#10;            if (!list.id || !list.name || !Array.isArray(list.items)) return false;&#10;            &#10;            for (const item of list.items) {&#10;                if (!item.id || !item.globalItemId) return false;&#10;                if (typeof item.quantity !== 'number' || item.quantity &lt;= 0) return false;&#10;            }&#10;        }&#10;        &#10;        return true;&#10;    },&#10;&#10;    /**&#10;     * Performance monitoring&#10;     */&#10;    getPerformanceMetrics() {&#10;        return {&#10;            totalOperations: this.pendingOperations.length,&#10;            queuedOperations: this.operationQueue.length,&#10;            retryQueueSize: this.retryQueue.length,&#10;            pendingChanges: this.pendingChangeIds.size,&#10;            connectionState: this.connectionState,&#10;            lastSyncTime: this.lastRevision,&#10;            reconnectAttempts: this.reconnectAttempts&#10;        };&#10;    }&#10;};&#10;&#10;// Global exposure&#10;window.DataService = DataService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/shopping-list-app/script.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shopping-list-app/script.js" />
              <option name="originalContent" value="// Simple Shopping List App in vanilla JS with enhanced collaboration features&#10;// Data is stored via DataService with real-time synchronization and conflict resolution.&#10;&#10;// Translation strings for English and Hebrew&#10;const translations = {&#10;    en: {&#10;        app_title: &quot;Shopping List&quot;,&#10;        language_label: &quot;Language:&quot;,&#10;        tab_lists: &quot;Lists&quot;,&#10;        tab_summary: &quot;Summary&quot;,&#10;        tab_settings: &quot;Settings&quot;,&#10;        lists_title: &quot;Your Lists&quot;,&#10;        add_list: &quot;New List&quot;,&#10;        summary_title: &quot;Purchase Summary&quot;,&#10;        settings_title: &quot;Settings&quot;,&#10;        currency_label: &quot;Default currency symbol:&quot;,&#10;        modal_new_list: &quot;Create List&quot;,&#10;        modal_edit_list: &quot;Edit List&quot;,&#10;        list_name_label: &quot;List name:&quot;,&#10;        save: &quot;Save&quot;,&#10;        cancel: &quot;Cancel&quot;,&#10;        item_modal_new: &quot;Add Item&quot;,&#10;        item_modal_edit: &quot;Edit Item&quot;,&#10;        item_name: &quot;Item name:&quot;,&#10;        item_category: &quot;Category:&quot;,&#10;        item_quantity: &quot;Quantity:&quot;,&#10;        item_price: &quot;Est. price:&quot;,&#10;        item_notes: &quot;Notes:&quot;,&#10;        add_item: &quot;Add Item&quot;,&#10;        close: &quot;Close&quot;,&#10;        manage_items: &quot;Manage Items&quot;,&#10;        rename_list: &quot;Rename&quot;,&#10;        edit_global_item: &quot;Edit&quot;,&#10;        delete_list: &quot;Delete&quot;,&#10;        category_produce: &quot;Produce&quot;,&#10;        category_dairy: &quot;Dairy&quot;,&#10;        category_meat: &quot;Meat&quot;,&#10;        category_bakery: &quot;Bakery&quot;,&#10;        category_beverages: &quot;Beverages&quot;,&#10;        category_other: &quot;Other&quot;,&#10;        purchased: &quot;Purchased&quot;,&#10;        missing: &quot;Missing&quot;,&#10;        total_cost: &quot;Total cost&quot;,&#10;        create_from_missing: &quot;Create list from missing items&quot;&#10;        ,&#10;        receipt_label: &quot;Upload receipt(s):&quot;,&#10;        search_placeholder: &quot;Search items&quot;,&#10;        tab_items: &quot;Global Items&quot;,&#10;        tab_archive: &quot;Archive&quot;,&#10;        items_title: &quot;Global Items&quot;,&#10;        add_global_item: &quot;New Global Item&quot;,&#10;        global_name: &quot;Item name:&quot;,&#10;        global_category: &quot;Category:&quot;,&#10;        global_price: &quot;Estimated price:&quot;,&#10;        global_unit: &quot;Price unit:&quot;,&#10;        archive_title: &quot;Purchase Archive&quot;&#10;        ,&#10;        modal_new_global_item: &quot;Create Global Item&quot;,&#10;        modal_edit_global_item: &quot;Edit Global Item&quot;&#10;        ,&#10;        item_unit: &quot;Unit:&quot;,&#10;        item_price_basis: &quot;Price basis quantity:&quot;,&#10;        import_title: &quot;Import from Google Keep&quot;,&#10;        import_label: &quot;Paste your Keep note here:&quot;,&#10;        import_button: &quot;Import&quot;,&#10;        export_csv: &quot;Export to CSV&quot;,&#10;        archive_view: &quot;View&quot;,&#10;        archive_edit: &quot;Edit&quot;&#10;        ,&#10;        complete_list: &quot;Complete&quot;&#10;        ,&#10;        categories_title: &quot;Categories&quot;,&#10;        add_category: &quot;Add Category&quot;&#10;        ,&#10;        clear_data: &quot;Clear All Data&quot;,&#10;        confirm_clear: &quot;Are you sure you want to clear all data? This cannot be undone.&quot;,&#10;        share_link: &quot;Copy Link&quot;,&#10;        maximize: &quot;Maximize&quot;,&#10;        restore: &quot;Restore&quot;,&#10;        check_all: &quot;Check All&quot;,&#10;        uncheck_all: &quot;Uncheck All&quot;,&#10;        undo: &quot;Undo&quot;,&#10;        redo: &quot;Redo&quot;&#10;    },&#10;    he: {&#10;        app_title: &quot;רשימת קניות&quot;,&#10;        language_label: &quot;שפה:&quot;,&#10;        tab_lists: &quot;רשימות&quot;,&#10;        tab_summary: &quot;סיכום&quot;,&#10;        tab_settings: &quot;הגדרות&quot;,&#10;        lists_title: &quot;הרשימות שלך&quot;,&#10;        add_list: &quot;רשימה חדשה&quot;,&#10;        summary_title: &quot;סיכום קניות&quot;,&#10;        settings_title: &quot;הגדרות&quot;,&#10;        currency_label: &quot;סמל מטבע ברירת מחדל:&quot;,&#10;        modal_new_list: &quot;יצירת רשימה&quot;,&#10;        modal_edit_list: &quot;עריכת רשימה&quot;,&#10;        list_name_label: &quot;שם הרשימה:&quot;,&#10;        save: &quot;שמירה&quot;,&#10;        cancel: &quot;ביטול&quot;,&#10;        item_modal_new: &quot;הוספת פריט&quot;,&#10;        item_modal_edit: &quot;עריכת פריט&quot;,&#10;        item_name: &quot;שם הפריט:&quot;,&#10;        item_category: &quot;קטגוריה:&quot;,&#10;        item_quantity: &quot;כמות:&quot;,&#10;        item_price: &quot;מחיר משוער:&quot;,&#10;        item_notes: &quot;הערות:&quot;,&#10;        add_item: &quot;הוספת פריט&quot;,&#10;        close: &quot;סגור&quot;,&#10;        manage_items: &quot;ניהול פריטים&quot;,&#10;        rename_list: &quot;שנה שם&quot;,&#10;        edit_global_item: &quot;ערוך&quot;,&#10;        delete_list: &quot;מחק&quot;,&#10;        category_produce: &quot;ירקות ופירות&quot;,&#10;        category_dairy: &quot;מוצרי חלב&quot;,&#10;        category_meat: &quot;בשר&quot;,&#10;        category_bakery: &quot;מאפה&quot;,&#10;        category_beverages: &quot;משקאות&quot;,&#10;        category_other: &quot;אחר&quot;,&#10;        purchased: &quot;נקנו&quot;,&#10;        missing: &quot;חסרים&quot;,&#10;        total_cost: &quot;עלות כוללת&quot;,&#10;        create_from_missing: &quot;צור רשימה מפריטים חסרים&quot;&#10;        ,&#10;        receipt_label: &quot;העלה קבלה(ות):&quot;,&#10;        search_placeholder: &quot;חפש פריטים&quot;,&#10;        tab_items: &quot;פריטים גלובליים&quot;,&#10;        tab_archive: &quot;ארכיון&quot;,&#10;        items_title: &quot;פריטים גלובליים&quot;,&#10;        add_global_item: &quot;פריט גלובלי חדש&quot;,&#10;        global_name: &quot;שם פריט:&quot;,&#10;        global_category: &quot;קטגוריה:&quot;,&#10;        global_price: &quot;מחיר משוער:&quot;,&#10;        global_unit: &quot;יחידת מחיר:&quot;,&#10;        archive_title: &quot;ארכיון קניות&quot;&#10;        ,&#10;        modal_new_global_item: &quot;יצירת פריט גלובלי&quot;,&#10;        modal_edit_global_item: &quot;עריכת פריט גלובלי&quot;&#10;        ,&#10;        item_unit: &quot;יחידה:&quot;,&#10;        item_price_basis: &quot;כמות למחיר:&quot;,&#10;        import_title: &quot;ייבוא מגוגל קיפ&quot;,&#10;        import_label: &quot;הדבק את ההערה כאן:&quot;,&#10;        import_button: &quot;ייבוא&quot;,&#10;        export_csv: &quot;יצא לקובץ CSV&quot;,&#10;        archive_view: &quot;צפה&quot;,&#10;        archive_edit: &quot;ערוך&quot;&#10;        ,&#10;        complete_list: &quot;סיום&quot;&#10;        ,&#10;        categories_title: &quot;קטגוריות&quot;,&#10;        add_category: &quot;הוסף קטגוריה&quot;&#10;        ,&#10;        clear_data: &quot;נקה את כל הנתונים&quot;,&#10;        confirm_clear: &quot;האם אתה בטוח שברצונך לנקות את כל הנתונים? פעולה זו לא ניתנת לביטול.&quot;,&#10;        share_link: &quot;העתק קישור&quot;,&#10;        maximize: &quot;מסך מלא&quot;,&#10;        restore: &quot;יציאה ממסך מלא&quot;,&#10;        check_all: &quot;סמן הכל&quot;,&#10;        uncheck_all: &quot;בטל סימון הכל&quot;,&#10;        undo: &quot;בטל&quot;,&#10;        redo: &quot;שחזר&quot;&#10;    }&#10;};&#10;&#10;&#10;// Main data structure: lists, globalItems, categories, archivedLists, receipts&#10;let data = {&#10;    lists: [],&#10;    globalItems: [],&#10;    categories: [],&#10;    archivedLists: [],&#10;    receipts: [],&#10;    revision: 0&#10;};&#10;&#10;// Collaboration state&#10;let connectedUsers = [];&#10;let activeEditors = {};&#10;let isEditing = false;&#10;let currentEditingContext = null;&#10;&#10;let currentLanguage = 'en';&#10;let editingListId = null;&#10;let editingItemListId = null;&#10;let editingItemId = null;&#10;let itemSearchTerm = '';&#10;let editingGlobalItemId = null;&#10;let editingArchive = false;&#10;const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);&#10;let collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories') || '{}');&#10;let listFullscreen = localStorage.getItem('listFullscreen') === 'true';&#10;&#10;const clone = obj =&gt; JSON.parse(JSON.stringify(obj));&#10;let undoStack = [];&#10;let redoStack = [];&#10;let lastSavedData = null;&#10;&#10;// Update datalist options for global item suggestions&#10;function updateGlobalItemSuggestions() {&#10;    const datalist = document.getElementById('global-item-suggestions');&#10;    if (!datalist) {&#10;        updateCustomSuggestions();&#10;        return;&#10;    }&#10;    datalist.innerHTML = '';&#10;    // Use a Set to avoid duplicate names (case-insensitive)&#10;    const seen = new Set();&#10;    data.globalItems.forEach(item =&gt; {&#10;        const nameLower = item.name.toLowerCase();&#10;        if (!seen.has(nameLower)) {&#10;            seen.add(nameLower);&#10;            const opt = document.createElement('option');&#10;            opt.value = item.name;&#10;            datalist.appendChild(opt);&#10;        }&#10;    });&#10;    updateCustomSuggestions();&#10;}&#10;&#10;// Handle input for item name to auto-fill category and unit when matching a global item&#10;function handleItemNameInput() {&#10;    const input = document.getElementById('item-name-input');&#10;    if (!input) return;&#10;    const val = input.value.trim();&#10;    const globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === val.toLowerCase());&#10;    if (globalItem) {&#10;        input.dataset.selectedId = globalItem.id;&#10;        // Fill category and unit from global item&#10;        const catSelect = document.getElementById('item-category-select');&#10;        if (catSelect) catSelect.value = globalItem.categoryId;&#10;        const unitSelect = document.getElementById('item-unit-select');&#10;        if (unitSelect) unitSelect.value = globalItem.priceUnit || 'piece';&#10;        // Set price placeholder to estimated price for user reference&#10;        const priceInput = document.getElementById('item-price-input');&#10;        if (priceInput) {&#10;            priceInput.placeholder = globalItem.estimatedPrice != null ? globalItem.estimatedPrice.toString() : '';&#10;        }&#10;    } else {&#10;        delete input.dataset.selectedId;&#10;    }&#10;    updateCustomSuggestions();&#10;}&#10;&#10;// Custom suggestions dropdown for mobile browsers where datalist is unreliable&#10;function updateCustomSuggestions() {&#10;    const container = document.getElementById('item-suggestions');&#10;    const input = document.getElementById('item-name-input');&#10;    if (!container || !input) return;&#10;    if (!isMobile) {&#10;        container.classList.add('hidden');&#10;        return;&#10;    }&#10;    const term = input.value.trim().toLowerCase();&#10;    container.innerHTML = '';&#10;    if (!term) {&#10;        container.classList.add('hidden');&#10;        return;&#10;    }&#10;    const matches = data.globalItems.filter(g =&gt; g.name.toLowerCase().includes(term)).slice(0, 5);&#10;    matches.forEach(item =&gt; {&#10;        const div = document.createElement('div');&#10;        div.textContent = item.name;&#10;        div.addEventListener('click', () =&gt; {&#10;            input.value = item.name;&#10;            input.dataset.selectedId = item.id;&#10;            container.classList.add('hidden');&#10;            handleItemNameInput();&#10;        });&#10;        container.appendChild(div);&#10;    });&#10;    container.classList.toggle('hidden', matches.length === 0);&#10;}&#10;&#10;// Utility functions for localStorage&#10;async function loadData() {&#10;    // Use DataService to load persisted data.  DataService returns null if no&#10;    // data exists or if parsing fails.&#10;    const stored = await window.DataService.loadData();&#10;    if (stored) {&#10;        data = stored;&#10;    }&#10;    // Ensure all properties exist&#10;    data.lists = data.lists || [];&#10;    data.globalItems = data.globalItems || [];&#10;    data.categories = data.categories || [];&#10;    data.archivedLists = data.archivedLists || [];&#10;    data.receipts = data.receipts || [];&#10;    data.revision = data.revision || 0;&#10;    // If categories empty, populate default categories with translations&#10;    if (data.categories.length === 0) {&#10;        data.categories = [&#10;            { id: 'produce', names: { en: translations.en.category_produce, he: translations.he.category_produce } },&#10;            { id: 'dairy', names: { en: translations.en.category_dairy, he: translations.he.category_dairy } },&#10;            { id: 'meat', names: { en: translations.en.category_meat, he: translations.he.category_meat } },&#10;            { id: 'bakery', names: { en: translations.en.category_bakery, he: translations.he.category_bakery } },&#10;            { id: 'beverages', names: { en: translations.en.category_beverages, he: translations.he.category_beverages } },&#10;            { id: 'other', names: { en: translations.en.category_other, he: translations.he.category_other } }&#10;        ];&#10;    }&#10;    // Ensure list items have priceBasisQuantity&#10;    data.lists.forEach(list =&gt; {&#10;        list.items = list.items || [];&#10;        list.items.forEach(item =&gt; {&#10;            if (item.priceBasisQuantity == null) item.priceBasisQuantity = 1;&#10;        });&#10;    });&#10;    data.archivedLists.forEach(list =&gt; {&#10;        list.items = list.items || [];&#10;        list.items.forEach(item =&gt; {&#10;            if (item.priceBasisQuantity == null) item.priceBasisQuantity = 1;&#10;        });&#10;    });&#10;    lastSavedData = clone(data);&#10;}&#10;&#10;function saveData(pushUndo = true, operationType = null, operationPath = null, operationData = null) {&#10;    if (pushUndo &amp;&amp; lastSavedData) {&#10;        undoStack.push(clone(lastSavedData));&#10;        if (undoStack.length &gt; 100) undoStack.shift();&#10;        redoStack = [];&#10;    }&#10;    lastSavedData = clone(data);&#10;&#10;    // Track operations for collaborative editing&#10;    const operations = [];&#10;    if (operationType &amp;&amp; operationPath) {&#10;        operations.push(window.DataService.createOperation(operationType, operationPath, operationData));&#10;    }&#10;&#10;    window.DataService.saveData(data, operations);&#10;&#10;    // Send real-time operations for immediate updates&#10;    if (operations.length &gt; 0) {&#10;        window.DataService.sendOperations(operations);&#10;    }&#10;}&#10;&#10;// Apply translations to static UI elements&#10;function applyLanguage() {&#10;    const t = translations[currentLanguage];&#10;    // Set direction for RTL languages&#10;    document.documentElement.setAttribute('dir', currentLanguage === 'he' ? 'rtl' : 'ltr');&#10;    document.getElementById('app-title').innerText = t.app_title;&#10;    document.getElementById('language-label').innerText = t.language_label;&#10;    document.getElementById('tab-lists').innerText = t.tab_lists;&#10;    document.getElementById('tab-summary').innerText = t.tab_summary;&#10;    document.getElementById('tab-items').innerText = t.tab_items;&#10;    document.getElementById('tab-archive').innerText = t.tab_archive;&#10;    document.getElementById('tab-settings').innerText = t.tab_settings;&#10;    // Clear data button&#10;    const clearBtn = document.getElementById('clear-data-button');&#10;    if (clearBtn) {&#10;        clearBtn.innerText = t.clear_data;&#10;    }&#10;    document.getElementById('lists-title').innerText = t.lists_title;&#10;    const addListBtn = document.getElementById('add-list-button');&#10;    addListBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;    addListBtn.title = t.add_list;&#10;    addListBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    document.getElementById('summary-title').innerText = t.summary_title;&#10;    document.getElementById('items-title').innerText = t.items_title;&#10;    document.getElementById('archive-title').innerText = t.archive_title;&#10;    document.getElementById('settings-title').innerText = t.settings_title;&#10;    document.getElementById('currency-label').innerText = t.currency_label;&#10;    document.getElementById('receipt-label').innerText = t.receipt_label;&#10;    // Search placeholder for item search input (if exists)&#10;    const searchInput = document.getElementById('item-search');&#10;    if (searchInput) {&#10;        searchInput.placeholder = t.search_placeholder;&#10;    }&#10;    // Global item modal labels&#10;    const globalModal = document.getElementById('global-item-modal-overlay');&#10;    if (globalModal) {&#10;        document.getElementById('global-item-modal-title').innerText = editingGlobalItemId ? t.modal_edit_global_item : t.modal_new_global_item;&#10;        document.getElementById('global-name-label').innerText = t.global_name;&#10;        document.getElementById('global-category-label').innerText = t.global_category;&#10;        document.getElementById('global-price-label').innerText = t.global_price;&#10;        document.getElementById('global-unit-label').innerText = t.global_unit;&#10;        document.getElementById('save-global-item').innerText = t.save;&#10;        document.getElementById('cancel-global-item-modal').innerText = t.cancel;&#10;        const addGlobalBtn = document.getElementById('add-global-item-button');&#10;        addGlobalBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;        addGlobalBtn.title = t.add_global_item;&#10;        addGlobalBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    }&#10;    // Categories section&#10;    const categoriesTitleEl = document.getElementById('categories-title');&#10;    if (categoriesTitleEl) categoriesTitleEl.innerText = t.categories_title;&#10;    const addCategoryBtn = document.getElementById('add-category-button');&#10;    if (addCategoryBtn) {&#10;        addCategoryBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;        addCategoryBtn.title = t.add_category;&#10;        addCategoryBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    }&#10;    // Render categories names to update language&#10;    renderCategories();&#10;    // Modal texts&#10;    document.getElementById('list-name-label').innerText = t.list_name_label;&#10;    document.getElementById('save-list').innerText = t.save;&#10;    document.getElementById('cancel-modal').innerText = t.cancel;&#10;    document.getElementById('item-name-label').innerText = t.item_name;&#10;    document.getElementById('item-category-label').innerText = t.item_category;&#10;    document.getElementById('item-quantity-label').innerText = t.item_quantity;&#10;    document.getElementById('item-price-label').innerText = t.item_price;&#10;    document.getElementById('item-notes-label').innerText = t.item_notes;&#10;    // Unit label&#10;    const unitLabel = document.getElementById('item-unit-label');&#10;    if (unitLabel) unitLabel.innerText = t.item_unit;&#10;    // Price basis label&#10;    const priceBasisLabel = document.getElementById('item-price-basis-label');&#10;    if (priceBasisLabel) priceBasisLabel.innerText = t.item_price_basis;&#10;    document.getElementById('save-item').innerText = t.save;&#10;    document.getElementById('cancel-item-modal').innerText = t.cancel;&#10;    const addItemBtn = document.getElementById('add-item-button');&#10;    addItemBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;    addItemBtn.title = t.add_item;&#10;    addItemBtn.className = 'btn btn-primary btn-sm';&#10;    const completeBtn = document.getElementById('complete-list-button');&#10;    if (completeBtn) {&#10;        completeBtn.innerHTML = '&lt;i class=&quot;bi bi-check2-circle&quot;&gt;&lt;/i&gt;';&#10;        completeBtn.title = t.complete_list;&#10;        completeBtn.className = 'btn btn-success btn-sm';&#10;    }&#10;    const undoBtn = document.getElementById('undo-button');&#10;    if (undoBtn) {&#10;        undoBtn.innerHTML = '&lt;i class=&quot;bi bi-arrow-counterclockwise&quot;&gt;&lt;/i&gt;';&#10;        undoBtn.title = t.undo;&#10;        undoBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const redoBtn = document.getElementById('redo-button');&#10;    if (redoBtn) {&#10;        redoBtn.innerHTML = '&lt;i class=&quot;bi bi-arrow-clockwise&quot;&gt;&lt;/i&gt;';&#10;        redoBtn.title = t.redo;&#10;        redoBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const closeBtn = document.getElementById('close-list-details');&#10;    closeBtn.innerHTML = '&lt;i class=&quot;bi bi-x-lg&quot;&gt;&lt;/i&gt;';&#10;    closeBtn.title = t.close;&#10;    closeBtn.className = 'btn btn-secondary btn-sm';&#10;    const fsBtn = document.getElementById('toggle-fullscreen');&#10;    if (fsBtn) {&#10;        fsBtn.innerHTML = listFullscreen ? '&lt;i class=&quot;bi bi-fullscreen-exit&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-fullscreen&quot;&gt;&lt;/i&gt;';&#10;        fsBtn.title = listFullscreen ? t.restore : t.maximize;&#10;        fsBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const checkedHeading = document.getElementById('checked-heading');&#10;    if (checkedHeading) checkedHeading.innerText = t.purchased;&#10;    // Populate categories select for list items using data.categories&#10;    const select = document.getElementById('item-category-select');&#10;    if (select) {&#10;        select.innerHTML = '';&#10;        data.categories.forEach(cat =&gt; {&#10;            const option = document.createElement('option');&#10;            option.value = cat.id;&#10;            // Use names translation if available&#10;            const name = cat.names ? (cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id) : (t[cat.nameKey] || cat.id);&#10;            option.textContent = name;&#10;            select.appendChild(option);&#10;        });&#10;    }&#10;    // Render lists and summary again to update text and direction&#10;    renderLists();&#10;    renderSummary();&#10;    // Render global items and archive for language changes&#10;    renderGlobalItems();&#10;&#10;    // Update global item suggestions for item modal&#10;    updateGlobalItemSuggestions();&#10;&#10;    // Update import/export section texts&#10;    const importTitle = document.getElementById('import-title');&#10;    const importLabel = document.getElementById('import-label');&#10;    const importButton = document.getElementById('import-button');&#10;    const exportCsvButton = document.getElementById('export-csv-button');&#10;    if (importTitle) importTitle.innerText = t.import_title;&#10;    if (importLabel) importLabel.innerText = t.import_label;&#10;    if (importButton) importButton.innerText = t.import_button;&#10;    if (exportCsvButton) exportCsvButton.innerText = t.export_csv;&#10;}&#10;&#10;// Render the list of shopping lists&#10;function renderLists() {&#10;    const container = document.getElementById('list-container');&#10;    container.innerHTML = '';&#10;    data.lists.forEach(list =&gt; {&#10;        const li = document.createElement('li');&#10;        li.className = 'list-group-item d-flex align-items-start justify-content-between gap-2';&#10;        li.setAttribute('data-list-id', list.id);&#10;        const t = translations[currentLanguage];&#10;        // List name and stats&#10;        const info = document.createElement('div');&#10;        info.className = 'flex-grow-1';&#10;        const nameSpan = document.createElement('strong');&#10;        nameSpan.textContent = list.name;&#10;        info.appendChild(nameSpan);&#10;        // Stats: purchased/total&#10;        const total = list.items.length;&#10;        const purchased = list.items.filter(i =&gt; i.isChecked).length;&#10;        const stats = document.createElement('div');&#10;        stats.className = 'small text-muted';&#10;        stats.textContent = `${t.purchased}: ${purchased}/${total}`;&#10;        info.appendChild(stats);&#10;        li.appendChild(info);&#10;        const btnGroup = document.createElement('div');&#10;        btnGroup.className = 'btn-group btn-group-sm';&#10;        // Manage Items button&#10;        const manageBtn = document.createElement('button');&#10;        manageBtn.className = 'btn btn-outline-primary';&#10;        manageBtn.innerHTML = '&lt;i class=&quot;bi bi-list-task&quot;&gt;&lt;/i&gt;';&#10;        manageBtn.title = t.manage_items;&#10;        manageBtn.addEventListener('click', () =&gt; openListDetails(list.id));&#10;        btnGroup.appendChild(manageBtn);&#10;        // Rename button&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = t.rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; openListModal(list.id));&#10;        btnGroup.appendChild(renameBtn);&#10;        // Share link button&#10;        const linkBtn = document.createElement('button');&#10;        linkBtn.className = 'btn btn-outline-secondary';&#10;        linkBtn.innerHTML = '&lt;i class=&quot;bi bi-link-45deg&quot;&gt;&lt;/i&gt;';&#10;        linkBtn.title = t.share_link;&#10;        linkBtn.addEventListener('click', () =&gt; {&#10;            const url = new URL(window.location);&#10;            url.searchParams.set('list', list.id);&#10;            navigator.clipboard.writeText(url.toString());&#10;            alert(t.share_link);&#10;        });&#10;        btnGroup.appendChild(linkBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete list?')) {&#10;                data.lists = data.lists.filter(l =&gt; l.id !== list.id);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        btnGroup.appendChild(deleteBtn);&#10;        li.appendChild(btnGroup);&#10;&#10;        // Check if list is being edited&#10;        if (window.DataService.isBeingEdited(list.id)) {&#10;            const editor = window.DataService.getActiveEditors(list.id);&#10;            showEditingBadge(editor.userId, list.id);&#10;        }&#10;&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;// Render purchase summary across all lists&#10;function renderSummary() {&#10;    const container = document.getElementById('summary-content');&#10;    const t = translations[currentLanguage];&#10;    container.innerHTML = '';&#10;    let totalCostAll = 0;&#10;    data.lists.forEach(list =&gt; {&#10;        const section = document.createElement('div');&#10;        section.style.marginBottom = '1rem';&#10;        const heading = document.createElement('h3');&#10;        heading.textContent = list.name;&#10;        section.appendChild(heading);&#10;        const itemsPurchased = list.items.filter(i =&gt; i.isChecked);&#10;        const itemsMissing = list.items.filter(i =&gt; !i.isChecked);&#10;        // Calculate total cost using actual or estimated price with basis and track estimated cost separately&#10;        let totalCost = 0;&#10;        let totalEstimated = 0;&#10;        itemsPurchased.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            // Actual cost&#10;            let actualCost = 0;&#10;            if (item.actualPrice != null) {&#10;                actualCost = item.actualPrice * (item.quantity / basis);&#10;            } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                actualCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalCost += actualCost;&#10;            // Estimated cost from global item if units match&#10;            let estCost = 0;&#10;            if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                estCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalEstimated += estCost;&#10;        });&#10;        totalCostAll += totalCost;&#10;        const purchasedP = document.createElement('p');&#10;        purchasedP.textContent = `${t.purchased}: ${itemsPurchased.length}`;&#10;        section.appendChild(purchasedP);&#10;        const missingP = document.createElement('p');&#10;        missingP.textContent = `${t.missing}: ${itemsMissing.length}`;&#10;        section.appendChild(missingP);&#10;        const currency = document.getElementById('default-currency').value || '';&#10;        // Show total cost and difference (actual - estimated) if available&#10;        const costP = document.createElement('p');&#10;        costP.textContent = `${t.total_cost}: ${currency}${totalCost.toFixed(2)}`;&#10;        section.appendChild(costP);&#10;        if (totalEstimated &gt; 0) {&#10;            const diff = totalCost - totalEstimated;&#10;            const diffP = document.createElement('p');&#10;            diffP.style.fontSize = '0.8rem';&#10;            diffP.style.color = diff &gt;= 0 ? 'red' : 'green';&#10;            const sign = diff &gt;= 0 ? '+' : '-';&#10;            diffP.textContent = `Difference: ${sign}${currency}${Math.abs(diff).toFixed(2)}`;&#10;            section.appendChild(diffP);&#10;        }&#10;        // Button to create new list with missing items&#10;        if (itemsMissing.length &gt; 0) {&#10;            const createBtn = document.createElement('button');&#10;            createBtn.className = 'btn btn-outline-primary btn-sm';&#10;            createBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;            createBtn.title = t.create_from_missing;&#10;            createBtn.addEventListener('click', () =&gt; {&#10;                if (!confirm(t.create_from_missing + '?')) return;&#10;                const newList = {&#10;                    id: 'list-' + Date.now(),&#10;                    name: list.name + ' - ' + t.missing,&#10;                    items: itemsMissing.map(item =&gt; ({ ...item, id: 'item-' + Date.now() + Math.random() }))&#10;                };&#10;                data.lists.push(newList);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;                alert('New list created');&#10;            });&#10;            section.appendChild(createBtn);&#10;        }&#10;        container.appendChild(section);&#10;    });&#10;    // Overall total cost&#10;    const overall = document.createElement('p');&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    overall.style.fontWeight = 'bold';&#10;    overall.textContent = `${t.total_cost}: ${currency}${totalCostAll.toFixed(2)}`;&#10;    container.appendChild(overall);&#10;}&#10;&#10;// Render list of global items&#10;function renderGlobalItems() {&#10;    const container = document.getElementById('global-items-container');&#10;    container.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    data.globalItems.forEach(item =&gt; {&#10;        const li = document.createElement('li');&#10;        li.style.display = 'flex';&#10;        li.style.justifyContent = 'space-between';&#10;        li.style.alignItems = 'center';&#10;        li.style.padding = '0.5rem';&#10;        li.style.marginBottom = '0.5rem';&#10;        li.style.backgroundColor = '#f5f5f5';&#10;        li.style.borderRadius = '4px';&#10;        // Info&#10;        const info = document.createElement('div');&#10;        info.style.flex = '1';&#10;        const name = document.createElement('strong');&#10;        name.textContent = item.name;&#10;        info.appendChild(name);&#10;        const cat = data.categories.find(c =&gt; c.id === item.categoryId);&#10;        const catName = cat ? (cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id) : item.categoryId;&#10;        const details = document.createElement('div');&#10;        details.style.fontSize = '0.8rem';&#10;        details.style.marginTop = '0.25rem';&#10;        details.textContent = `${catName} – ${currency}${item.estimatedPrice.toFixed(2)} / ${item.priceUnit}`;&#10;        info.appendChild(details);&#10;        li.appendChild(info);&#10;        // Edit button&#10;        const editBtn = document.createElement('button');&#10;        editBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        editBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        editBtn.title = t.edit_global_item;&#10;        editBtn.addEventListener('click', () =&gt; openGlobalItemModal(item.id));&#10;        li.appendChild(editBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger btn-sm';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete global item?')) {&#10;                data.globalItems = data.globalItems.filter(g =&gt; g.id !== item.id);&#10;                // Remove references in list items&#10;                data.lists.forEach(list =&gt; {&#10;                    list.items = list.items.filter(li =&gt; li.globalItemId !== item.id);&#10;                });&#10;                saveData();&#10;                renderGlobalItems();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        li.appendChild(deleteBtn);&#10;        container.appendChild(li);&#10;    });&#10;    // Update suggestions after rendering&#10;    updateGlobalItemSuggestions();&#10;}&#10;&#10;// Open global item modal (new or edit)&#10;function openGlobalItemModal(itemId = null) {&#10;    editingGlobalItemId = itemId;&#10;    const overlay = document.getElementById('global-item-modal-overlay');&#10;    const t = translations[currentLanguage];&#10;    const titleEl = document.getElementById('global-item-modal-title');&#10;    titleEl.textContent = itemId ? t.modal_edit_global_item : t.modal_new_global_item;&#10;    // Populate category select&#10;    const catSelect = document.getElementById('global-category-select');&#10;    catSelect.innerHTML = '';&#10;    data.categories.forEach(cat =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = cat.id;&#10;        opt.textContent = cat.names[currentLanguage] || cat.names.en || cat.names.he;&#10;        catSelect.appendChild(opt);&#10;    });&#10;    if (itemId) {&#10;        const item = data.globalItems.find(g =&gt; g.id === itemId);&#10;        document.getElementById('global-name-input').value = item.name;&#10;        document.getElementById('global-category-select').value = item.categoryId;&#10;        document.getElementById('global-price-input').value = item.estimatedPrice;&#10;        document.getElementById('global-unit-select').value = item.priceUnit;&#10;    } else {&#10;        document.getElementById('global-name-input').value = '';&#10;        document.getElementById('global-category-select').value = data.categories[0].id;&#10;        document.getElementById('global-price-input').value = 0;&#10;        document.getElementById('global-unit-select').value = 'piece';&#10;    }&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeGlobalItemModal() {&#10;    document.getElementById('global-item-modal-overlay').classList.add('hidden');&#10;}&#10;&#10;function saveGlobalItem() {&#10;    const name = document.getElementById('global-name-input').value.trim();&#10;    const categoryId = document.getElementById('global-category-select').value;&#10;    const price = parseFloat(document.getElementById('global-price-input').value) || 0;&#10;    const unit = document.getElementById('global-unit-select').value;&#10;    if (!name) return;&#10;    if (editingGlobalItemId) {&#10;        const item = data.globalItems.find(g =&gt; g.id === editingGlobalItemId);&#10;        if (item) {&#10;            item.name = name;&#10;            item.categoryId = categoryId;&#10;            item.estimatedPrice = price;&#10;            item.priceUnit = unit;&#10;        }&#10;    } else {&#10;        const newItem = {&#10;            id: 'global-' + Date.now(),&#10;            name,&#10;            categoryId,&#10;            estimatedPrice: price,&#10;            priceUnit: unit,&#10;            createdAt: new Date().toISOString(),&#10;            updatedAt: new Date().toISOString()&#10;        };&#10;        data.globalItems.push(newItem);&#10;    }&#10;    saveData();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;    closeGlobalItemModal();&#10;}&#10;&#10;// Open list creation/edit modal&#10;function openListModal(listId = null) {&#10;    editingListId = listId;&#10;    const overlay = document.getElementById('modal-overlay');&#10;    const title = document.getElementById('modal-title');&#10;    const t = translations[currentLanguage];&#10;    if (listId) {&#10;        title.textContent = t.modal_edit_list;&#10;        const list = data.lists.find(l =&gt; l.id === listId);&#10;        document.getElementById('list-name-input').value = list ? list.name : '';&#10;    } else {&#10;        title.textContent = t.modal_new_list;&#10;        document.getElementById('list-name-input').value = '';&#10;    }&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeListModal() {&#10;    document.getElementById('modal-overlay').classList.add('hidden');&#10;}&#10;&#10;// Save list (new or edited)&#10;function saveList() {&#10;    const name = document.getElementById('list-name-input').value.trim();&#10;    if (!name) return;&#10;    if (editingListId) {&#10;        // Edit existing&#10;        const list = data.lists.find(l =&gt; l.id === editingListId);&#10;        if (list) list.name = name;&#10;    } else {&#10;        // Create new&#10;        data.lists.push({ id: 'list-' + Date.now(), name: name, items: [] });&#10;    }&#10;    saveData();&#10;    renderLists();&#10;    closeListModal();&#10;    renderSummary();&#10;}&#10;&#10;// Open list details overlay to manage items&#10;function openListDetails(listId, isArchive = false) {&#10;    editingArchive = isArchive;&#10;    editingItemListId = listId;&#10;    editingItemId = null;&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId);&#10;    isEditing = true;&#10;    currentEditingContext = { listId, isArchive };&#10;&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const title = document.getElementById('list-details-title');&#10;&#10;    const list = (isArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;    const t = translations[currentLanguage];&#10;&#10;    if (list) {&#10;        title.textContent = list.name;&#10;        title.setAttribute('data-list-id', listId);&#10;        renderItems(list);&#10;    }&#10;&#10;    overlay.classList.remove('hidden');&#10;    const url = new URL(window.location);&#10;    url.searchParams.set('list', listId);&#10;    history.replaceState(null, '', url);&#10;    applyFullscreenState();&#10;&#10;    // Show editing indicators&#10;    showEditingIndicators(listId);&#10;}&#10;&#10;function closeListDetails() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId);&#10;        clearEditingBadges(currentEditingContext.listId);&#10;        currentEditingContext = null;&#10;    }&#10;&#10;    isEditing = false;&#10;&#10;    const url = new URL(window.location);&#10;    url.searchParams.delete('list');&#10;    history.replaceState(null, '', url);&#10;}&#10;&#10;// Open item modal to create or edit an item&#10;function openItemModal(listId, itemId = null) {&#10;    editingItemListId = listId;&#10;    editingItemId = itemId;&#10;&#10;    // Check if item is being edited by someone else&#10;    if (itemId &amp;&amp; window.DataService.isBeingEdited(listId, itemId)) {&#10;        const editor = window.DataService.getActiveEditors(listId, itemId);&#10;        const t = translations[currentLanguage];&#10;        if (!confirm(`${editor.userId} is currently editing this item. Continue anyway?`)) {&#10;            return;&#10;        }&#10;    }&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId, itemId);&#10;&#10;    const overlay = document.getElementById('item-modal-overlay');&#10;    const t = translations[currentLanguage];&#10;    const title = document.getElementById('item-modal-title');&#10;    if (itemId) {&#10;        title.textContent = t.item_modal_edit;&#10;        const list = (editingArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;        const item = list.items.find(i =&gt; i.id === itemId);&#10;        // Derive global item&#10;        const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;        const nameInput = document.getElementById('item-name-input');&#10;        nameInput.value = globalItem ? globalItem.name : '';&#10;        if (globalItem) {&#10;            nameInput.dataset.selectedId = globalItem.id;&#10;        } else {&#10;            delete nameInput.dataset.selectedId;&#10;        }&#10;        // Category comes from global item&#10;        document.getElementById('item-category-select').value = globalItem ? globalItem.categoryId : data.categories[0].id;&#10;        // Quantity and unit&#10;        document.getElementById('item-quantity-input').value = item.quantity;&#10;        document.getElementById('item-unit-select').value = item.quantityUnit || (globalItem ? globalItem.priceUnit : 'piece');&#10;        // Price (actual price)&#10;        document.getElementById('item-price-input').value = item.actualPrice != null ? item.actualPrice : '';&#10;        document.getElementById('item-price-basis-input').value = item.priceBasisQuantity || 1;&#10;        document.getElementById('item-notes-input').value = item.notes || '';&#10;    } else {&#10;        title.textContent = t.item_modal_new;&#10;        const nameInput = document.getElementById('item-name-input');&#10;        nameInput.value = '';&#10;        delete nameInput.dataset.selectedId;&#10;        // Default values&#10;        document.getElementById('item-category-select').value = data.categories[0].id;&#10;        document.getElementById('item-quantity-input').value = 1;&#10;        document.getElementById('item-unit-select').value = 'piece';&#10;        document.getElementById('item-price-input').value = 0;&#10;        document.getElementById('item-price-basis-input').value = 1;&#10;        document.getElementById('item-notes-input').value = '';&#10;    }&#10;    // Add data attributes for tracking&#10;    const modal = document.getElementById('item-modal');&#10;    modal.setAttribute('data-list-id', listId);&#10;    if (itemId) modal.setAttribute('data-item-id', itemId);&#10;&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeItemModal() {&#10;    const overlay = document.getElementById('item-modal-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (editingItemListId) {&#10;        window.DataService.updatePresence('editEnd', editingItemListId, editingItemId);&#10;        clearEditingBadges(editingItemListId, editingItemId);&#10;    }&#10;&#10;    const nameInput = document.getElementById('item-name-input');&#10;    if (nameInput) delete nameInput.dataset.selectedId;&#10;}&#10;&#10;// Save item (new or edited)&#10;function saveItem() {&#10;    const list = (editingArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === editingItemListId);&#10;    if (!list) return;&#10;&#10;    const nameInput = document.getElementById('item-name-input');&#10;    const name = nameInput.value.trim();&#10;    const categoryId = document.getElementById('item-category-select').value;&#10;    const quantity = parseFloat(document.getElementById('item-quantity-input').value) || 1;&#10;    const quantityUnit = document.getElementById('item-unit-select').value || 'piece';&#10;    // Parse actual price; if input is empty or whitespace treat as null so that estimated price is used&#10;    const priceStr = document.getElementById('item-price-input').value.trim();&#10;    const price = priceStr ? parseFloat(priceStr) : null;&#10;    const priceBasisQuantity = parseFloat(document.getElementById('item-price-basis-input').value) || 1;&#10;    const notes = document.getElementById('item-notes-input').value.trim();&#10;    if (!name) return;&#10;    // Determine global item reference&#10;    let globalItem = null;&#10;    if (nameInput.dataset.selectedId) {&#10;        globalItem = data.globalItems.find(g =&gt; g.id === nameInput.dataset.selectedId);&#10;    }&#10;    if (!globalItem) {&#10;        // Find existing global item by name and category&#10;        globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === name.toLowerCase() &amp;&amp; g.categoryId === categoryId);&#10;    }&#10;    if (!globalItem) {&#10;        // Create new global item; use estimated price from actual price input if provided, otherwise 0&#10;        const estimated = price != null ? price : 0;&#10;        globalItem = {&#10;            id: 'global-' + Date.now() + Math.random(),&#10;            name,&#10;            categoryId,&#10;            estimatedPrice: estimated,&#10;            priceUnit: quantityUnit,&#10;            createdAt: new Date().toISOString(),&#10;            updatedAt: new Date().toISOString()&#10;        };&#10;        data.globalItems.push(globalItem);&#10;    }&#10;    if (editingItemId) {&#10;        // Edit existing list item&#10;        const item = list.items.find(i =&gt; i.id === editingItemId);&#10;        if (item) {&#10;            // If the global item reference has changed and another item with the same global item exists,&#10;            // merge them instead of creating duplicates&#10;            const oldGlobalId = item.globalItemId;&#10;            item.globalItemId = globalItem.id;&#10;            // Check if there is another item in the same list with the same globalItemId (excluding this item)&#10;            const duplicate = list.items.find(i =&gt; i.id !== item.id &amp;&amp; i.globalItemId === globalItem.id);&#10;            if (duplicate) {&#10;                // Merge current item's data into the duplicate&#10;                // Sum quantities if units match; otherwise keep separate quantities but still merge&#10;                if (duplicate.quantityUnit === quantityUnit) {&#10;                    duplicate.quantity += quantity;&#10;                } else {&#10;                    // Different units; store them separately by creating a notes entry&#10;                    duplicate.notes = duplicate.notes ? `${duplicate.notes}; ${quantity} ${quantityUnit}` : `${quantity} ${quantityUnit}`;&#10;                }&#10;                // Prefer actual price from the edit if provided, otherwise keep existing&#10;                if (price != null) duplicate.actualPrice = price;&#10;                // Merge price basis quantity: take max of the two (to avoid losing precision)&#10;                duplicate.priceBasisQuantity = Math.max(duplicate.priceBasisQuantity || 1, priceBasisQuantity || 1);&#10;                // Merge notes&#10;                if (notes) {&#10;                    duplicate.notes = duplicate.notes ? `${duplicate.notes}; ${notes}` : notes;&#10;                }&#10;                // Remove the old item from list&#10;                const index = list.items.findIndex(i =&gt; i.id === item.id);&#10;                if (index &gt;= 0) list.items.splice(index, 1);&#10;            } else {&#10;                // No duplicate, just update the item values normally&#10;                item.quantity = quantity;&#10;                item.quantityUnit = quantityUnit;&#10;                item.actualPrice = price;&#10;                item.priceBasisQuantity = priceBasisQuantity;&#10;                item.notes = notes;&#10;            }&#10;        }&#10;    } else {&#10;        // When creating a new list item, check if one already exists with the same globalItemId&#10;        const existing = list.items.find(i =&gt; i.globalItemId === globalItem.id &amp;&amp; i.quantityUnit === quantityUnit);&#10;        if (existing) {&#10;            // Merge new quantity and details into existing item&#10;            existing.quantity += quantity;&#10;            if (price != null) existing.actualPrice = price;&#10;            existing.priceBasisQuantity = Math.max(existing.priceBasisQuantity || 1, priceBasisQuantity || 1);&#10;            if (notes) {&#10;                existing.notes = existing.notes ? `${existing.notes}; ${notes}` : notes;&#10;            }&#10;        } else {&#10;            // Create new list item with wrapper referencing global item&#10;            list.items.push({&#10;                id: 'item-' + Date.now() + Math.random(),&#10;                globalItemId: globalItem.id,&#10;                quantity,&#10;                quantityUnit,&#10;                actualPrice: price,&#10;                priceBasisQuantity,&#10;                notes,&#10;                isChecked: false&#10;            });&#10;        }&#10;    }&#10;    const operationType = editingItemId ? 'update' : 'create';&#10;    const operationPath = editingItemId ?&#10;        `lists/${editingItemListId}/items/${editingItemId}` :&#10;        `lists/${editingItemListId}/items`;&#10;&#10;    // Track the operation for collaborative editing&#10;    saveData(true, operationType, operationPath, editingItemId ? item : newItem);&#10;&#10;    renderItems(list);&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;&#10;    if (editingArchive) {&#10;        renderArchive();&#10;    }&#10;&#10;    closeItemModal();&#10;}&#10;&#10;function applyFullscreenState() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const modal = document.getElementById('list-details');&#10;    const btn = document.getElementById('toggle-fullscreen');&#10;    if (listFullscreen) {&#10;        overlay.classList.add('fullscreen');&#10;        modal.classList.add('fullscreen');&#10;        if (btn) btn.innerText = translations[currentLanguage].restore;&#10;    } else {&#10;        overlay.classList.remove('fullscreen');&#10;        modal.classList.remove('fullscreen');&#10;        if (btn) btn.innerText = translations[currentLanguage].maximize;&#10;    }&#10;}&#10;&#10;function toggleListFullscreen() {&#10;    listFullscreen = !listFullscreen;&#10;    localStorage.setItem('listFullscreen', listFullscreen);&#10;    applyFullscreenState();&#10;}&#10;&#10;function getItemCategory(item) {&#10;    const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;    return globalItem ? globalItem.categoryId : (item.categoryId || 'other');&#10;}&#10;&#10;function moveCategory(catId, dir, list) {&#10;    const idx = data.categories.findIndex(c =&gt; c.id === catId);&#10;    const newIdx = idx + dir;&#10;    if (newIdx &lt; 0 || newIdx &gt;= data.categories.length) return;&#10;    const [cat] = data.categories.splice(idx, 1);&#10;    data.categories.splice(newIdx, 0, cat);&#10;    saveData();&#10;    renderCategories();&#10;    renderItems(list);&#10;}&#10;&#10;function moveItem(list, itemId, dir) {&#10;    const idx = list.items.findIndex(i =&gt; i.id === itemId);&#10;    const newIdx = idx + dir;&#10;    if (newIdx &lt; 0 || newIdx &gt;= list.items.length) return;&#10;    const [it] = list.items.splice(idx, 1);&#10;    list.items.splice(newIdx, 0, it);&#10;    saveData();&#10;    renderItems(list);&#10;}&#10;&#10;function setCategoryChecked(list, catId, checked) {&#10;    list.items.forEach(it =&gt; {&#10;        if (getItemCategory(it) === catId) {&#10;            it.isChecked = checked;&#10;        }&#10;    });&#10;    saveData();&#10;    renderItems(list);&#10;    renderLists();&#10;    renderSummary();&#10;}&#10;&#10;// Render items of current list&#10;function renderItems(list) {&#10;    const container = document.getElementById('items-container');&#10;    const checkedContainer = document.getElementById('checked-items-container');&#10;    container.innerHTML = '';&#10;    checkedContainer.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    const term = itemSearchTerm.toLowerCase();&#10;    const groups = {};&#10;    list.items.filter(item =&gt; {&#10;        const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;        const itemName = globalItem ? globalItem.name : item.name;&#10;        return !term || (itemName &amp;&amp; itemName.toLowerCase().includes(term));&#10;    }).forEach(item =&gt; {&#10;        const cid = getItemCategory(item);&#10;        if (!groups[cid]) groups[cid] = [];&#10;        groups[cid].push(item);&#10;    });&#10;    data.categories.forEach(cat =&gt; {&#10;        const catId = cat.id;&#10;        const items = groups[catId] || [];&#10;        if (items.length === 0) return;&#10;        const catName = cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id;&#10;        const unchecked = items.filter(i =&gt; !i.isChecked);&#10;        const checked = items.filter(i =&gt; i.isChecked);&#10;        const renderSection = (target, arr) =&gt; {&#10;            const heading = document.createElement('div');&#10;            heading.className = 'category-heading d-flex align-items-center gap-2';&#10;            const collapseBtn = document.createElement('button');&#10;            collapseBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            collapseBtn.innerHTML = collapsedCategories[catId] ? '&lt;i class=&quot;bi bi-chevron-right&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;            collapseBtn.addEventListener('click', () =&gt; {&#10;                collapsedCategories[catId] = !collapsedCategories[catId];&#10;                localStorage.setItem('collapsedCategories', JSON.stringify(collapsedCategories));&#10;                renderItems(list);&#10;            });&#10;            heading.appendChild(collapseBtn);&#10;            const span = document.createElement('span');&#10;            span.textContent = catName;&#10;            heading.appendChild(span);&#10;            const checkBox = document.createElement('input');&#10;            checkBox.type = 'checkbox';&#10;            checkBox.className = 'form-check-input ms-2';&#10;            checkBox.checked = arr.length &gt; 0 &amp;&amp; arr.every(i =&gt; i.isChecked);&#10;            checkBox.addEventListener('change', () =&gt; {&#10;                setCategoryChecked(list, catId, checkBox.checked);&#10;            });&#10;            heading.appendChild(checkBox);&#10;            const upBtn = document.createElement('button');&#10;            upBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            upBtn.innerHTML = '&lt;i class=&quot;bi bi-chevron-up&quot;&gt;&lt;/i&gt;';&#10;            upBtn.addEventListener('click', () =&gt; moveCategory(catId, -1, list));&#10;            heading.appendChild(upBtn);&#10;            const downBtn = document.createElement('button');&#10;            downBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            downBtn.innerHTML = '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;            downBtn.addEventListener('click', () =&gt; moveCategory(catId, 1, list));&#10;            heading.appendChild(downBtn);&#10;            target.appendChild(heading);&#10;            if (!collapsedCategories[catId]) {&#10;                arr.forEach(item =&gt; {&#10;                    const li = document.createElement('li');&#10;                    li.className = 'list-group-item d-flex align-items-start gap-2';&#10;                    li.setAttribute('data-item-id', item.id);&#10;                    const checkbox = document.createElement('input');&#10;                    checkbox.type = 'checkbox';&#10;                    checkbox.className = 'form-check-input mt-1';&#10;                    checkbox.checked = item.isChecked;&#10;                    checkbox.addEventListener('change', () =&gt; {&#10;                        item.isChecked = checkbox.checked;&#10;                        saveData();&#10;                        renderItems(list);&#10;                        renderLists();&#10;                        renderSummary();&#10;                    });&#10;                    li.appendChild(checkbox);&#10;                    const info = document.createElement('span');&#10;                    info.className = 'item-text flex-grow-1';&#10;                    info.style.textDecoration = item.isChecked ? 'line-through' : 'none';&#10;                    const currency = document.getElementById('default-currency').value || '';&#10;                    const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;                    const itemName = globalItem ? globalItem.name : item.name;&#10;                    const unit = item.quantityUnit || '';&#10;                    const priceVal = item.actualPrice != null ? item.actualPrice : (globalItem ? globalItem.estimatedPrice : 0);&#10;                    const basis = item.priceBasisQuantity || 1;&#10;                    const priceUnit = item.actualPrice != null ? item.quantityUnit : (globalItem ? globalItem.priceUnit : item.quantityUnit);&#10;                    let totalCost = null;&#10;                    if (item.actualPrice != null) {&#10;                        totalCost = priceVal * (item.quantity / basis);&#10;                    } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                        totalCost = priceVal * (item.quantity / basis);&#10;                    }&#10;                    const quantityDisplay = `${item.quantity}${unit ? ' ' + unit : ''}`;&#10;                    let priceDisplay = `${currency}${priceVal.toFixed(2)}`;&#10;                    if (basis !== 1) priceDisplay += ` / ${basis}`;&#10;                    if (priceUnit) priceDisplay += ` ${priceUnit}`;&#10;                    let text = `${itemName} (${quantityDisplay})`;&#10;                    text += `, ${priceDisplay}`;&#10;                    if (totalCost != null) {&#10;                        text += ` × ${item.quantity} = ${currency}${totalCost.toFixed(2)}`;&#10;                    }&#10;                    info.textContent = text;&#10;                    li.appendChild(info);&#10;                    const btnGroup = document.createElement('div');&#10;                    btnGroup.className = 'btn-group btn-group-sm';&#10;                    const up = document.createElement('button');&#10;                    up.className = 'btn btn-outline-secondary';&#10;                    up.innerHTML = '&lt;i class=&quot;bi bi-chevron-up&quot;&gt;&lt;/i&gt;';&#10;                    up.addEventListener('click', () =&gt; moveItem(list, item.id, -1));&#10;                    btnGroup.appendChild(up);&#10;                    const down = document.createElement('button');&#10;                    down.className = 'btn btn-outline-secondary';&#10;                    down.innerHTML = '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;                    down.addEventListener('click', () =&gt; moveItem(list, item.id, 1));&#10;                    btnGroup.appendChild(down);&#10;                    const editBtn = document.createElement('button');&#10;                    editBtn.className = 'btn btn-outline-secondary';&#10;                    editBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;                    editBtn.title = t.rename_list;&#10;                    editBtn.addEventListener('click', () =&gt; openItemModal(list.id, item.id));&#10;                    btnGroup.appendChild(editBtn);&#10;                    const deleteBtn = document.createElement('button');&#10;                    deleteBtn.className = 'btn btn-outline-danger';&#10;                    deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;                    deleteBtn.title = t.delete_list;&#10;                    deleteBtn.addEventListener('click', () =&gt; {&#10;                        const index = list.items.findIndex(i =&gt; i.id === item.id);&#10;                        if (index &gt;= 0) {&#10;                            list.items.splice(index, 1);&#10;                            saveData();&#10;                            renderItems(list);&#10;                            renderLists();&#10;                            renderSummary();&#10;                        }&#10;                    });&#10;                    btnGroup.appendChild(deleteBtn);&#10;                    li.appendChild(btnGroup);&#10;                    target.appendChild(li);&#10;                });&#10;            }&#10;        };&#10;        if (unchecked.length &gt; 0) renderSection(container, unchecked);&#10;        if (checked.length &gt; 0) renderSection(checkedContainer, checked);&#10;    });&#10;    const hasChecked = checkedContainer.children.length &gt; 0;&#10;    checkedContainer.style.display = hasChecked ? '' : 'none';&#10;    const headingEl = document.getElementById('checked-heading');&#10;    if (headingEl) headingEl.style.display = hasChecked ? '' : 'none';&#10;}&#10;&#10;function showPage(page) {&#10;    document.querySelectorAll('.page').forEach(p =&gt; p.classList.remove('active'));&#10;    document.querySelectorAll('nav button').forEach(b =&gt; b.classList.remove('active'));&#10;    document.getElementById(`page-${page}`).classList.add('active');&#10;    document.getElementById(`tab-${page}`).classList.add('active');&#10;    if (page === 'summary') renderSummary();&#10;    if (page === 'items') renderGlobalItems();&#10;    if (page === 'archive') renderArchive();&#10;}&#10;&#10;// Run init on DOM ready&#10;document.addEventListener('DOMContentLoaded', init);&#10;&#10;// Collaboration state management&#10;function updateCollaborationState() {&#10;    // Update presence indicators&#10;    showPresenceIndicators();&#10;&#10;    // Clear existing editing badges&#10;    clearEditingBadges();&#10;&#10;    // Show editing indicators for active editors&#10;    Object.values(activeEditors).forEach(editor =&gt; {&#10;        const [listId, itemId] = editor.key.split('/');&#10;        showEditingIndicators(listId, itemId);&#10;    });&#10;}&#10;&#10;// Enhanced initialization with collaboration features&#10;async function init() {&#10;    await loadData();&#10;&#10;    // Set up conflict resolver&#10;    window.DataService.conflictResolver = async (mergedData, originalData) =&gt; {&#10;        const conflicts = mergedData._conflicts || [];&#10;        if (conflicts.length &gt; 0) {&#10;            return await showConflictResolutionModal(conflicts, mergedData, originalData);&#10;        }&#10;        return mergedData;&#10;    };&#10;&#10;    // Set up user identification&#10;    let userName = localStorage.getItem('shopping-list-username');&#10;    if (!userName) {&#10;        userName = prompt('Enter your name for collaboration:') || `User-${Date.now().toString(36)}`;&#10;        localStorage.setItem('shopping-list-username', userName);&#10;    }&#10;    window.DataService.setCurrentUser({ name: userName });&#10;&#10;    setupEvents();&#10;    applyLanguage();&#10;    renderLists();&#10;    renderSummary();&#10;    // Display existing receipts names if any&#10;    displayReceipts();&#10;    // Render global items and archive&#10;    renderGlobalItems();&#10;    renderCategories();&#10;&#10;    // If using a remote server for data persistence, connect to its&#10;    // WebSocket endpoint so that updates from other clients are pushed&#10;    // into this instance.  The DataService will set up a socket.io&#10;    // connection and call onRemoteDataUpdated() whenever data is updated.&#10;    if (window.DataService &amp;&amp; window.DataService.useServer) {&#10;        window.DataService.initSocket();&#10;    }&#10;    const params = new URLSearchParams(window.location.search);&#10;    const linked = params.get('list');&#10;    if (linked) {&#10;        showPage('lists');&#10;        openListDetails(linked);&#10;    }&#10;}&#10;&#10;// Display list of uploaded receipts (names only) in summary page&#10;function displayReceipts() {&#10;    const listDiv = document.getElementById('receipt-list');&#10;    if (!listDiv) return;&#10;    listDiv.innerHTML = '';&#10;    (data.receipts || []).forEach(rec =&gt; {&#10;        const p = document.createElement('p');&#10;        p.textContent = rec.name;&#10;        listDiv.appendChild(p);&#10;    });&#10;}&#10;&#10;// Render archived purchases&#10;function renderArchive() {&#10;    const container = document.getElementById('archive-content');&#10;    if (!container) return;&#10;    container.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    if (!data.archivedLists || data.archivedLists.length === 0) {&#10;        const p = document.createElement('p');&#10;        p.textContent = t.missing || 'No archives yet';&#10;        container.appendChild(p);&#10;        return;&#10;    }&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    data.archivedLists.forEach(list =&gt; {&#10;        const section = document.createElement('div');&#10;        section.style.marginBottom = '1rem';&#10;        const heading = document.createElement('h3');&#10;        heading.textContent = list.name;&#10;        section.appendChild(heading);&#10;        // completion date&#10;        if (list.completedAt) {&#10;            const dateP = document.createElement('p');&#10;            dateP.textContent = new Date(list.completedAt).toLocaleDateString();&#10;            section.appendChild(dateP);&#10;        }&#10;        // totals: compute cost using actual or estimated price with basis&#10;        let totalActual = 0;&#10;        let totalEst = 0;&#10;        list.items.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            let actualCost = 0;&#10;            if (item.actualPrice != null) {&#10;                actualCost = item.actualPrice * (item.quantity / basis);&#10;            } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                actualCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalActual += actualCost;&#10;            let estCost = 0;&#10;            if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                estCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalEst += estCost;&#10;        });&#10;        const pTotal = document.createElement('p');&#10;        pTotal.textContent = `${t.total_cost}: ${currency}${totalActual.toFixed(2)}`;&#10;        section.appendChild(pTotal);&#10;        if (totalEst &gt; 0) {&#10;            const diff = totalActual - totalEst;&#10;            const diffP = document.createElement('p');&#10;            diffP.style.fontSize = '0.8rem';&#10;            diffP.style.color = diff &gt;= 0 ? 'red' : 'green';&#10;            const sign = diff &gt;= 0 ? '+' : '-';&#10;            diffP.textContent = `Difference: ${sign}${currency}${Math.abs(diff).toFixed(2)}`;&#10;            section.appendChild(diffP);&#10;        }&#10;        // receipts (names)&#10;        if (list.receiptImages &amp;&amp; list.receiptImages.length &gt; 0) {&#10;            const receiptsDiv = document.createElement('div');&#10;            const recHeading = document.createElement('p');&#10;            recHeading.textContent = t.receipt_label;&#10;            receiptsDiv.appendChild(recHeading);&#10;            list.receiptImages.forEach(r =&gt; {&#10;                const pName = document.createElement('p');&#10;                pName.textContent = r.name || r;&#10;                receiptsDiv.appendChild(pName);&#10;            });&#10;            section.appendChild(receiptsDiv);&#10;        }&#10;        // View button to open archived list details for editing&#10;        const viewBtn = document.createElement('button');&#10;        viewBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        viewBtn.innerHTML = '&lt;i class=&quot;bi bi-eye&quot;&gt;&lt;/i&gt;';&#10;        viewBtn.title = t.archive_view;&#10;        viewBtn.addEventListener('click', () =&gt; {&#10;            openListDetails(list.id, true);&#10;        });&#10;        section.appendChild(viewBtn);&#10;        container.appendChild(section);&#10;    });&#10;}&#10;&#10;// Render categories in settings page&#10;function renderCategories() {&#10;    const container = document.getElementById('categories-container');&#10;    if (!container) return;&#10;    container.innerHTML = '';&#10;    data.categories.forEach(cat =&gt; {&#10;        const li = document.createElement('li');&#10;        li.style.display = 'flex';&#10;        li.style.justifyContent = 'space-between';&#10;        li.style.alignItems = 'center';&#10;        li.style.padding = '0.3rem 0';&#10;        const nameSpan = document.createElement('span');&#10;        nameSpan.textContent = cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id;&#10;        li.appendChild(nameSpan);&#10;        // Edit button for categories (rename names)&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = translations[currentLanguage].rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; {&#10;            // Prompt for new names in both languages&#10;            const newNameEn = prompt('New category name (English)', cat.names.en || '');&#10;            if (newNameEn == null) return;&#10;            const newNameHe = prompt('New category name (Hebrew)', cat.names.he || newNameEn);&#10;            if (newNameHe == null) return;&#10;            cat.names.en = newNameEn.trim() || cat.names.en;&#10;            cat.names.he = newNameHe.trim() || cat.names.he;&#10;            saveData();&#10;            renderCategories();&#10;            applyLanguage();&#10;        });&#10;        li.appendChild(renameBtn);&#10;        // Delete button for custom categories (not default ones)&#10;        if (!cat.id.startsWith('produce') &amp;&amp; !cat.id.startsWith('dairy') &amp;&amp; !cat.id.startsWith('meat') &amp;&amp; !cat.id.startsWith('bakery') &amp;&amp; !cat.id.startsWith('beverages') &amp;&amp; cat.id !== 'other') {&#10;            const delBtn = document.createElement('button');&#10;            delBtn.className = 'btn btn-outline-danger btn-sm';&#10;            delBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;            delBtn.title = translations[currentLanguage].delete_list;&#10;            delBtn.addEventListener('click', () =&gt; {&#10;                if (confirm('Delete category?')) {&#10;                    // Remove category from data.categories&#10;                    data.categories = data.categories.filter(c =&gt; c.id !== cat.id);&#10;                    // Determine fallback category id (use 'other')&#10;                    const fallbackId = 'other';&#10;                    // Reassign items and global items using this category to fallback&#10;                    // Update all global items using this category to fallback&#10;                    data.globalItems.forEach(item =&gt; {&#10;                        if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                    });&#10;                    // For backwards compatibility, update old list item categoryId fields&#10;                    data.lists.forEach(list =&gt; {&#10;                        list.items.forEach(item =&gt; {&#10;                            if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                        });&#10;                    });&#10;                    data.archivedLists.forEach(list =&gt; {&#10;                        list.items.forEach(item =&gt; {&#10;                            if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                        });&#10;                    });&#10;                    saveData();&#10;                    renderCategories();&#10;                    applyLanguage();&#10;                }&#10;            });&#10;            li.appendChild(delBtn);&#10;        }&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;function addCategory() {&#10;    const input = document.getElementById('new-category-input');&#10;    const name = input.value.trim();&#10;    if (!name) return;&#10;    // Create slug id&#10;    const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '') + '-' + Date.now();&#10;    const names = { en: name, he: name };&#10;    data.categories.push({ id, names });&#10;    input.value = '';&#10;    saveData();&#10;    renderCategories();&#10;    applyLanguage();&#10;}&#10;&#10;// Import lists from Google Keep note text&#10;function importFromKeep() {&#10;    const textarea = document.getElementById('import-textarea');&#10;    if (!textarea) return;&#10;    const text = textarea.value.trim();&#10;    if (!text) return;&#10;    // Ask for list name (default: Imported List)&#10;    let listName = prompt('List name', 'Imported List');&#10;    if (!listName) return;&#10;    const lines = text.split(/\r?\n/);&#10;    const items = [];&#10;    let currentCategoryName = null;&#10;    lines.forEach(line =&gt; {&#10;        // Remove comments after '//'&#10;        const commentIndex = line.indexOf('//');&#10;        let contentLine = commentIndex &gt;= 0 ? line.slice(0, commentIndex) : line;&#10;        // Trim whitespace and indentation&#10;        let trimmed = contentLine.trim();&#10;        if (!trimmed) return;&#10;        // Match checkbox pattern [ ] or [X]&#10;        const match = trimmed.match(/^\[( |X|x)\]\s*(.*)$/);&#10;        if (!match) return;&#10;        const checkedChar = match[1];&#10;        let content = match[2].trim();&#10;        const isChecked = checkedChar.toUpperCase() === 'X';&#10;        if (!content) return;&#10;        // Category line if content ends with ':'&#10;        if (content.endsWith(':')) {&#10;            const categoryName = content.slice(0, -1).trim();&#10;            if (categoryName) {&#10;                currentCategoryName = categoryName;&#10;            }&#10;            return;&#10;        }&#10;        // Item line&#10;        let namePart = content;&#10;        let notes = '';&#10;        // Extract note after '-' character&#10;        const dashIndex = namePart.indexOf('-');&#10;        if (dashIndex &gt;= 0) {&#10;            notes = namePart.slice(dashIndex + 1).trim();&#10;            namePart = namePart.slice(0, dashIndex).trim();&#10;        }&#10;        // Extract quantity and unit from patterns like &quot;Bananas*4&quot;, &quot;Bananas*4 kg&quot; or &quot;Bananas x4&quot;&#10;        let quantity = 1;&#10;        let quantityUnit = 'piece';&#10;        const qtyMatch = namePart.match(/^(.*?)(?:[\*×x]\s*(\d+(?:\.\d+)?)(?:\s*(kg|liter|package|piece))?)$/i);&#10;        if (qtyMatch) {&#10;            namePart = qtyMatch[1].trim();&#10;            quantity = parseFloat(qtyMatch[2]);&#10;            if (qtyMatch[3]) quantityUnit = qtyMatch[3].toLowerCase();&#10;        }&#10;        // Determine category: currentCategoryName or default 'Other'&#10;        let categoryName = currentCategoryName || translations[currentLanguage].category_other;&#10;        // Find or create category object&#10;        let categoryObj = data.categories.find(cat =&gt; (cat.names.en === categoryName || cat.names.he === categoryName || cat.id === categoryName.toLowerCase()));&#10;        if (!categoryObj) {&#10;            const id = categoryName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/gi, '') + '-' + Date.now();&#10;            categoryObj = { id, names: { en: categoryName, he: categoryName } };&#10;            data.categories.push(categoryObj);&#10;        }&#10;        const globalName = namePart.trim();&#10;        if (!globalName) return;&#10;        // Find or create global item&#10;        let globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === globalName.toLowerCase() &amp;&amp; g.categoryId === categoryObj.id);&#10;        if (!globalItem) {&#10;            globalItem = {&#10;                id: 'global-' + Date.now() + Math.random(),&#10;                name: globalName,&#10;                categoryId: categoryObj.id,&#10;                estimatedPrice: 0,&#10;                priceUnit: quantityUnit,&#10;                createdAt: new Date().toISOString(),&#10;                updatedAt: new Date().toISOString()&#10;            };&#10;            data.globalItems.push(globalItem);&#10;        }&#10;        items.push({&#10;            id: 'item-' + Date.now() + Math.random(),&#10;            globalItemId: globalItem.id,&#10;            quantity,&#10;            quantityUnit,&#10;            actualPrice: null,&#10;            priceBasisQuantity: 1,&#10;            notes,&#10;            isChecked&#10;        });&#10;    });&#10;    if (items.length === 0) {&#10;        alert('No items found to import');&#10;        return;&#10;    }&#10;    const newList = { id: 'list-' + Date.now(), name: listName, items };&#10;    data.lists.push(newList);&#10;    saveData();&#10;    textarea.value = '';&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;    alert('Imported ' + items.length + (items.length === 1 ? ' item' : ' items'));&#10;}&#10;&#10;// Export shopping data to CSV&#10;function exportToCSV() {&#10;    const rows = [];&#10;    // Header&#10;    rows.push(['List Name', 'Item Name', 'Quantity', 'Unit', 'Price', 'Basis Quantity', 'Category', 'Actual Price', 'Date Completed']);&#10;    const allLists = [...data.lists, ...data.archivedLists];&#10;    allLists.forEach(list =&gt; {&#10;        list.items.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            // Determine item name and category from global item if available&#10;            const itemName = globalItem ? globalItem.name : (item.name || '');&#10;            const categoryId = globalItem ? globalItem.categoryId : item.categoryId;&#10;            const category = data.categories.find(c =&gt; c.id === categoryId);&#10;            const categoryName = category ? (category.names.en || category.id) : '';&#10;            const priceVal = item.actualPrice != null ? item.actualPrice : (globalItem ? globalItem.estimatedPrice : 0);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            const actualPrice = item.actualPrice != null ? priceVal : '';&#10;            const dateCompleted = list.completedAt || '';&#10;            rows.push([&#10;                list.name,&#10;                itemName,&#10;                item.quantity,&#10;                item.quantityUnit,&#10;                priceVal,&#10;                basis,&#10;                categoryName,&#10;                actualPrice,&#10;                dateCompleted&#10;            ]);&#10;        });&#10;    });&#10;    const csvContent = rows.map(r =&gt; r.map(field =&gt; {&#10;        const s = String(field == null ? '' : field);&#10;        // Escape double quotes by doubling&#10;        return '&quot;' + s.replace(/&quot;/g, '&quot;&quot;') + '&quot;';&#10;    }).join(',')).join('\n');&#10;    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });&#10;    const url = URL.createObjectURL(blob);&#10;    const link = document.createElement('a');&#10;    link.setAttribute('href', url);&#10;    link.setAttribute('download', 'shopping-data.csv');&#10;    document.body.appendChild(link);&#10;    link.click();&#10;    document.body.removeChild(link);&#10;    URL.revokeObjectURL(url);&#10;}&#10;&#10;function refreshUI() {&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    if (overlay &amp;&amp; !overlay.classList.contains('hidden')) {&#10;        const listArr = editingArchive ? data.archivedLists : data.lists;&#10;        const current = listArr.find(l =&gt; l.id === editingItemListId);&#10;        if (current) renderItems(current);&#10;    }&#10;}&#10;&#10;function undo() {&#10;    if (undoStack.length === 0) return;&#10;    redoStack.push(clone(data));&#10;    data = undoStack.pop();&#10;    lastSavedData = clone(data);&#10;    refreshUI();&#10;    saveData(false);&#10;}&#10;&#10;function redo() {&#10;    if (redoStack.length === 0) return;&#10;    undoStack.push(clone(data));&#10;    data = redoStack.pop();&#10;    lastSavedData = clone(data);&#10;    refreshUI();&#10;    saveData(false);&#10;}&#10;&#10;// Clear all data from localStorage and reset app&#10;async function clearAllData() {&#10;    const t = translations[currentLanguage];&#10;    if (!confirm(t.confirm_clear)) return;&#10;    // Use DataService to clear persisted data&#10;    await window.DataService.clearData();&#10;    // Reset in-memory data to defaults&#10;    data = {&#10;        lists: [],&#10;        globalItems: [],&#10;        categories: [],&#10;        archivedLists: [],&#10;        receipts: []&#10;    };&#10;    // Reload default categories and save to storage&#10;    await loadData();&#10;    saveData();&#10;    // Re-render all views&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;    alert(t.clear_data + ' done');&#10;}&#10;&#10;// Complete a list and move it to archive&#10;function completeList(listId) {&#10;    const index = data.lists.findIndex(l =&gt; l.id === listId);&#10;    if (index === -1) return;&#10;    if (!confirm('Mark this list as completed?')) return;&#10;    const list = data.lists[index];&#10;    list.isCompleted = true;&#10;    list.completedAt = new Date().toISOString();&#10;    // You might want to attach receipts here (global receipts)&#10;    // For now just copy global receipts as list receipts and clear global&#10;    list.receiptImages = (data.receipts || []).slice();&#10;    data.receipts = [];&#10;    // Move to archive&#10;    data.archivedLists.push(list);&#10;    data.lists.splice(index, 1);&#10;    saveData();&#10;    renderLists();&#10;    renderSummary();&#10;    renderArchive();&#10;    closeListDetails();&#10;}&#10;&#10;// Presence and collaboration features&#10;function showPresenceIndicators() {&#10;    // Add connected users indicator to header&#10;    let presenceIndicator = document.getElementById('presence-indicator');&#10;    if (!presenceIndicator) {&#10;        presenceIndicator = document.createElement('div');&#10;        presenceIndicator.id = 'presence-indicator';&#10;        presenceIndicator.style.cssText = `&#10;            display: flex;&#10;            align-items: center;&#10;            gap: 0.5rem;&#10;            color: white;&#10;            font-size: 0.8rem;&#10;        `;&#10;&#10;        const header = document.querySelector('header');&#10;        const languageToggle = document.querySelector('.language-toggle');&#10;        header.insertBefore(presenceIndicator, languageToggle);&#10;    }&#10;&#10;    const onlineCount = connectedUsers.length;&#10;    const t = translations[currentLanguage];&#10;&#10;    presenceIndicator.innerHTML = `&#10;        &lt;i class=&quot;bi bi-people&quot;&gt;&lt;/i&gt;&#10;        &lt;span&gt;${onlineCount} ${onlineCount === 1 ? 'user' : 'users'} online&lt;/span&gt;&#10;        ${window.DataService?.isConnected ? '&lt;i class=&quot;bi bi-wifi&quot; style=&quot;color: #4caf50;&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-wifi-off&quot; style=&quot;color: #f44336;&quot;&gt;&lt;/i&gt;'}&#10;    `;&#10;}&#10;&#10;function showEditingIndicators(listId, itemId = null) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    const editor = activeEditors[key];&#10;&#10;    if (editor &amp;&amp; editor.clientId !== window.DataService.clientId) {&#10;        // Show indicator that someone else is editing&#10;        showEditingBadge(editor.userId, listId, itemId);&#10;    }&#10;}&#10;&#10;function showEditingBadge(userName, listId, itemId = null) {&#10;    const targetSelector = itemId ?&#10;        `[data-item-id=&quot;${itemId}&quot;]` :&#10;        `[data-list-id=&quot;${listId}&quot;]`;&#10;&#10;    const target = document.querySelector(targetSelector);&#10;    if (target &amp;&amp; !target.querySelector('.editing-badge')) {&#10;        const badge = document.createElement('span');&#10;        badge.className = 'editing-badge';&#10;        badge.style.cssText = `&#10;            background: #2196f3;&#10;            color: white;&#10;            font-size: 0.7rem;&#10;            padding: 2px 6px;&#10;            border-radius: 10px;&#10;            margin-left: 0.5rem;&#10;            display: inline-flex;&#10;            align-items: center;&#10;            gap: 0.25rem;&#10;        `;&#10;        badge.innerHTML = `&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;${userName}`;&#10;        target.appendChild(badge);&#10;    }&#10;}&#10;&#10;function clearEditingBadges(listId = null, itemId = null) {&#10;    if (listId &amp;&amp; itemId) {&#10;        const target = document.querySelector(`[data-item-id=&quot;${itemId}&quot;]`);&#10;        const badge = target?.querySelector('.editing-badge');&#10;        badge?.remove();&#10;    } else if (listId) {&#10;        const target = document.querySelector(`[data-list-id=&quot;${listId}&quot;]`);&#10;        const badge = target?.querySelector('.editing-badge');&#10;        badge?.remove();&#10;    } else {&#10;        document.querySelectorAll('.editing-badge').forEach(badge =&gt; badge.remove());&#10;    }&#10;}&#10;&#10;// Enhanced conflict resolution UI&#10;function showConflictResolutionModal(conflicts, mergedData, originalData) {&#10;    return new Promise((resolve) =&gt; {&#10;        const overlay = document.createElement('div');&#10;        overlay.style.cssText = `&#10;            position: fixed;&#10;            top: 0;&#10;            left: 0;&#10;            right: 0;&#10;            bottom: 0;&#10;            background: rgba(0,0,0,0.7);&#10;            display: flex;&#10;            justify-content: center;&#10;            align-items: center;&#10;            z-index: 10000;&#10;        `;&#10;&#10;        const modal = document.createElement('div');&#10;        modal.style.cssText = `&#10;            background: white;&#10;            padding: 2rem;&#10;            border-radius: 8px;&#10;            max-width: 600px;&#10;            max-height: 80vh;&#10;            overflow-y: auto;&#10;            box-shadow: 0 4px 20px rgba(0,0,0,0.3);&#10;        `;&#10;&#10;        const t = translations[currentLanguage];&#10;        modal.innerHTML = `&#10;            &lt;h3&gt;Resolve Conflicts&lt;/h3&gt;&#10;            &lt;p&gt;Your changes conflict with recent updates from other users. Please choose how to resolve:&lt;/p&gt;&#10;            &lt;div id=&quot;conflict-list&quot;&gt;&lt;/div&gt;&#10;            &lt;div style=&quot;margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;&quot;&gt;&#10;                &lt;button id=&quot;accept-merged&quot; class=&quot;btn btn-primary&quot;&gt;Accept Merged Version&lt;/button&gt;&#10;                &lt;button id=&quot;keep-mine&quot; class=&quot;btn btn-secondary&quot;&gt;Keep My Changes&lt;/button&gt;&#10;                &lt;button id=&quot;manual-resolve&quot; class=&quot;btn btn-outline-primary&quot;&gt;Manual Review&lt;/button&gt;&#10;            &lt;/div&gt;&#10;        `;&#10;&#10;        const conflictList = modal.querySelector('#conflict-list');&#10;        conflicts.forEach(conflict =&gt; {&#10;            const conflictDiv = document.createElement('div');&#10;            conflictDiv.style.cssText = `&#10;                border: 1px solid #ddd;&#10;                padding: 1rem;&#10;                margin: 1rem 0;&#10;                border-radius: 4px;&#10;            `;&#10;&#10;            if (conflict.type === 'list_conflict') {&#10;                conflictDiv.innerHTML = `&#10;                    &lt;h4&gt;List: ${conflict.serverVersion.name}&lt;/h4&gt;&#10;                    &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;&quot;&gt;&#10;                        &lt;div&gt;&#10;                            &lt;strong&gt;Server Version:&lt;/strong&gt;&#10;                            &lt;div style=&quot;background: #f0f8ff; padding: 0.5rem; border-radius: 4px;&quot;&gt;&#10;                                ${conflict.serverVersion.name} (${conflict.serverVersion.items?.length || 0} items)&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div&gt;&#10;                            &lt;strong&gt;Your Version:&lt;/strong&gt;&#10;                            &lt;div style=&quot;background: #fff8dc; padding: 0.5rem; border-radius: 4px;&quot;&gt;&#10;                                ${conflict.localVersion.name} (${conflict.localVersion.items?.length || 0} items)&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                `;&#10;            }&#10;        });&#10;&#10;        modal.querySelector('#accept-merged').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(mergedData);&#10;        });&#10;&#10;        modal.querySelector('#keep-mine').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(originalData);&#10;        });&#10;&#10;        modal.querySelector('#manual-resolve').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(null); // Let user manually resolve&#10;        });&#10;&#10;        overlay.appendChild(modal);&#10;        document.body.appendChild(overlay);&#10;    });&#10;}&#10;&#10;// Enhanced list management with presence tracking&#10;function openListDetails(listId, isArchive = false) {&#10;    editingArchive = isArchive;&#10;    editingItemListId = listId;&#10;    editingItemId = null;&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId);&#10;    isEditing = true;&#10;    currentEditingContext = { listId, isArchive };&#10;&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const title = document.getElementById('list-details-title');&#10;&#10;    const list = (isArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;    const t = translations[currentLanguage];&#10;&#10;    if (list) {&#10;        title.textContent = list.name;&#10;        title.setAttribute('data-list-id', listId);&#10;        renderItems(list);&#10;    }&#10;&#10;    overlay.classList.remove('hidden');&#10;    const url = new URL(window.location);&#10;    url.searchParams.set('list', listId);&#10;    history.replaceState(null, '', url);&#10;    applyFullscreenState();&#10;&#10;    // Show editing indicators&#10;    showEditingIndicators(listId);&#10;}&#10;&#10;function closeListDetails() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId);&#10;        clearEditingBadges(currentEditingContext.listId);&#10;        currentEditingContext = null;&#10;    }&#10;&#10;    isEditing = false;&#10;&#10;    const url = new URL(window.location);&#10;    url.searchParams.delete('list');&#10;    history.replaceState(null, '', url);&#10;}&#10;&#10;// Enhanced remote data update handler with presence&#10;window.onRemoteDataUpdated = function(remoteData) {&#10;    if (!remoteData || typeof remoteData !== 'object') return;&#10;&#10;    // Store current editing context to restore after update&#10;    const wasEditing = isEditing;&#10;    const editingContext = currentEditingContext;&#10;&#10;    data = remoteData;&#10;    data.lists = data.lists || [];&#10;    data.globalItems = data.globalItems || [];&#10;    data.categories = data.categories || [];&#10;    data.archivedLists = data.archivedLists || [];&#10;    data.receipts = data.receipts || [];&#10;    lastSavedData = clone(data);&#10;    undoStack = [];&#10;    redoStack = [];&#10;&#10;    // Update UI&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;&#10;    // Restore editing context if we were editing&#10;    if (wasEditing &amp;&amp; editingContext &amp;&amp; editingItemListId) {&#10;        const listArr = editingContext.isArchive ? data.archivedLists : data.lists;&#10;        const current = listArr.find(l =&gt; l.id === editingItemListId);&#10;        if (current) {&#10;            renderItems(current);&#10;        }&#10;    }&#10;&#10;    // Show conflict notification if needed&#10;    if (remoteData._conflicts &amp;&amp; remoteData._conflicts.length &gt; 0) {&#10;        window.DataService.showConflictNotification();&#10;    }&#10;};&#10;&#10;// New presence update handler&#10;window.onPresenceUpdated = function(users, editors) {&#10;    connectedUsers = users || [];&#10;    activeEditors = editors || {};&#10;&#10;    showPresenceIndicators();&#10;    clearEditingBadges(); // Clear all existing badges&#10;&#10;    // Show editing indicators for currently active editors&#10;    Object.entries(activeEditors).forEach(([key, editor]) =&gt; {&#10;        if (editor.clientId !== window.DataService.clientId) {&#10;            const [listId, itemId] = key.split('/');&#10;            showEditingIndicators(listId, itemId);&#10;        }&#10;    });&#10;};&#10;&#10;// Enhanced render functions with collaboration indicators&#10;function renderLists() {&#10;    const container = document.getElementById('list-container');&#10;    container.innerHTML = '';&#10;&#10;    data.lists.forEach(list =&gt; {&#10;        const li = document.createElement('li');&#10;        li.className = 'list-group-item d-flex align-items-start justify-content-between gap-2';&#10;        li.setAttribute('data-list-id', list.id);&#10;        const t = translations[currentLanguage];&#10;        // List name and stats&#10;        const info = document.createElement('div');&#10;        info.className = 'flex-grow-1';&#10;        const nameSpan = document.createElement('strong');&#10;        nameSpan.textContent = list.name;&#10;        info.appendChild(nameSpan);&#10;        // Stats: purchased/total&#10;        const total = list.items.length;&#10;        const purchased = list.items.filter(i =&gt; i.isChecked).length;&#10;        const stats = document.createElement('div');&#10;        stats.className = 'small text-muted';&#10;        stats.textContent = `${t.purchased}: ${purchased}/${total}`;&#10;        info.appendChild(stats);&#10;        li.appendChild(info);&#10;        const btnGroup = document.createElement('div');&#10;        btnGroup.className = 'btn-group btn-group-sm';&#10;        // Manage Items button&#10;        const manageBtn = document.createElement('button');&#10;        manageBtn.className = 'btn btn-outline-primary';&#10;        manageBtn.innerHTML = '&lt;i class=&quot;bi bi-list-task&quot;&gt;&lt;/i&gt;';&#10;        manageBtn.title = t.manage_items;&#10;        manageBtn.addEventListener('click', () =&gt; openListDetails(list.id));&#10;        btnGroup.appendChild(manageBtn);&#10;        // Rename button&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = t.rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; openListModal(list.id));&#10;        btnGroup.appendChild(renameBtn);&#10;        // Share link button&#10;        const linkBtn = document.createElement('button');&#10;        linkBtn.className = 'btn btn-outline-secondary';&#10;        linkBtn.innerHTML = '&lt;i class=&quot;bi bi-link-45deg&quot;&gt;&lt;/i&gt;';&#10;        linkBtn.title = t.share_link;&#10;        linkBtn.addEventListener('click', () =&gt; {&#10;            const url = new URL(window.location);&#10;            url.searchParams.set('list', list.id);&#10;            navigator.clipboard.writeText(url.toString());&#10;            alert(t.share_link);&#10;        });&#10;        btnGroup.appendChild(linkBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete list?')) {&#10;                data.lists = data.lists.filter(l =&gt; l.id !== list.id);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        btnGroup.appendChild(deleteBtn);&#10;        li.appendChild(btnGroup);&#10;&#10;        // Check if list is being edited&#10;        if (window.DataService.isBeingEdited(list.id)) {&#10;            const editor = window.DataService.getActiveEditors(list.id);&#10;            showEditingBadge(editor.userId, list.id);&#10;        }&#10;&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;// Add real-time operation handlers&#10;window.onRemoteOperationsApplied = function(operations) {&#10;    // Handle batch operations from other clients&#10;    console.log('Remote operations applied:', operations);&#10;&#10;    // Show subtle notification&#10;    const notification = document.createElement('div');&#10;    notification.style.cssText = `&#10;        position: fixed;&#10;        bottom: 20px;&#10;        right: 20px;&#10;        background: #4caf50;&#10;        color: white;&#10;        padding: 8px 16px;&#10;        border-radius: 4px;&#10;        z-index: 9999;&#10;        font-size: 0.8rem;&#10;        opacity: 0.9;&#10;    `;&#10;    notification.textContent = `${operations.length} updates from other users`;&#10;    document.body.appendChild(notification);&#10;&#10;    setTimeout(() =&gt; notification.remove(), 3000);&#10;};&#10;&#10;window.onRemoteOperationReceived = function(operation) {&#10;    // Handle single real-time operation&#10;    console.log('Real-time operation received:', operation);&#10;&#10;    // Apply operation locally for instant feedback&#10;    // This would require implementing operation transforms on the client side&#10;    // For now, we'll just refresh the affected UI components&#10;&#10;    if (operation.path.startsWith('lists/')) {&#10;        renderLists();&#10;        if (isEditing &amp;&amp; currentEditingContext) {&#10;            const list = data.lists.find(l =&gt; l.id === currentEditingContext.listId);&#10;            if (list) renderItems(list);&#10;        }&#10;    }&#10;};&#10;&#10;// Enhanced beforeunload handler for presence cleanup&#10;window.addEventListener('beforeunload', () =&gt; {&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId, editingItemId);&#10;    }&#10;    window.DataService.updatePresence('disconnect');&#10;});&#10;&#10;// Enhanced visibility change handler for better presence tracking&#10;document.addEventListener('visibilitychange', () =&gt; {&#10;    if (document.visibilityState === 'visible') {&#10;        window.DataService.updatePresence('active');&#10;        showPresenceIndicators();&#10;    } else {&#10;        window.DataService.updatePresence('idle');&#10;    }&#10;});&#10;" />
              <option name="updatedContent" value="// Simple Shopping List App in vanilla JS with enhanced collaboration features&#10;// Data is stored via DataService with real-time synchronization and conflict resolution.&#10;&#10;// Translation strings for English and Hebrew&#10;const translations = {&#10;    en: {&#10;        app_title: &quot;Shopping List&quot;,&#10;        language_label: &quot;Language:&quot;,&#10;        tab_lists: &quot;Lists&quot;,&#10;        tab_summary: &quot;Summary&quot;,&#10;        tab_settings: &quot;Settings&quot;,&#10;        lists_title: &quot;Your Lists&quot;,&#10;        add_list: &quot;New List&quot;,&#10;        summary_title: &quot;Purchase Summary&quot;,&#10;        settings_title: &quot;Settings&quot;,&#10;        currency_label: &quot;Default currency symbol:&quot;,&#10;        modal_new_list: &quot;Create List&quot;,&#10;        modal_edit_list: &quot;Edit List&quot;,&#10;        list_name_label: &quot;List name:&quot;,&#10;        save: &quot;Save&quot;,&#10;        cancel: &quot;Cancel&quot;,&#10;        item_modal_new: &quot;Add Item&quot;,&#10;        item_modal_edit: &quot;Edit Item&quot;,&#10;        item_name: &quot;Item name:&quot;,&#10;        item_category: &quot;Category:&quot;,&#10;        item_quantity: &quot;Quantity:&quot;,&#10;        item_price: &quot;Est. price:&quot;,&#10;        item_notes: &quot;Notes:&quot;,&#10;        add_item: &quot;Add Item&quot;,&#10;        close: &quot;Close&quot;,&#10;        manage_items: &quot;Manage Items&quot;,&#10;        rename_list: &quot;Rename&quot;,&#10;        edit_global_item: &quot;Edit&quot;,&#10;        delete_list: &quot;Delete&quot;,&#10;        category_produce: &quot;Produce&quot;,&#10;        category_dairy: &quot;Dairy&quot;,&#10;        category_meat: &quot;Meat&quot;,&#10;        category_bakery: &quot;Bakery&quot;,&#10;        category_beverages: &quot;Beverages&quot;,&#10;        category_other: &quot;Other&quot;,&#10;        purchased: &quot;Purchased&quot;,&#10;        missing: &quot;Missing&quot;,&#10;        total_cost: &quot;Total cost&quot;,&#10;        create_from_missing: &quot;Create list from missing items&quot;&#10;        ,&#10;        receipt_label: &quot;Upload receipt(s):&quot;,&#10;        search_placeholder: &quot;Search items&quot;,&#10;        tab_items: &quot;Global Items&quot;,&#10;        tab_archive: &quot;Archive&quot;,&#10;        items_title: &quot;Global Items&quot;,&#10;        add_global_item: &quot;New Global Item&quot;,&#10;        global_name: &quot;Item name:&quot;,&#10;        global_category: &quot;Category:&quot;,&#10;        global_price: &quot;Estimated price:&quot;,&#10;        global_unit: &quot;Price unit:&quot;,&#10;        archive_title: &quot;Purchase Archive&quot;&#10;        ,&#10;        modal_new_global_item: &quot;Create Global Item&quot;,&#10;        modal_edit_global_item: &quot;Edit Global Item&quot;&#10;        ,&#10;        item_unit: &quot;Unit:&quot;,&#10;        item_price_basis: &quot;Price basis quantity:&quot;,&#10;        import_title: &quot;Import from Google Keep&quot;,&#10;        import_label: &quot;Paste your Keep note here:&quot;,&#10;        import_button: &quot;Import&quot;,&#10;        export_csv: &quot;Export to CSV&quot;,&#10;        archive_view: &quot;View&quot;,&#10;        archive_edit: &quot;Edit&quot;&#10;        ,&#10;        complete_list: &quot;Complete&quot;&#10;        ,&#10;        categories_title: &quot;Categories&quot;,&#10;        add_category: &quot;Add Category&quot;&#10;        ,&#10;        clear_data: &quot;Clear All Data&quot;,&#10;        confirm_clear: &quot;Are you sure you want to clear all data? This cannot be undone.&quot;,&#10;        share_link: &quot;Copy Link&quot;,&#10;        maximize: &quot;Maximize&quot;,&#10;        restore: &quot;Restore&quot;,&#10;        check_all: &quot;Check All&quot;,&#10;        uncheck_all: &quot;Uncheck All&quot;,&#10;        undo: &quot;Undo&quot;,&#10;        redo: &quot;Redo&quot;&#10;    },&#10;    he: {&#10;        app_title: &quot;רשימת קניות&quot;,&#10;        language_label: &quot;שפה:&quot;,&#10;        tab_lists: &quot;רשימות&quot;,&#10;        tab_summary: &quot;סיכום&quot;,&#10;        tab_settings: &quot;הגדרות&quot;,&#10;        lists_title: &quot;הרשימות שלך&quot;,&#10;        add_list: &quot;רשימה חדשה&quot;,&#10;        summary_title: &quot;סיכום קניות&quot;,&#10;        settings_title: &quot;הגדרות&quot;,&#10;        currency_label: &quot;סמל מטבע ברירת מחדל:&quot;,&#10;        modal_new_list: &quot;יצירת רשימה&quot;,&#10;        modal_edit_list: &quot;עריכת רשימה&quot;,&#10;        list_name_label: &quot;שם הרשימה:&quot;,&#10;        save: &quot;שמירה&quot;,&#10;        cancel: &quot;ביטול&quot;,&#10;        item_modal_new: &quot;הוספת פריט&quot;,&#10;        item_modal_edit: &quot;עריכת פריט&quot;,&#10;        item_name: &quot;שם הפריט:&quot;,&#10;        item_category: &quot;קטגוריה:&quot;,&#10;        item_quantity: &quot;כמות:&quot;,&#10;        item_price: &quot;מחיר משוער:&quot;,&#10;        item_notes: &quot;הערות:&quot;,&#10;        add_item: &quot;הוספת פריט&quot;,&#10;        close: &quot;סגור&quot;,&#10;        manage_items: &quot;ניהול פריטים&quot;,&#10;        rename_list: &quot;שנה שם&quot;,&#10;        edit_global_item: &quot;ערוך&quot;,&#10;        delete_list: &quot;מחק&quot;,&#10;        category_produce: &quot;ירקות ופירות&quot;,&#10;        category_dairy: &quot;מוצרי חלב&quot;,&#10;        category_meat: &quot;בשר&quot;,&#10;        category_bakery: &quot;מאפה&quot;,&#10;        category_beverages: &quot;משקאות&quot;,&#10;        category_other: &quot;אחר&quot;,&#10;        purchased: &quot;נקנו&quot;,&#10;        missing: &quot;חסרים&quot;,&#10;        total_cost: &quot;עלות כוללת&quot;,&#10;        create_from_missing: &quot;צור רשימה מפריטים חסרים&quot;&#10;        ,&#10;        receipt_label: &quot;העלה קבלה(ות):&quot;,&#10;        search_placeholder: &quot;חפש פריטים&quot;,&#10;        tab_items: &quot;פריטים גלובליים&quot;,&#10;        tab_archive: &quot;ארכיון&quot;,&#10;        items_title: &quot;פריטים גלובליים&quot;,&#10;        add_global_item: &quot;פריט גלובלי חדש&quot;,&#10;        global_name: &quot;שם פריט:&quot;,&#10;        global_category: &quot;קטגוריה:&quot;,&#10;        global_price: &quot;מחיר משוער:&quot;,&#10;        global_unit: &quot;יחידת מחיר:&quot;,&#10;        archive_title: &quot;ארכיון קניות&quot;&#10;        ,&#10;        modal_new_global_item: &quot;יצירת פריט גלובלי&quot;,&#10;        modal_edit_global_item: &quot;עריכת פריט גלובלי&quot;&#10;        ,&#10;        item_unit: &quot;יחידה:&quot;,&#10;        item_price_basis: &quot;כמות למחיר:&quot;,&#10;        import_title: &quot;ייבוא מגוגל קיפ&quot;,&#10;        import_label: &quot;הדבק את ההערה כאן:&quot;,&#10;        import_button: &quot;ייבוא&quot;,&#10;        export_csv: &quot;יצא לקובץ CSV&quot;,&#10;        archive_view: &quot;צפה&quot;,&#10;        archive_edit: &quot;ערוך&quot;&#10;        ,&#10;        complete_list: &quot;סיום&quot;&#10;        ,&#10;        categories_title: &quot;קטגוריות&quot;,&#10;        add_category: &quot;הוסף קטגוריה&quot;&#10;        ,&#10;        clear_data: &quot;נקה את כל הנתונים&quot;,&#10;        confirm_clear: &quot;האם אתה בטוח שברצונך לנקות את כל הנתונים? פעולה זו לא ניתנת לביטול.&quot;,&#10;        share_link: &quot;העתק קישור&quot;,&#10;        maximize: &quot;מסך מלא&quot;,&#10;        restore: &quot;יציאה ממסך מלא&quot;,&#10;        check_all: &quot;סמן הכל&quot;,&#10;        uncheck_all: &quot;בטל סימון הכל&quot;,&#10;        undo: &quot;בטל&quot;,&#10;        redo: &quot;שחזר&quot;&#10;    }&#10;};&#10;&#10;&#10;// Main data structure: lists, globalItems, categories, archivedLists, receipts&#10;let data = {&#10;    lists: [],&#10;    globalItems: [],&#10;    categories: [],&#10;    archivedLists: [],&#10;    receipts: [],&#10;    revision: 0&#10;};&#10;&#10;// Collaboration state&#10;let connectedUsers = [];&#10;let activeEditors = {};&#10;let isEditing = false;&#10;let currentEditingContext = null;&#10;&#10;let currentLanguage = 'en';&#10;let editingListId = null;&#10;let editingItemListId = null;&#10;let editingItemId = null;&#10;let itemSearchTerm = '';&#10;let editingGlobalItemId = null;&#10;let editingArchive = false;&#10;const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);&#10;let collapsedCategories = JSON.parse(localStorage.getItem('collapsedCategories') || '{}');&#10;let listFullscreen = localStorage.getItem('listFullscreen') === 'true';&#10;&#10;const clone = obj =&gt; JSON.parse(JSON.stringify(obj));&#10;let undoStack = [];&#10;let redoStack = [];&#10;let lastSavedData = null;&#10;&#10;// Update datalist options for global item suggestions&#10;function updateGlobalItemSuggestions() {&#10;    const datalist = document.getElementById('global-item-suggestions');&#10;    if (!datalist) {&#10;        updateCustomSuggestions();&#10;        return;&#10;    }&#10;    datalist.innerHTML = '';&#10;    // Use a Set to avoid duplicate names (case-insensitive)&#10;    const seen = new Set();&#10;    data.globalItems.forEach(item =&gt; {&#10;        const nameLower = item.name.toLowerCase();&#10;        if (!seen.has(nameLower)) {&#10;            seen.add(nameLower);&#10;            const opt = document.createElement('option');&#10;            opt.value = item.name;&#10;            datalist.appendChild(opt);&#10;        }&#10;    });&#10;    updateCustomSuggestions();&#10;}&#10;&#10;// Handle input for item name to auto-fill category and unit when matching a global item&#10;function handleItemNameInput() {&#10;    const input = document.getElementById('item-name-input');&#10;    if (!input) return;&#10;    const val = input.value.trim();&#10;    const globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === val.toLowerCase());&#10;    if (globalItem) {&#10;        input.dataset.selectedId = globalItem.id;&#10;        // Fill category and unit from global item&#10;        const catSelect = document.getElementById('item-category-select');&#10;        if (catSelect) catSelect.value = globalItem.categoryId;&#10;        const unitSelect = document.getElementById('item-unit-select');&#10;        if (unitSelect) unitSelect.value = globalItem.priceUnit || 'piece';&#10;        // Set price placeholder to estimated price for user reference&#10;        const priceInput = document.getElementById('item-price-input');&#10;        if (priceInput) {&#10;            priceInput.placeholder = globalItem.estimatedPrice != null ? globalItem.estimatedPrice.toString() : '';&#10;        }&#10;    } else {&#10;        delete input.dataset.selectedId;&#10;    }&#10;    updateCustomSuggestions();&#10;}&#10;&#10;// Custom suggestions dropdown for mobile browsers where datalist is unreliable&#10;function updateCustomSuggestions() {&#10;    const container = document.getElementById('item-suggestions');&#10;    const input = document.getElementById('item-name-input');&#10;    if (!container || !input) return;&#10;    if (!isMobile) {&#10;        container.classList.add('hidden');&#10;        return;&#10;    }&#10;    const term = input.value.trim().toLowerCase();&#10;    container.innerHTML = '';&#10;    if (!term) {&#10;        container.classList.add('hidden');&#10;        return;&#10;    }&#10;    const matches = data.globalItems.filter(g =&gt; g.name.toLowerCase().includes(term)).slice(0, 5);&#10;    matches.forEach(item =&gt; {&#10;        const div = document.createElement('div');&#10;        div.textContent = item.name;&#10;        div.addEventListener('click', () =&gt; {&#10;            input.value = item.name;&#10;            input.dataset.selectedId = item.id;&#10;            container.classList.add('hidden');&#10;            handleItemNameInput();&#10;        });&#10;        container.appendChild(div);&#10;    });&#10;    container.classList.toggle('hidden', matches.length === 0);&#10;}&#10;&#10;// Utility functions for localStorage&#10;async function loadData() {&#10;    // Use DataService to load persisted data.  DataService returns null if no&#10;    // data exists or if parsing fails.&#10;    const stored = await window.DataService.loadData();&#10;    if (stored) {&#10;        data = stored;&#10;    }&#10;    // Ensure all properties exist&#10;    data.lists = data.lists || [];&#10;    data.globalItems = data.globalItems || [];&#10;    data.categories = data.categories || [];&#10;    data.archivedLists = data.archivedLists || [];&#10;    data.receipts = data.receipts || [];&#10;    data.revision = data.revision || 0;&#10;    // If categories empty, populate default categories with translations&#10;    if (data.categories.length === 0) {&#10;        data.categories = [&#10;            { id: 'produce', names: { en: translations.en.category_produce, he: translations.he.category_produce } },&#10;            { id: 'dairy', names: { en: translations.en.category_dairy, he: translations.he.category_dairy } },&#10;            { id: 'meat', names: { en: translations.en.category_meat, he: translations.he.category_meat } },&#10;            { id: 'bakery', names: { en: translations.en.category_bakery, he: translations.he.category_bakery } },&#10;            { id: 'beverages', names: { en: translations.en.category_beverages, he: translations.he.category_beverages } },&#10;            { id: 'other', names: { en: translations.en.category_other, he: translations.he.category_other } }&#10;        ];&#10;    }&#10;    // Ensure list items have priceBasisQuantity&#10;    data.lists.forEach(list =&gt; {&#10;        list.items = list.items || [];&#10;        list.items.forEach(item =&gt; {&#10;            if (item.priceBasisQuantity == null) item.priceBasisQuantity = 1;&#10;        });&#10;    });&#10;    data.archivedLists.forEach(list =&gt; {&#10;        list.items = list.items || [];&#10;        list.items.forEach(item =&gt; {&#10;            if (item.priceBasisQuantity == null) item.priceBasisQuantity = 1;&#10;        });&#10;    });&#10;    lastSavedData = clone(data);&#10;}&#10;&#10;function saveData(pushUndo = true, operationType = null, operationPath = null, operationData = null) {&#10;    if (pushUndo &amp;&amp; lastSavedData) {&#10;        undoStack.push(clone(lastSavedData));&#10;        if (undoStack.length &gt; 100) undoStack.shift();&#10;        redoStack = [];&#10;    }&#10;    lastSavedData = clone(data);&#10;&#10;    // Track operations for collaborative editing&#10;    const operations = [];&#10;    if (operationType &amp;&amp; operationPath) {&#10;        operations.push(window.DataService.createOperation(operationType, operationPath, operationData));&#10;    }&#10;&#10;    window.DataService.saveData(data, operations);&#10;&#10;    // Send real-time operations for immediate updates&#10;    if (operations.length &gt; 0) {&#10;        window.DataService.sendOperations(operations);&#10;    }&#10;}&#10;&#10;// Apply translations to static UI elements&#10;function applyLanguage() {&#10;    const t = translations[currentLanguage];&#10;    // Set direction for RTL languages&#10;    document.documentElement.setAttribute('dir', currentLanguage === 'he' ? 'rtl' : 'ltr');&#10;    document.getElementById('app-title').innerText = t.app_title;&#10;    document.getElementById('language-label').innerText = t.language_label;&#10;    document.getElementById('tab-lists').innerText = t.tab_lists;&#10;    document.getElementById('tab-summary').innerText = t.tab_summary;&#10;    document.getElementById('tab-items').innerText = t.tab_items;&#10;    document.getElementById('tab-archive').innerText = t.tab_archive;&#10;    document.getElementById('tab-settings').innerText = t.tab_settings;&#10;    // Clear data button&#10;    const clearBtn = document.getElementById('clear-data-button');&#10;    if (clearBtn) {&#10;        clearBtn.innerText = t.clear_data;&#10;    }&#10;    document.getElementById('lists-title').innerText = t.lists_title;&#10;    const addListBtn = document.getElementById('add-list-button');&#10;    addListBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;    addListBtn.title = t.add_list;&#10;    addListBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    document.getElementById('summary-title').innerText = t.summary_title;&#10;    document.getElementById('items-title').innerText = t.items_title;&#10;    document.getElementById('archive-title').innerText = t.archive_title;&#10;    document.getElementById('settings-title').innerText = t.settings_title;&#10;    document.getElementById('currency-label').innerText = t.currency_label;&#10;    document.getElementById('receipt-label').innerText = t.receipt_label;&#10;    // Search placeholder for item search input (if exists)&#10;    const searchInput = document.getElementById('item-search');&#10;    if (searchInput) {&#10;        searchInput.placeholder = t.search_placeholder;&#10;    }&#10;    // Global item modal labels&#10;    const globalModal = document.getElementById('global-item-modal-overlay');&#10;    if (globalModal) {&#10;        document.getElementById('global-item-modal-title').innerText = editingGlobalItemId ? t.modal_edit_global_item : t.modal_new_global_item;&#10;        document.getElementById('global-name-label').innerText = t.global_name;&#10;        document.getElementById('global-category-label').innerText = t.global_category;&#10;        document.getElementById('global-price-label').innerText = t.global_price;&#10;        document.getElementById('global-unit-label').innerText = t.global_unit;&#10;        document.getElementById('save-global-item').innerText = t.save;&#10;        document.getElementById('cancel-global-item-modal').innerText = t.cancel;&#10;        const addGlobalBtn = document.getElementById('add-global-item-button');&#10;        addGlobalBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;        addGlobalBtn.title = t.add_global_item;&#10;        addGlobalBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    }&#10;    // Categories section&#10;    const categoriesTitleEl = document.getElementById('categories-title');&#10;    if (categoriesTitleEl) categoriesTitleEl.innerText = t.categories_title;&#10;    const addCategoryBtn = document.getElementById('add-category-button');&#10;    if (addCategoryBtn) {&#10;        addCategoryBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;        addCategoryBtn.title = t.add_category;&#10;        addCategoryBtn.classList.add('btn', 'btn-primary', 'btn-sm');&#10;    }&#10;    // Render categories names to update language&#10;    renderCategories();&#10;    // Modal texts&#10;    document.getElementById('list-name-label').innerText = t.list_name_label;&#10;    document.getElementById('save-list').innerText = t.save;&#10;    document.getElementById('cancel-modal').innerText = t.cancel;&#10;    document.getElementById('item-name-label').innerText = t.item_name;&#10;    document.getElementById('item-category-label').innerText = t.item_category;&#10;    document.getElementById('item-quantity-label').innerText = t.item_quantity;&#10;    document.getElementById('item-price-label').innerText = t.item_price;&#10;    document.getElementById('item-notes-label').innerText = t.item_notes;&#10;    // Unit label&#10;    const unitLabel = document.getElementById('item-unit-label');&#10;    if (unitLabel) unitLabel.innerText = t.item_unit;&#10;    // Price basis label&#10;    const priceBasisLabel = document.getElementById('item-price-basis-label');&#10;    if (priceBasisLabel) priceBasisLabel.innerText = t.item_price_basis;&#10;    document.getElementById('save-item').innerText = t.save;&#10;    document.getElementById('cancel-item-modal').innerText = t.cancel;&#10;    const addItemBtn = document.getElementById('add-item-button');&#10;    addItemBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;    addItemBtn.title = t.add_item;&#10;    addItemBtn.className = 'btn btn-primary btn-sm';&#10;    const completeBtn = document.getElementById('complete-list-button');&#10;    if (completeBtn) {&#10;        completeBtn.innerHTML = '&lt;i class=&quot;bi bi-check2-circle&quot;&gt;&lt;/i&gt;';&#10;        completeBtn.title = t.complete_list;&#10;        completeBtn.className = 'btn btn-success btn-sm';&#10;    }&#10;    const undoBtn = document.getElementById('undo-button');&#10;    if (undoBtn) {&#10;        undoBtn.innerHTML = '&lt;i class=&quot;bi bi-arrow-counterclockwise&quot;&gt;&lt;/i&gt;';&#10;        undoBtn.title = t.undo;&#10;        undoBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const redoBtn = document.getElementById('redo-button');&#10;    if (redoBtn) {&#10;        redoBtn.innerHTML = '&lt;i class=&quot;bi bi-arrow-clockwise&quot;&gt;&lt;/i&gt;';&#10;        redoBtn.title = t.redo;&#10;        redoBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const closeBtn = document.getElementById('close-list-details');&#10;    closeBtn.innerHTML = '&lt;i class=&quot;bi bi-x-lg&quot;&gt;&lt;/i&gt;';&#10;    closeBtn.title = t.close;&#10;    closeBtn.className = 'btn btn-secondary btn-sm';&#10;    const fsBtn = document.getElementById('toggle-fullscreen');&#10;    if (fsBtn) {&#10;        fsBtn.innerHTML = listFullscreen ? '&lt;i class=&quot;bi bi-fullscreen-exit&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-fullscreen&quot;&gt;&lt;/i&gt;';&#10;        fsBtn.title = listFullscreen ? t.restore : t.maximize;&#10;        fsBtn.className = 'btn btn-secondary btn-sm';&#10;    }&#10;    const checkedHeading = document.getElementById('checked-heading');&#10;    if (checkedHeading) checkedHeading.innerText = t.purchased;&#10;    // Populate categories select for list items using data.categories&#10;    const select = document.getElementById('item-category-select');&#10;    if (select) {&#10;        select.innerHTML = '';&#10;        data.categories.forEach(cat =&gt; {&#10;            const option = document.createElement('option');&#10;            option.value = cat.id;&#10;            // Use names translation if available&#10;            const name = cat.names ? (cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id) : (t[cat.nameKey] || cat.id);&#10;            option.textContent = name;&#10;            select.appendChild(option);&#10;        });&#10;    }&#10;    // Render lists and summary again to update text and direction&#10;    renderLists();&#10;    renderSummary();&#10;    // Render global items and archive for language changes&#10;    renderGlobalItems();&#10;&#10;    // Update global item suggestions for item modal&#10;    updateGlobalItemSuggestions();&#10;&#10;    // Update import/export section texts&#10;    const importTitle = document.getElementById('import-title');&#10;    const importLabel = document.getElementById('import-label');&#10;    const importButton = document.getElementById('import-button');&#10;    const exportCsvButton = document.getElementById('export-csv-button');&#10;    if (importTitle) importTitle.innerText = t.import_title;&#10;    if (importLabel) importLabel.innerText = t.import_label;&#10;    if (importButton) importButton.innerText = t.import_button;&#10;    if (exportCsvButton) exportCsvButton.innerText = t.export_csv;&#10;}&#10;&#10;// Render the list of shopping lists&#10;function renderLists() {&#10;    const container = document.getElementById('list-container');&#10;    container.innerHTML = '';&#10;    data.lists.forEach(list =&gt; {&#10;        const li = document.createElement('li');&#10;        li.className = 'list-group-item d-flex align-items-start justify-content-between gap-2';&#10;        li.setAttribute('data-list-id', list.id);&#10;        const t = translations[currentLanguage];&#10;        // List name and stats&#10;        const info = document.createElement('div');&#10;        info.className = 'flex-grow-1';&#10;        const nameSpan = document.createElement('strong');&#10;        nameSpan.textContent = list.name;&#10;        info.appendChild(nameSpan);&#10;        // Stats: purchased/total&#10;        const total = list.items.length;&#10;        const purchased = list.items.filter(i =&gt; i.isChecked).length;&#10;        const stats = document.createElement('div');&#10;        stats.className = 'small text-muted';&#10;        stats.textContent = `${t.purchased}: ${purchased}/${total}`;&#10;        info.appendChild(stats);&#10;        li.appendChild(info);&#10;        const btnGroup = document.createElement('div');&#10;        btnGroup.className = 'btn-group btn-group-sm';&#10;        // Manage Items button&#10;        const manageBtn = document.createElement('button');&#10;        manageBtn.className = 'btn btn-outline-primary';&#10;        manageBtn.innerHTML = '&lt;i class=&quot;bi bi-list-task&quot;&gt;&lt;/i&gt;';&#10;        manageBtn.title = t.manage_items;&#10;        manageBtn.addEventListener('click', () =&gt; openListDetails(list.id));&#10;        btnGroup.appendChild(manageBtn);&#10;        // Rename button&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = t.rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; openListModal(list.id));&#10;        btnGroup.appendChild(renameBtn);&#10;        // Share link button&#10;        const linkBtn = document.createElement('button');&#10;        linkBtn.className = 'btn btn-outline-secondary';&#10;        linkBtn.innerHTML = '&lt;i class=&quot;bi bi-link-45deg&quot;&gt;&lt;/i&gt;';&#10;        linkBtn.title = t.share_link;&#10;        linkBtn.addEventListener('click', () =&gt; {&#10;            const url = new URL(window.location);&#10;            url.searchParams.set('list', list.id);&#10;            navigator.clipboard.writeText(url.toString());&#10;            alert(t.share_link);&#10;        });&#10;        btnGroup.appendChild(linkBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete list?')) {&#10;                data.lists = data.lists.filter(l =&gt; l.id !== list.id);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        btnGroup.appendChild(deleteBtn);&#10;        li.appendChild(btnGroup);&#10;&#10;        // Check if list is being edited&#10;        if (window.DataService.isBeingEdited(list.id)) {&#10;            const editor = window.DataService.getActiveEditors(list.id);&#10;            showEditingBadge(editor.userId, list.id);&#10;        }&#10;&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;// Render purchase summary across all lists&#10;function renderSummary() {&#10;    const container = document.getElementById('summary-content');&#10;    const t = translations[currentLanguage];&#10;    container.innerHTML = '';&#10;    let totalCostAll = 0;&#10;    data.lists.forEach(list =&gt; {&#10;        const section = document.createElement('div');&#10;        section.style.marginBottom = '1rem';&#10;        const heading = document.createElement('h3');&#10;        heading.textContent = list.name;&#10;        section.appendChild(heading);&#10;        const itemsPurchased = list.items.filter(i =&gt; i.isChecked);&#10;        const itemsMissing = list.items.filter(i =&gt; !i.isChecked);&#10;        // Calculate total cost using actual or estimated price with basis and track estimated cost separately&#10;        let totalCost = 0;&#10;        let totalEstimated = 0;&#10;        itemsPurchased.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            // Actual cost&#10;            let actualCost = 0;&#10;            if (item.actualPrice != null) {&#10;                actualCost = item.actualPrice * (item.quantity / basis);&#10;            } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                actualCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalCost += actualCost;&#10;            // Estimated cost from global item if units match&#10;            let estCost = 0;&#10;            if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                estCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalEstimated += estCost;&#10;        });&#10;        totalCostAll += totalCost;&#10;        const purchasedP = document.createElement('p');&#10;        purchasedP.textContent = `${t.purchased}: ${itemsPurchased.length}`;&#10;        section.appendChild(purchasedP);&#10;        const missingP = document.createElement('p');&#10;        missingP.textContent = `${t.missing}: ${itemsMissing.length}`;&#10;        section.appendChild(missingP);&#10;        const currency = document.getElementById('default-currency').value || '';&#10;        // Show total cost and difference (actual - estimated) if available&#10;        const costP = document.createElement('p');&#10;        costP.textContent = `${t.total_cost}: ${currency}${totalCost.toFixed(2)}`;&#10;        section.appendChild(costP);&#10;        if (totalEstimated &gt; 0) {&#10;            const diff = totalCost - totalEstimated;&#10;            const diffP = document.createElement('p');&#10;            diffP.style.fontSize = '0.8rem';&#10;            diffP.style.color = diff &gt;= 0 ? 'red' : 'green';&#10;            const sign = diff &gt;= 0 ? '+' : '-';&#10;            diffP.textContent = `Difference: ${sign}${currency}${Math.abs(diff).toFixed(2)}`;&#10;            section.appendChild(diffP);&#10;        }&#10;        // Button to create new list with missing items&#10;        if (itemsMissing.length &gt; 0) {&#10;            const createBtn = document.createElement('button');&#10;            createBtn.className = 'btn btn-outline-primary btn-sm';&#10;            createBtn.innerHTML = '&lt;i class=&quot;bi bi-plus-lg&quot;&gt;&lt;/i&gt;';&#10;            createBtn.title = t.create_from_missing;&#10;            createBtn.addEventListener('click', () =&gt; {&#10;                if (!confirm(t.create_from_missing + '?')) return;&#10;                const newList = {&#10;                    id: 'list-' + Date.now(),&#10;                    name: list.name + ' - ' + t.missing,&#10;                    items: itemsMissing.map(item =&gt; ({ ...item, id: 'item-' + Date.now() + Math.random() }))&#10;                };&#10;                data.lists.push(newList);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;                alert('New list created');&#10;            });&#10;            section.appendChild(createBtn);&#10;        }&#10;        container.appendChild(section);&#10;    });&#10;    // Overall total cost&#10;    const overall = document.createElement('p');&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    overall.style.fontWeight = 'bold';&#10;    overall.textContent = `${t.total_cost}: ${currency}${totalCostAll.toFixed(2)}`;&#10;    container.appendChild(overall);&#10;}&#10;&#10;// Render list of global items&#10;function renderGlobalItems() {&#10;    const container = document.getElementById('global-items-container');&#10;    container.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    data.globalItems.forEach(item =&gt; {&#10;        const li = document.createElement('li');&#10;        li.style.display = 'flex';&#10;        li.style.justifyContent = 'space-between';&#10;        li.style.alignItems = 'center';&#10;        li.style.padding = '0.5rem';&#10;        li.style.marginBottom = '0.5rem';&#10;        li.style.backgroundColor = '#f5f5f5';&#10;        li.style.borderRadius = '4px';&#10;        // Info&#10;        const info = document.createElement('div');&#10;        info.style.flex = '1';&#10;        const name = document.createElement('strong');&#10;        name.textContent = item.name;&#10;        info.appendChild(name);&#10;        const cat = data.categories.find(c =&gt; c.id === item.categoryId);&#10;        const catName = cat ? (cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id) : item.categoryId;&#10;        const details = document.createElement('div');&#10;        details.style.fontSize = '0.8rem';&#10;        details.style.marginTop = '0.25rem';&#10;        details.textContent = `${catName} – ${currency}${item.estimatedPrice.toFixed(2)} / ${item.priceUnit}`;&#10;        info.appendChild(details);&#10;        li.appendChild(info);&#10;        // Edit button&#10;        const editBtn = document.createElement('button');&#10;        editBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        editBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        editBtn.title = t.edit_global_item;&#10;        editBtn.addEventListener('click', () =&gt; openGlobalItemModal(item.id));&#10;        li.appendChild(editBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger btn-sm';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete global item?')) {&#10;                data.globalItems = data.globalItems.filter(g =&gt; g.id !== item.id);&#10;                // Remove references in list items&#10;                data.lists.forEach(list =&gt; {&#10;                    list.items = list.items.filter(li =&gt; li.globalItemId !== item.id);&#10;                });&#10;                saveData();&#10;                renderGlobalItems();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        li.appendChild(deleteBtn);&#10;        container.appendChild(li);&#10;    });&#10;    // Update suggestions after rendering&#10;    updateGlobalItemSuggestions();&#10;}&#10;&#10;// Open global item modal (new or edit)&#10;function openGlobalItemModal(itemId = null) {&#10;    editingGlobalItemId = itemId;&#10;    const overlay = document.getElementById('global-item-modal-overlay');&#10;    const t = translations[currentLanguage];&#10;    const titleEl = document.getElementById('global-item-modal-title');&#10;    titleEl.textContent = itemId ? t.modal_edit_global_item : t.modal_new_global_item;&#10;    // Populate category select&#10;    const catSelect = document.getElementById('global-category-select');&#10;    catSelect.innerHTML = '';&#10;    data.categories.forEach(cat =&gt; {&#10;        const opt = document.createElement('option');&#10;        opt.value = cat.id;&#10;        opt.textContent = cat.names[currentLanguage] || cat.names.en || cat.names.he;&#10;        catSelect.appendChild(opt);&#10;    });&#10;    if (itemId) {&#10;        const item = data.globalItems.find(g =&gt; g.id === itemId);&#10;        document.getElementById('global-name-input').value = item.name;&#10;        document.getElementById('global-category-select').value = item.categoryId;&#10;        document.getElementById('global-price-input').value = item.estimatedPrice;&#10;        document.getElementById('global-unit-select').value = item.priceUnit;&#10;    } else {&#10;        document.getElementById('global-name-input').value = '';&#10;        document.getElementById('global-category-select').value = data.categories[0].id;&#10;        document.getElementById('global-price-input').value = 0;&#10;        document.getElementById('global-unit-select').value = 'piece';&#10;    }&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeGlobalItemModal() {&#10;    document.getElementById('global-item-modal-overlay').classList.add('hidden');&#10;}&#10;&#10;function saveGlobalItem() {&#10;    const name = document.getElementById('global-name-input').value.trim();&#10;    const categoryId = document.getElementById('global-category-select').value;&#10;    const price = parseFloat(document.getElementById('global-price-input').value) || 0;&#10;    const unit = document.getElementById('global-unit-select').value;&#10;    if (!name) return;&#10;    if (editingGlobalItemId) {&#10;        const item = data.globalItems.find(g =&gt; g.id === editingGlobalItemId);&#10;        if (item) {&#10;            item.name = name;&#10;            item.categoryId = categoryId;&#10;            item.estimatedPrice = price;&#10;            item.priceUnit = unit;&#10;        }&#10;    } else {&#10;        const newItem = {&#10;            id: 'global-' + Date.now(),&#10;            name,&#10;            categoryId,&#10;            estimatedPrice: price,&#10;            priceUnit: unit,&#10;            createdAt: new Date().toISOString(),&#10;            updatedAt: new Date().toISOString()&#10;        };&#10;        data.globalItems.push(newItem);&#10;    }&#10;    saveData();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;    closeGlobalItemModal();&#10;}&#10;&#10;// Open list creation/edit modal&#10;function openListModal(listId = null) {&#10;    editingListId = listId;&#10;    const overlay = document.getElementById('modal-overlay');&#10;    const title = document.getElementById('modal-title');&#10;    const t = translations[currentLanguage];&#10;    if (listId) {&#10;        title.textContent = t.modal_edit_list;&#10;        const list = data.lists.find(l =&gt; l.id === listId);&#10;        document.getElementById('list-name-input').value = list ? list.name : '';&#10;    } else {&#10;        title.textContent = t.modal_new_list;&#10;        document.getElementById('list-name-input').value = '';&#10;    }&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeListModal() {&#10;    document.getElementById('modal-overlay').classList.add('hidden');&#10;}&#10;&#10;// Save list (new or edited)&#10;function saveList() {&#10;    const name = document.getElementById('list-name-input').value.trim();&#10;    if (!name) return;&#10;    if (editingListId) {&#10;        // Edit existing&#10;        const list = data.lists.find(l =&gt; l.id === editingListId);&#10;        if (list) list.name = name;&#10;    } else {&#10;        // Create new&#10;        data.lists.push({ id: 'list-' + Date.now(), name: name, items: [] });&#10;    }&#10;    saveData();&#10;    renderLists();&#10;    closeListModal();&#10;    renderSummary();&#10;}&#10;&#10;// Open list details overlay to manage items&#10;function openListDetails(listId, isArchive = false) {&#10;    editingArchive = isArchive;&#10;    editingItemListId = listId;&#10;    editingItemId = null;&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId);&#10;    isEditing = true;&#10;    currentEditingContext = { listId, isArchive };&#10;&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const title = document.getElementById('list-details-title');&#10;&#10;    const list = (isArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;    const t = translations[currentLanguage];&#10;&#10;    if (list) {&#10;        title.textContent = list.name;&#10;        title.setAttribute('data-list-id', listId);&#10;        renderItems(list);&#10;    }&#10;&#10;    overlay.classList.remove('hidden');&#10;    const url = new URL(window.location);&#10;    url.searchParams.set('list', listId);&#10;    history.replaceState(null, '', url);&#10;    applyFullscreenState();&#10;&#10;    // Show editing indicators&#10;    showEditingIndicators(listId);&#10;}&#10;&#10;function closeListDetails() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId);&#10;        clearEditingBadges(currentEditingContext.listId);&#10;        currentEditingContext = null;&#10;    }&#10;&#10;    isEditing = false;&#10;&#10;    const url = new URL(window.location);&#10;    url.searchParams.delete('list');&#10;    history.replaceState(null, '', url);&#10;}&#10;&#10;// Open item modal to create or edit an item&#10;function openItemModal(listId, itemId = null) {&#10;    editingItemListId = listId;&#10;    editingItemId = itemId;&#10;&#10;    // Check if item is being edited by someone else&#10;    if (itemId &amp;&amp; window.DataService.isBeingEdited(listId, itemId)) {&#10;        const editor = window.DataService.getActiveEditors(listId, itemId);&#10;        const t = translations[currentLanguage];&#10;        if (!confirm(`${editor.userId} is currently editing this item. Continue anyway?`)) {&#10;            return;&#10;        }&#10;    }&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId, itemId);&#10;&#10;    const overlay = document.getElementById('item-modal-overlay');&#10;    const t = translations[currentLanguage];&#10;    const title = document.getElementById('item-modal-title');&#10;    if (itemId) {&#10;        title.textContent = t.item_modal_edit;&#10;        const list = (editingArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;        const item = list.items.find(i =&gt; i.id === itemId);&#10;        // Derive global item&#10;        const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;        const nameInput = document.getElementById('item-name-input');&#10;        nameInput.value = globalItem ? globalItem.name : '';&#10;        if (globalItem) {&#10;            nameInput.dataset.selectedId = globalItem.id;&#10;        } else {&#10;            delete nameInput.dataset.selectedId;&#10;        }&#10;        // Category comes from global item&#10;        document.getElementById('item-category-select').value = globalItem ? globalItem.categoryId : data.categories[0].id;&#10;        // Quantity and unit&#10;        document.getElementById('item-quantity-input').value = item.quantity;&#10;        document.getElementById('item-unit-select').value = item.quantityUnit || (globalItem ? globalItem.priceUnit : 'piece');&#10;        // Price (actual price)&#10;        document.getElementById('item-price-input').value = item.actualPrice != null ? item.actualPrice : '';&#10;        document.getElementById('item-price-basis-input').value = item.priceBasisQuantity || 1;&#10;        document.getElementById('item-notes-input').value = item.notes || '';&#10;    } else {&#10;        title.textContent = t.item_modal_new;&#10;        const nameInput = document.getElementById('item-name-input');&#10;        nameInput.value = '';&#10;        delete nameInput.dataset.selectedId;&#10;        // Default values&#10;        document.getElementById('item-category-select').value = data.categories[0].id;&#10;        document.getElementById('item-quantity-input').value = 1;&#10;        document.getElementById('item-unit-select').value = 'piece';&#10;        document.getElementById('item-price-input').value = 0;&#10;        document.getElementById('item-price-basis-input').value = 1;&#10;        document.getElementById('item-notes-input').value = '';&#10;    }&#10;    // Add data attributes for tracking&#10;    const modal = document.getElementById('item-modal');&#10;    modal.setAttribute('data-list-id', listId);&#10;    if (itemId) modal.setAttribute('data-item-id', itemId);&#10;&#10;    overlay.classList.remove('hidden');&#10;}&#10;&#10;function closeItemModal() {&#10;    const overlay = document.getElementById('item-modal-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (editingItemListId) {&#10;        window.DataService.updatePresence('editEnd', editingItemListId, editingItemId);&#10;        clearEditingBadges(editingItemListId, editingItemId);&#10;    }&#10;&#10;    const nameInput = document.getElementById('item-name-input');&#10;    if (nameInput) delete nameInput.dataset.selectedId;&#10;}&#10;&#10;// Save item (new or edited)&#10;function saveItem() {&#10;    const list = (editingArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === editingItemListId);&#10;    if (!list) return;&#10;&#10;    const nameInput = document.getElementById('item-name-input');&#10;    const name = nameInput.value.trim();&#10;    const categoryId = document.getElementById('item-category-select').value;&#10;    const quantity = parseFloat(document.getElementById('item-quantity-input').value) || 1;&#10;    const quantityUnit = document.getElementById('item-unit-select').value || 'piece';&#10;    // Parse actual price; if input is empty or whitespace treat as null so that estimated price is used&#10;    const priceStr = document.getElementById('item-price-input').value.trim();&#10;    const price = priceStr ? parseFloat(priceStr) : null;&#10;    const priceBasisQuantity = parseFloat(document.getElementById('item-price-basis-input').value) || 1;&#10;    const notes = document.getElementById('item-notes-input').value.trim();&#10;    if (!name) return;&#10;    // Determine global item reference&#10;    let globalItem = null;&#10;    if (nameInput.dataset.selectedId) {&#10;        globalItem = data.globalItems.find(g =&gt; g.id === nameInput.dataset.selectedId);&#10;    }&#10;    if (!globalItem) {&#10;        // Find existing global item by name and category&#10;        globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === name.toLowerCase() &amp;&amp; g.categoryId === categoryId);&#10;    }&#10;    if (!globalItem) {&#10;        // Create new global item; use estimated price from actual price input if provided, otherwise 0&#10;        const estimated = price != null ? price : 0;&#10;        globalItem = {&#10;            id: 'global-' + Date.now() + Math.random(),&#10;            name,&#10;            categoryId,&#10;            estimatedPrice: estimated,&#10;            priceUnit: quantityUnit,&#10;            createdAt: new Date().toISOString(),&#10;            updatedAt: new Date().toISOString()&#10;        };&#10;        data.globalItems.push(globalItem);&#10;    }&#10;    if (editingItemId) {&#10;        // Edit existing list item&#10;        const item = list.items.find(i =&gt; i.id === editingItemId);&#10;        if (item) {&#10;            // If the global item reference has changed and another item with the same global item exists,&#10;            // merge them instead of creating duplicates&#10;            const oldGlobalId = item.globalItemId;&#10;            item.globalItemId = globalItem.id;&#10;            // Check if there is another item in the same list with the same globalItemId (excluding this item)&#10;            const duplicate = list.items.find(i =&gt; i.id !== item.id &amp;&amp; i.globalItemId === globalItem.id);&#10;            if (duplicate) {&#10;                // Merge current item's data into the duplicate&#10;                // Sum quantities if units match; otherwise keep separate quantities but still merge&#10;                if (duplicate.quantityUnit === quantityUnit) {&#10;                    duplicate.quantity += quantity;&#10;                } else {&#10;                    // Different units; store them separately by creating a notes entry&#10;                    duplicate.notes = duplicate.notes ? `${duplicate.notes}; ${quantity} ${quantityUnit}` : `${quantity} ${quantityUnit}`;&#10;                }&#10;                // Prefer actual price from the edit if provided, otherwise keep existing&#10;                if (price != null) duplicate.actualPrice = price;&#10;                // Merge price basis quantity: take max of the two (to avoid losing precision)&#10;                duplicate.priceBasisQuantity = Math.max(duplicate.priceBasisQuantity || 1, priceBasisQuantity || 1);&#10;                // Merge notes&#10;                if (notes) {&#10;                    duplicate.notes = duplicate.notes ? `${duplicate.notes}; ${notes}` : notes;&#10;                }&#10;                // Remove the old item from list&#10;                const index = list.items.findIndex(i =&gt; i.id === item.id);&#10;                if (index &gt;= 0) list.items.splice(index, 1);&#10;            } else {&#10;                // No duplicate, just update the item values normally&#10;                item.quantity = quantity;&#10;                item.quantityUnit = quantityUnit;&#10;                item.actualPrice = price;&#10;                item.priceBasisQuantity = priceBasisQuantity;&#10;                item.notes = notes;&#10;            }&#10;        }&#10;    } else {&#10;        // When creating a new list item, check if one already exists with the same globalItemId&#10;        const existing = list.items.find(i =&gt; i.globalItemId === globalItem.id &amp;&amp; i.quantityUnit === quantityUnit);&#10;        if (existing) {&#10;            // Merge new quantity and details into existing item&#10;            existing.quantity += quantity;&#10;            if (price != null) existing.actualPrice = price;&#10;            existing.priceBasisQuantity = Math.max(existing.priceBasisQuantity || 1, priceBasisQuantity || 1);&#10;            if (notes) {&#10;                existing.notes = existing.notes ? `${existing.notes}; ${notes}` : notes;&#10;            }&#10;        } else {&#10;            // Create new list item with wrapper referencing global item&#10;            list.items.push({&#10;                id: 'item-' + Date.now() + Math.random(),&#10;                globalItemId: globalItem.id,&#10;                quantity,&#10;                quantityUnit,&#10;                actualPrice: price,&#10;                priceBasisQuantity,&#10;                notes,&#10;                isChecked: false&#10;            });&#10;        }&#10;    }&#10;    const operationType = editingItemId ? 'update' : 'create';&#10;    const operationPath = editingItemId ?&#10;        `lists/${editingItemListId}/items/${editingItemId}` :&#10;        `lists/${editingItemListId}/items`;&#10;&#10;    // Track the operation for collaborative editing&#10;    saveData(true, operationType, operationPath, editingItemId ? item : newItem);&#10;&#10;    renderItems(list);&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;&#10;    if (editingArchive) {&#10;        renderArchive();&#10;    }&#10;&#10;    closeItemModal();&#10;}&#10;&#10;function applyFullscreenState() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const modal = document.getElementById('list-details');&#10;    const btn = document.getElementById('toggle-fullscreen');&#10;    if (listFullscreen) {&#10;        overlay.classList.add('fullscreen');&#10;        modal.classList.add('fullscreen');&#10;        if (btn) btn.innerText = translations[currentLanguage].restore;&#10;    } else {&#10;        overlay.classList.remove('fullscreen');&#10;        modal.classList.remove('fullscreen');&#10;        if (btn) btn.innerText = translations[currentLanguage].maximize;&#10;    }&#10;}&#10;&#10;function toggleListFullscreen() {&#10;    listFullscreen = !listFullscreen;&#10;    localStorage.setItem('listFullscreen', listFullscreen);&#10;    applyFullscreenState();&#10;}&#10;&#10;function getItemCategory(item) {&#10;    const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;    return globalItem ? globalItem.categoryId : (item.categoryId || 'other');&#10;}&#10;&#10;function moveCategory(catId, dir, list) {&#10;    const idx = data.categories.findIndex(c =&gt; c.id === catId);&#10;    const newIdx = idx + dir;&#10;    if (newIdx &lt; 0 || newIdx &gt;= data.categories.length) return;&#10;    const [cat] = data.categories.splice(idx, 1);&#10;    data.categories.splice(newIdx, 0, cat);&#10;    saveData();&#10;    renderCategories();&#10;    renderItems(list);&#10;}&#10;&#10;function moveItem(list, itemId, dir) {&#10;    const idx = list.items.findIndex(i =&gt; i.id === itemId);&#10;    const newIdx = idx + dir;&#10;    if (newIdx &lt; 0 || newIdx &gt;= list.items.length) return;&#10;    const [it] = list.items.splice(idx, 1);&#10;    list.items.splice(newIdx, 0, it);&#10;    saveData();&#10;    renderItems(list);&#10;}&#10;&#10;function setCategoryChecked(list, catId, checked) {&#10;    list.items.forEach(it =&gt; {&#10;        if (getItemCategory(it) === catId) {&#10;            it.isChecked = checked;&#10;        }&#10;    });&#10;    saveData();&#10;    renderItems(list);&#10;    renderLists();&#10;    renderSummary();&#10;}&#10;&#10;// Render items of current list&#10;function renderItems(list) {&#10;    const container = document.getElementById('items-container');&#10;    const checkedContainer = document.getElementById('checked-items-container');&#10;    container.innerHTML = '';&#10;    checkedContainer.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    const term = itemSearchTerm.toLowerCase();&#10;    const groups = {};&#10;    list.items.filter(item =&gt; {&#10;        const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;        const itemName = globalItem ? globalItem.name : item.name;&#10;        return !term || (itemName &amp;&amp; itemName.toLowerCase().includes(term));&#10;    }).forEach(item =&gt; {&#10;        const cid = getItemCategory(item);&#10;        if (!groups[cid]) groups[cid] = [];&#10;        groups[cid].push(item);&#10;    });&#10;    data.categories.forEach(cat =&gt; {&#10;        const catId = cat.id;&#10;        const items = groups[catId] || [];&#10;        if (items.length === 0) return;&#10;        const catName = cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id;&#10;        const unchecked = items.filter(i =&gt; !i.isChecked);&#10;        const checked = items.filter(i =&gt; i.isChecked);&#10;        const renderSection = (target, arr) =&gt; {&#10;            const heading = document.createElement('div');&#10;            heading.className = 'category-heading d-flex align-items-center gap-2';&#10;            const collapseBtn = document.createElement('button');&#10;            collapseBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            collapseBtn.innerHTML = collapsedCategories[catId] ? '&lt;i class=&quot;bi bi-chevron-right&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;            collapseBtn.addEventListener('click', () =&gt; {&#10;                collapsedCategories[catId] = !collapsedCategories[catId];&#10;                localStorage.setItem('collapsedCategories', JSON.stringify(collapsedCategories));&#10;                renderItems(list);&#10;            });&#10;            heading.appendChild(collapseBtn);&#10;            const span = document.createElement('span');&#10;            span.textContent = catName;&#10;            heading.appendChild(span);&#10;            const checkBox = document.createElement('input');&#10;            checkBox.type = 'checkbox';&#10;            checkBox.className = 'form-check-input ms-2';&#10;            checkBox.checked = arr.length &gt; 0 &amp;&amp; arr.every(i =&gt; i.isChecked);&#10;            checkBox.addEventListener('change', () =&gt; {&#10;                setCategoryChecked(list, catId, checkBox.checked);&#10;            });&#10;            heading.appendChild(checkBox);&#10;            const upBtn = document.createElement('button');&#10;            upBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            upBtn.innerHTML = '&lt;i class=&quot;bi bi-chevron-up&quot;&gt;&lt;/i&gt;';&#10;            upBtn.addEventListener('click', () =&gt; moveCategory(catId, -1, list));&#10;            heading.appendChild(upBtn);&#10;            const downBtn = document.createElement('button');&#10;            downBtn.className = 'btn btn-sm btn-outline-secondary';&#10;            downBtn.innerHTML = '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;            downBtn.addEventListener('click', () =&gt; moveCategory(catId, 1, list));&#10;            heading.appendChild(downBtn);&#10;            target.appendChild(heading);&#10;            if (!collapsedCategories[catId]) {&#10;                arr.forEach(item =&gt; {&#10;                    const li = document.createElement('li');&#10;                    li.className = 'list-group-item d-flex align-items-start gap-2';&#10;                    li.setAttribute('data-item-id', item.id);&#10;                    const checkbox = document.createElement('input');&#10;                    checkbox.type = 'checkbox';&#10;                    checkbox.className = 'form-check-input mt-1';&#10;                    checkbox.checked = item.isChecked;&#10;                    checkbox.addEventListener('change', () =&gt; {&#10;                        item.isChecked = checkbox.checked;&#10;                        saveData();&#10;                        renderItems(list);&#10;                        renderLists();&#10;                        renderSummary();&#10;                    });&#10;                    li.appendChild(checkbox);&#10;                    const info = document.createElement('span');&#10;                    info.className = 'item-text flex-grow-1';&#10;                    info.style.textDecoration = item.isChecked ? 'line-through' : 'none';&#10;                    const currency = document.getElementById('default-currency').value || '';&#10;                    const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;                    const itemName = globalItem ? globalItem.name : item.name;&#10;                    const unit = item.quantityUnit || '';&#10;                    const priceVal = item.actualPrice != null ? item.actualPrice : (globalItem ? globalItem.estimatedPrice : 0);&#10;                    const basis = item.priceBasisQuantity || 1;&#10;                    const priceUnit = item.actualPrice != null ? item.quantityUnit : (globalItem ? globalItem.priceUnit : item.quantityUnit);&#10;                    let totalCost = null;&#10;                    if (item.actualPrice != null) {&#10;                        totalCost = priceVal * (item.quantity / basis);&#10;                    } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                        totalCost = priceVal * (item.quantity / basis);&#10;                    }&#10;                    const quantityDisplay = `${item.quantity}${unit ? ' ' + unit : ''}`;&#10;                    let priceDisplay = `${currency}${priceVal.toFixed(2)}`;&#10;                    if (basis !== 1) priceDisplay += ` / ${basis}`;&#10;                    if (priceUnit) priceDisplay += ` ${priceUnit}`;&#10;                    let text = `${itemName} (${quantityDisplay})`;&#10;                    text += `, ${priceDisplay}`;&#10;                    if (totalCost != null) {&#10;                        text += ` × ${item.quantity} = ${currency}${totalCost.toFixed(2)}`;&#10;                    }&#10;                    info.textContent = text;&#10;                    li.appendChild(info);&#10;                    const btnGroup = document.createElement('div');&#10;                    btnGroup.className = 'btn-group btn-group-sm';&#10;                    const up = document.createElement('button');&#10;                    up.className = 'btn btn-outline-secondary';&#10;                    up.innerHTML = '&lt;i class=&quot;bi bi-chevron-up&quot;&gt;&lt;/i&gt;';&#10;                    up.addEventListener('click', () =&gt; moveItem(list, item.id, -1));&#10;                    btnGroup.appendChild(up);&#10;                    const down = document.createElement('button');&#10;                    down.className = 'btn btn-outline-secondary';&#10;                    down.innerHTML = '&lt;i class=&quot;bi bi-chevron-down&quot;&gt;&lt;/i&gt;';&#10;                    down.addEventListener('click', () =&gt; moveItem(list, item.id, 1));&#10;                    btnGroup.appendChild(down);&#10;                    const editBtn = document.createElement('button');&#10;                    editBtn.className = 'btn btn-outline-secondary';&#10;                    editBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;                    editBtn.title = t.rename_list;&#10;                    editBtn.addEventListener('click', () =&gt; openItemModal(list.id, item.id));&#10;                    btnGroup.appendChild(editBtn);&#10;                    const deleteBtn = document.createElement('button');&#10;                    deleteBtn.className = 'btn btn-outline-danger';&#10;                    deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;                    deleteBtn.title = t.delete_list;&#10;                    deleteBtn.addEventListener('click', () =&gt; {&#10;                        const index = list.items.findIndex(i =&gt; i.id === item.id);&#10;                        if (index &gt;= 0) {&#10;                            list.items.splice(index, 1);&#10;                            saveData();&#10;                            renderItems(list);&#10;                            renderLists();&#10;                            renderSummary();&#10;                        }&#10;                    });&#10;                    btnGroup.appendChild(deleteBtn);&#10;                    li.appendChild(btnGroup);&#10;                    target.appendChild(li);&#10;                });&#10;            }&#10;        };&#10;        if (unchecked.length &gt; 0) renderSection(container, unchecked);&#10;        if (checked.length &gt; 0) renderSection(checkedContainer, checked);&#10;    });&#10;    const hasChecked = checkedContainer.children.length &gt; 0;&#10;    checkedContainer.style.display = hasChecked ? '' : 'none';&#10;    const headingEl = document.getElementById('checked-heading');&#10;    if (headingEl) headingEl.style.display = hasChecked ? '' : 'none';&#10;}&#10;&#10;function showPage(page) {&#10;    document.querySelectorAll('.page').forEach(p =&gt; p.classList.remove('active'));&#10;    document.querySelectorAll('nav button').forEach(b =&gt; b.classList.remove('active'));&#10;    document.getElementById(`page-${page}`).classList.add('active');&#10;    document.getElementById(`tab-${page}`).classList.add('active');&#10;    if (page === 'summary') renderSummary();&#10;    if (page === 'items') renderGlobalItems();&#10;    if (page === 'archive') renderArchive();&#10;}&#10;&#10;// Run init on DOM ready&#10;document.addEventListener('DOMContentLoaded', init);&#10;&#10;// Collaboration state management&#10;function updateCollaborationState() {&#10;    // Update presence indicators&#10;    showPresenceIndicators();&#10;&#10;    // Clear existing editing badges&#10;    clearEditingBadges();&#10;&#10;    // Show editing indicators for active editors&#10;    Object.values(activeEditors).forEach(editor =&gt; {&#10;        const [listId, itemId] = editor.key.split('/');&#10;        showEditingIndicators(listId, itemId);&#10;    });&#10;}&#10;&#10;// Enhanced initialization with collaboration features&#10;async function init() {&#10;    await loadData();&#10;&#10;    // Set up conflict resolver&#10;    window.DataService.conflictResolver = async (mergedData, originalData) =&gt; {&#10;        const conflicts = mergedData._conflicts || [];&#10;        if (conflicts.length &gt; 0) {&#10;            return await showConflictResolutionModal(conflicts, mergedData, originalData);&#10;        }&#10;        return mergedData;&#10;    };&#10;&#10;    // Set up user identification&#10;    let userName = localStorage.getItem('shopping-list-username');&#10;    if (!userName) {&#10;        userName = prompt('Enter your name for collaboration:') || `User-${Date.now().toString(36)}`;&#10;        localStorage.setItem('shopping-list-username', userName);&#10;    }&#10;    window.DataService.setCurrentUser({ name: userName });&#10;&#10;    setupEvents();&#10;    applyLanguage();&#10;    renderLists();&#10;    renderSummary();&#10;    // Display existing receipts names if any&#10;    displayReceipts();&#10;    // Render global items and archive&#10;    renderGlobalItems();&#10;    renderCategories();&#10;&#10;    // If using a remote server for data persistence, connect to its&#10;    // WebSocket endpoint so that updates from other clients are pushed&#10;    // into this instance.  The DataService will set up a socket.io&#10;    // connection and call onRemoteDataUpdated() whenever data is updated.&#10;    if (window.DataService &amp;&amp; window.DataService.useServer) {&#10;        window.DataService.initSocket();&#10;    }&#10;    const params = new URLSearchParams(window.location.search);&#10;    const linked = params.get('list');&#10;    if (linked) {&#10;        showPage('lists');&#10;        openListDetails(linked);&#10;    }&#10;}&#10;&#10;// Display list of uploaded receipts (names only) in summary page&#10;function displayReceipts() {&#10;    const listDiv = document.getElementById('receipt-list');&#10;    if (!listDiv) return;&#10;    listDiv.innerHTML = '';&#10;    (data.receipts || []).forEach(rec =&gt; {&#10;        const p = document.createElement('p');&#10;        p.textContent = rec.name;&#10;        listDiv.appendChild(p);&#10;    });&#10;}&#10;&#10;// Render archived purchases&#10;function renderArchive() {&#10;    const container = document.getElementById('archive-content');&#10;    if (!container) return;&#10;    container.innerHTML = '';&#10;    const t = translations[currentLanguage];&#10;    if (!data.archivedLists || data.archivedLists.length === 0) {&#10;        const p = document.createElement('p');&#10;        p.textContent = t.missing || 'No archives yet';&#10;        container.appendChild(p);&#10;        return;&#10;    }&#10;    const currency = document.getElementById('default-currency').value || '';&#10;    data.archivedLists.forEach(list =&gt; {&#10;        const section = document.createElement('div');&#10;        section.style.marginBottom = '1rem';&#10;        const heading = document.createElement('h3');&#10;        heading.textContent = list.name;&#10;        section.appendChild(heading);&#10;        // completion date&#10;        if (list.completedAt) {&#10;            const dateP = document.createElement('p');&#10;            dateP.textContent = new Date(list.completedAt).toLocaleDateString();&#10;            section.appendChild(dateP);&#10;        }&#10;        // totals: compute cost using actual or estimated price with basis&#10;        let totalActual = 0;&#10;        let totalEst = 0;&#10;        list.items.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            let actualCost = 0;&#10;            if (item.actualPrice != null) {&#10;                actualCost = item.actualPrice * (item.quantity / basis);&#10;            } else if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                actualCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalActual += actualCost;&#10;            let estCost = 0;&#10;            if (globalItem &amp;&amp; globalItem.priceUnit === item.quantityUnit) {&#10;                estCost = (globalItem.estimatedPrice || 0) * (item.quantity / basis);&#10;            }&#10;            totalEst += estCost;&#10;        });&#10;        const pTotal = document.createElement('p');&#10;        pTotal.textContent = `${t.total_cost}: ${currency}${totalActual.toFixed(2)}`;&#10;        section.appendChild(pTotal);&#10;        if (totalEst &gt; 0) {&#10;            const diff = totalActual - totalEst;&#10;            const diffP = document.createElement('p');&#10;            diffP.style.fontSize = '0.8rem';&#10;            diffP.style.color = diff &gt;= 0 ? 'red' : 'green';&#10;            const sign = diff &gt;= 0 ? '+' : '-';&#10;            diffP.textContent = `Difference: ${sign}${currency}${Math.abs(diff).toFixed(2)}`;&#10;            section.appendChild(diffP);&#10;        }&#10;        // receipts (names)&#10;        if (list.receiptImages &amp;&amp; list.receiptImages.length &gt; 0) {&#10;            const receiptsDiv = document.createElement('div');&#10;            const recHeading = document.createElement('p');&#10;            recHeading.textContent = t.receipt_label;&#10;            receiptsDiv.appendChild(recHeading);&#10;            list.receiptImages.forEach(r =&gt; {&#10;                const pName = document.createElement('p');&#10;                pName.textContent = r.name || r;&#10;                receiptsDiv.appendChild(pName);&#10;            });&#10;            section.appendChild(receiptsDiv);&#10;        }&#10;        // View button to open archived list details for editing&#10;        const viewBtn = document.createElement('button');&#10;        viewBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        viewBtn.innerHTML = '&lt;i class=&quot;bi bi-eye&quot;&gt;&lt;/i&gt;';&#10;        viewBtn.title = t.archive_view;&#10;        viewBtn.addEventListener('click', () =&gt; {&#10;            openListDetails(list.id, true);&#10;        });&#10;        section.appendChild(viewBtn);&#10;        container.appendChild(section);&#10;    });&#10;}&#10;&#10;// Render categories in settings page&#10;function renderCategories() {&#10;    const container = document.getElementById('categories-container');&#10;    if (!container) return;&#10;    container.innerHTML = '';&#10;    data.categories.forEach(cat =&gt; {&#10;        const li = document.createElement('li');&#10;        li.style.display = 'flex';&#10;        li.style.justifyContent = 'space-between';&#10;        li.style.alignItems = 'center';&#10;        li.style.padding = '0.3rem 0';&#10;        const nameSpan = document.createElement('span');&#10;        nameSpan.textContent = cat.names[currentLanguage] || cat.names.en || cat.names.he || cat.id;&#10;        li.appendChild(nameSpan);&#10;        // Edit button for categories (rename names)&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary btn-sm';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = translations[currentLanguage].rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; {&#10;            // Prompt for new names in both languages&#10;            const newNameEn = prompt('New category name (English)', cat.names.en || '');&#10;            if (newNameEn == null) return;&#10;            const newNameHe = prompt('New category name (Hebrew)', cat.names.he || newNameEn);&#10;            if (newNameHe == null) return;&#10;            cat.names.en = newNameEn.trim() || cat.names.en;&#10;            cat.names.he = newNameHe.trim() || cat.names.he;&#10;            saveData();&#10;            renderCategories();&#10;            applyLanguage();&#10;        });&#10;        li.appendChild(renameBtn);&#10;        // Delete button for custom categories (not default ones)&#10;        if (!cat.id.startsWith('produce') &amp;&amp; !cat.id.startsWith('dairy') &amp;&amp; !cat.id.startsWith('meat') &amp;&amp; !cat.id.startsWith('bakery') &amp;&amp; !cat.id.startsWith('beverages') &amp;&amp; cat.id !== 'other') {&#10;            const delBtn = document.createElement('button');&#10;            delBtn.className = 'btn btn-outline-danger btn-sm';&#10;            delBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;            delBtn.title = translations[currentLanguage].delete_list;&#10;            delBtn.addEventListener('click', () =&gt; {&#10;                if (confirm('Delete category?')) {&#10;                    // Remove category from data.categories&#10;                    data.categories = data.categories.filter(c =&gt; c.id !== cat.id);&#10;                    // Determine fallback category id (use 'other')&#10;                    const fallbackId = 'other';&#10;                    // Reassign items and global items using this category to fallback&#10;                    // Update all global items using this category to fallback&#10;                    data.globalItems.forEach(item =&gt; {&#10;                        if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                    });&#10;                    // For backwards compatibility, update old list item categoryId fields&#10;                    data.lists.forEach(list =&gt; {&#10;                        list.items.forEach(item =&gt; {&#10;                            if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                        });&#10;                    });&#10;                    data.archivedLists.forEach(list =&gt; {&#10;                        list.items.forEach(item =&gt; {&#10;                            if (item.categoryId === cat.id) item.categoryId = fallbackId;&#10;                        });&#10;                    });&#10;                    saveData();&#10;                    renderCategories();&#10;                    applyLanguage();&#10;                }&#10;            });&#10;            li.appendChild(delBtn);&#10;        }&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;function addCategory() {&#10;    const input = document.getElementById('new-category-input');&#10;    const name = input.value.trim();&#10;    if (!name) return;&#10;    // Create slug id&#10;    const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '') + '-' + Date.now();&#10;    const names = { en: name, he: name };&#10;    data.categories.push({ id, names });&#10;    input.value = '';&#10;    saveData();&#10;    renderCategories();&#10;    applyLanguage();&#10;}&#10;&#10;// Import lists from Google Keep note text&#10;function importFromKeep() {&#10;    const textarea = document.getElementById('import-textarea');&#10;    if (!textarea) return;&#10;    const text = textarea.value.trim();&#10;    if (!text) return;&#10;    // Ask for list name (default: Imported List)&#10;    let listName = prompt('List name', 'Imported List');&#10;    if (!listName) return;&#10;    const lines = text.split(/\r?\n/);&#10;    const items = [];&#10;    let currentCategoryName = null;&#10;    lines.forEach(line =&gt; {&#10;        // Remove comments after '//'&#10;        const commentIndex = line.indexOf('//');&#10;        let contentLine = commentIndex &gt;= 0 ? line.slice(0, commentIndex) : line;&#10;        // Trim whitespace and indentation&#10;        let trimmed = contentLine.trim();&#10;        if (!trimmed) return;&#10;        // Match checkbox pattern [ ] or [X]&#10;        const match = trimmed.match(/^\[( |X|x)\]\s*(.*)$/);&#10;        if (!match) return;&#10;        const checkedChar = match[1];&#10;        let content = match[2].trim();&#10;        const isChecked = checkedChar.toUpperCase() === 'X';&#10;        if (!content) return;&#10;        // Category line if content ends with ':'&#10;        if (content.endsWith(':')) {&#10;            const categoryName = content.slice(0, -1).trim();&#10;            if (categoryName) {&#10;                currentCategoryName = categoryName;&#10;            }&#10;            return;&#10;        }&#10;        // Item line&#10;        let namePart = content;&#10;        let notes = '';&#10;        // Extract note after '-' character&#10;        const dashIndex = namePart.indexOf('-');&#10;        if (dashIndex &gt;= 0) {&#10;            notes = namePart.slice(dashIndex + 1).trim();&#10;            namePart = namePart.slice(0, dashIndex).trim();&#10;        }&#10;        // Extract quantity and unit from patterns like &quot;Bananas*4&quot;, &quot;Bananas*4 kg&quot; or &quot;Bananas x4&quot;&#10;        let quantity = 1;&#10;        let quantityUnit = 'piece';&#10;        const qtyMatch = namePart.match(/^(.*?)(?:[\*×x]\s*(\d+(?:\.\d+)?)(?:\s*(kg|liter|package|piece))?)$/i);&#10;        if (qtyMatch) {&#10;            namePart = qtyMatch[1].trim();&#10;            quantity = parseFloat(qtyMatch[2]);&#10;            if (qtyMatch[3]) quantityUnit = qtyMatch[3].toLowerCase();&#10;        }&#10;        // Determine category: currentCategoryName or default 'Other'&#10;        let categoryName = currentCategoryName || translations[currentLanguage].category_other;&#10;        // Find or create category object&#10;        let categoryObj = data.categories.find(cat =&gt; (cat.names.en === categoryName || cat.names.he === categoryName || cat.id === categoryName.toLowerCase()));&#10;        if (!categoryObj) {&#10;            const id = categoryName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/gi, '') + '-' + Date.now();&#10;            categoryObj = { id, names: { en: categoryName, he: categoryName } };&#10;            data.categories.push(categoryObj);&#10;        }&#10;        const globalName = namePart.trim();&#10;        if (!globalName) return;&#10;        // Find or create global item&#10;        let globalItem = data.globalItems.find(g =&gt; g.name.toLowerCase() === globalName.toLowerCase() &amp;&amp; g.categoryId === categoryObj.id);&#10;        if (!globalItem) {&#10;            globalItem = {&#10;                id: 'global-' + Date.now() + Math.random(),&#10;                name: globalName,&#10;                categoryId: categoryObj.id,&#10;                estimatedPrice: 0,&#10;                priceUnit: quantityUnit,&#10;                createdAt: new Date().toISOString(),&#10;                updatedAt: new Date().toISOString()&#10;            };&#10;            data.globalItems.push(globalItem);&#10;        }&#10;        items.push({&#10;            id: 'item-' + Date.now() + Math.random(),&#10;            globalItemId: globalItem.id,&#10;            quantity,&#10;            quantityUnit,&#10;            actualPrice: null,&#10;            priceBasisQuantity: 1,&#10;            notes,&#10;            isChecked&#10;        });&#10;    });&#10;    if (items.length === 0) {&#10;        alert('No items found to import');&#10;        return;&#10;    }&#10;    const newList = { id: 'list-' + Date.now(), name: listName, items };&#10;    data.lists.push(newList);&#10;    saveData();&#10;    textarea.value = '';&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    updateGlobalItemSuggestions();&#10;    alert('Imported ' + items.length + (items.length === 1 ? ' item' : ' items'));&#10;}&#10;&#10;// Export shopping data to CSV&#10;function exportToCSV() {&#10;    const rows = [];&#10;    // Header&#10;    rows.push(['List Name', 'Item Name', 'Quantity', 'Unit', 'Price', 'Basis Quantity', 'Category', 'Actual Price', 'Date Completed']);&#10;    const allLists = [...data.lists, ...data.archivedLists];&#10;    allLists.forEach(list =&gt; {&#10;        list.items.forEach(item =&gt; {&#10;            const globalItem = data.globalItems.find(g =&gt; g.id === item.globalItemId);&#10;            // Determine item name and category from global item if available&#10;            const itemName = globalItem ? globalItem.name : (item.name || '');&#10;            const categoryId = globalItem ? globalItem.categoryId : item.categoryId;&#10;            const category = data.categories.find(c =&gt; c.id === categoryId);&#10;            const categoryName = category ? (category.names.en || category.id) : '';&#10;            const priceVal = item.actualPrice != null ? item.actualPrice : (globalItem ? globalItem.estimatedPrice : 0);&#10;            const basis = item.priceBasisQuantity || 1;&#10;            const actualPrice = item.actualPrice != null ? priceVal : '';&#10;            const dateCompleted = list.completedAt || '';&#10;            rows.push([&#10;                list.name,&#10;                itemName,&#10;                item.quantity,&#10;                item.quantityUnit,&#10;                priceVal,&#10;                basis,&#10;                categoryName,&#10;                actualPrice,&#10;                dateCompleted&#10;            ]);&#10;        });&#10;    });&#10;    const csvContent = rows.map(r =&gt; r.map(field =&gt; {&#10;        const s = String(field == null ? '' : field);&#10;        // Escape double quotes by doubling&#10;        return '&quot;' + s.replace(/&quot;/g, '&quot;&quot;') + '&quot;';&#10;    }).join(',')).join('\n');&#10;    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });&#10;    const url = URL.createObjectURL(blob);&#10;    const link = document.createElement('a');&#10;    link.setAttribute('href', url);&#10;    link.setAttribute('download', 'shopping-data.csv');&#10;    document.body.appendChild(link);&#10;    link.click();&#10;    document.body.removeChild(link);&#10;    URL.revokeObjectURL(url);&#10;}&#10;&#10;function refreshUI() {&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    if (overlay &amp;&amp; !overlay.classList.contains('hidden')) {&#10;        const listArr = editingArchive ? data.archivedLists : data.lists;&#10;        const current = listArr.find(l =&gt; l.id === editingItemListId);&#10;        if (current) renderItems(current);&#10;    }&#10;}&#10;&#10;function undo() {&#10;    if (undoStack.length === 0) return;&#10;    redoStack.push(clone(data));&#10;    data = undoStack.pop();&#10;    lastSavedData = clone(data);&#10;    refreshUI();&#10;    saveData(false);&#10;}&#10;&#10;function redo() {&#10;    if (redoStack.length === 0) return;&#10;    undoStack.push(clone(data));&#10;    data = redoStack.pop();&#10;    lastSavedData = clone(data);&#10;    refreshUI();&#10;    saveData(false);&#10;}&#10;&#10;// Clear all data from localStorage and reset app&#10;async function clearAllData() {&#10;    const t = translations[currentLanguage];&#10;    if (!confirm(t.confirm_clear)) return;&#10;    // Use DataService to clear persisted data&#10;    await window.DataService.clearData();&#10;    // Reset in-memory data to defaults&#10;    data = {&#10;        lists: [],&#10;        globalItems: [],&#10;        categories: [],&#10;        archivedLists: [],&#10;        receipts: []&#10;    };&#10;    // Reload default categories and save to storage&#10;    await loadData();&#10;    saveData();&#10;    // Re-render all views&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;    alert(t.clear_data + ' done');&#10;}&#10;&#10;// Complete a list and move it to archive&#10;function completeList(listId) {&#10;    const index = data.lists.findIndex(l =&gt; l.id === listId);&#10;    if (index === -1) return;&#10;    if (!confirm('Mark this list as completed?')) return;&#10;    const list = data.lists[index];&#10;    list.isCompleted = true;&#10;    list.completedAt = new Date().toISOString();&#10;    // You might want to attach receipts here (global receipts)&#10;    // For now just copy global receipts as list receipts and clear global&#10;    list.receiptImages = (data.receipts || []).slice();&#10;    data.receipts = [];&#10;    // Move to archive&#10;    data.archivedLists.push(list);&#10;    data.lists.splice(index, 1);&#10;    saveData();&#10;    renderLists();&#10;    renderSummary();&#10;    renderArchive();&#10;    closeListDetails();&#10;}&#10;&#10;// Presence and collaboration features&#10;function showPresenceIndicators() {&#10;    // Add connected users indicator to header&#10;    let presenceIndicator = document.getElementById('presence-indicator');&#10;    if (!presenceIndicator) {&#10;        presenceIndicator = document.createElement('div');&#10;        presenceIndicator.id = 'presence-indicator';&#10;        presenceIndicator.style.cssText = `&#10;            display: flex;&#10;            align-items: center;&#10;            gap: 0.5rem;&#10;            color: white;&#10;            font-size: 0.8rem;&#10;        `;&#10;&#10;        const header = document.querySelector('header');&#10;        const languageToggle = document.querySelector('.language-toggle');&#10;        header.insertBefore(presenceIndicator, languageToggle);&#10;    }&#10;&#10;    const onlineCount = connectedUsers.length;&#10;    const t = translations[currentLanguage];&#10;&#10;    presenceIndicator.innerHTML = `&#10;        &lt;i class=&quot;bi bi-people&quot;&gt;&lt;/i&gt;&#10;        &lt;span&gt;${onlineCount} ${onlineCount === 1 ? 'user' : 'users'} online&lt;/span&gt;&#10;        ${window.DataService?.isConnected ? '&lt;i class=&quot;bi bi-wifi&quot; style=&quot;color: #4caf50;&quot;&gt;&lt;/i&gt;' : '&lt;i class=&quot;bi bi-wifi-off&quot; style=&quot;color: #f44336;&quot;&gt;&lt;/i&gt;'}&#10;    `;&#10;}&#10;&#10;function showEditingIndicators(listId, itemId = null) {&#10;    const key = itemId ? `${listId}/${itemId}` : listId;&#10;    const editor = activeEditors[key];&#10;&#10;    if (editor &amp;&amp; editor.clientId !== window.DataService.clientId) {&#10;        // Show indicator that someone else is editing&#10;        showEditingBadge(editor.userId, listId, itemId);&#10;    }&#10;}&#10;&#10;function showEditingBadge(userName, listId, itemId = null) {&#10;    const targetSelector = itemId ?&#10;        `[data-item-id=&quot;${itemId}&quot;]` :&#10;        `[data-list-id=&quot;${listId}&quot;]`;&#10;&#10;    const target = document.querySelector(targetSelector);&#10;    if (target &amp;&amp; !target.querySelector('.editing-badge')) {&#10;        const badge = document.createElement('span');&#10;        badge.className = 'editing-badge';&#10;        badge.style.cssText = `&#10;            background: #2196f3;&#10;            color: white;&#10;            font-size: 0.7rem;&#10;            padding: 2px 6px;&#10;            border-radius: 10px;&#10;            margin-left: 0.5rem;&#10;            display: inline-flex;&#10;            align-items: center;&#10;            gap: 0.25rem;&#10;        `;&#10;        badge.innerHTML = `&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;${userName}`;&#10;        target.appendChild(badge);&#10;    }&#10;}&#10;&#10;function clearEditingBadges(listId = null, itemId = null) {&#10;    if (listId &amp;&amp; itemId) {&#10;        const target = document.querySelector(`[data-item-id=&quot;${itemId}&quot;]`);&#10;        const badge = target?.querySelector('.editing-badge');&#10;        badge?.remove();&#10;    } else if (listId) {&#10;        const target = document.querySelector(`[data-list-id=&quot;${listId}&quot;]`);&#10;        const badge = target?.querySelector('.editing-badge');&#10;        badge?.remove();&#10;    } else {&#10;        document.querySelectorAll('.editing-badge').forEach(badge =&gt; badge.remove());&#10;    }&#10;}&#10;&#10;// Enhanced conflict resolution UI&#10;function showConflictResolutionModal(conflicts, mergedData, originalData) {&#10;    return new Promise((resolve) =&gt; {&#10;        const overlay = document.createElement('div');&#10;        overlay.style.cssText = `&#10;            position: fixed;&#10;            top: 0;&#10;            left: 0;&#10;            right: 0;&#10;            bottom: 0;&#10;            background: rgba(0,0,0,0.7);&#10;            display: flex;&#10;            justify-content: center;&#10;            align-items: center;&#10;            z-index: 10000;&#10;        `;&#10;&#10;        const modal = document.createElement('div');&#10;        modal.style.cssText = `&#10;            background: white;&#10;            padding: 2rem;&#10;            border-radius: 8px;&#10;            max-width: 600px;&#10;            max-height: 80vh;&#10;            overflow-y: auto;&#10;            box-shadow: 0 4px 20px rgba(0,0,0,0.3);&#10;        `;&#10;&#10;        const t = translations[currentLanguage];&#10;        modal.innerHTML = `&#10;            &lt;h3&gt;Resolve Conflicts&lt;/h3&gt;&#10;            &lt;p&gt;Your changes conflict with recent updates from other users. Please choose how to resolve:&lt;/p&gt;&#10;            &lt;div id=&quot;conflict-list&quot;&gt;&lt;/div&gt;&#10;            &lt;div style=&quot;margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;&quot;&gt;&#10;                &lt;button id=&quot;accept-merged&quot; class=&quot;btn btn-primary&quot;&gt;Accept Merged Version&lt;/button&gt;&#10;                &lt;button id=&quot;keep-mine&quot; class=&quot;btn btn-secondary&quot;&gt;Keep My Changes&lt;/button&gt;&#10;                &lt;button id=&quot;manual-resolve&quot; class=&quot;btn btn-outline-primary&quot;&gt;Manual Review&lt;/button&gt;&#10;            &lt;/div&gt;&#10;        `;&#10;&#10;        const conflictList = modal.querySelector('#conflict-list');&#10;        conflicts.forEach(conflict =&gt; {&#10;            const conflictDiv = document.createElement('div');&#10;            conflictDiv.style.cssText = `&#10;                border: 1px solid #ddd;&#10;                padding: 1rem;&#10;                margin: 1rem 0;&#10;                border-radius: 4px;&#10;            `;&#10;&#10;            if (conflict.type === 'list_conflict') {&#10;                conflictDiv.innerHTML = `&#10;                    &lt;h4&gt;List: ${conflict.serverVersion.name}&lt;/h4&gt;&#10;                    &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;&quot;&gt;&#10;                        &lt;div&gt;&#10;                            &lt;strong&gt;Server Version:&lt;/strong&gt;&#10;                            &lt;div style=&quot;background: #f0f8ff; padding: 0.5rem; border-radius: 4px;&quot;&gt;&#10;                                ${conflict.serverVersion.name} (${conflict.serverVersion.items?.length || 0} items)&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                        &lt;div&gt;&#10;                            &lt;strong&gt;Your Version:&lt;/strong&gt;&#10;                            &lt;div style=&quot;background: #fff8dc; padding: 0.5rem; border-radius: 4px;&quot;&gt;&#10;                                ${conflict.localVersion.name} (${conflict.localVersion.items?.length || 0} items)&#10;                            &lt;/div&gt;&#10;                        &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                `;&#10;            }&#10;        });&#10;&#10;        modal.querySelector('#accept-merged').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(mergedData);&#10;        });&#10;&#10;        modal.querySelector('#keep-mine').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(originalData);&#10;        });&#10;&#10;        modal.querySelector('#manual-resolve').addEventListener('click', () =&gt; {&#10;            overlay.remove();&#10;            resolve(null); // Let user manually resolve&#10;        });&#10;&#10;        overlay.appendChild(modal);&#10;        document.body.appendChild(overlay);&#10;    });&#10;}&#10;&#10;// Enhanced list management with presence tracking&#10;function openListDetails(listId, isArchive = false) {&#10;    editingArchive = isArchive;&#10;    editingItemListId = listId;&#10;    editingItemId = null;&#10;&#10;    // Track editing presence&#10;    window.DataService.updatePresence('editStart', listId);&#10;    isEditing = true;&#10;    currentEditingContext = { listId, isArchive };&#10;&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    const title = document.getElementById('list-details-title');&#10;&#10;    const list = (isArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === listId);&#10;    const t = translations[currentLanguage];&#10;&#10;    if (list) {&#10;        title.textContent = list.name;&#10;        title.setAttribute('data-list-id', listId);&#10;        renderItems(list);&#10;    }&#10;&#10;    overlay.classList.remove('hidden');&#10;    const url = new URL(window.location);&#10;    url.searchParams.set('list', listId);&#10;    history.replaceState(null, '', url);&#10;    applyFullscreenState();&#10;&#10;    // Show editing indicators&#10;    showEditingIndicators(listId);&#10;}&#10;&#10;function closeListDetails() {&#10;    const overlay = document.getElementById('list-details-overlay');&#10;    overlay.classList.add('hidden');&#10;&#10;    // Clear editing presence&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId);&#10;        clearEditingBadges(currentEditingContext.listId);&#10;        currentEditingContext = null;&#10;    }&#10;&#10;    isEditing = false;&#10;&#10;    const url = new URL(window.location);&#10;    url.searchParams.delete('list');&#10;    history.replaceState(null, '', url);&#10;}&#10;&#10;// Enhanced remote data update handler with presence&#10;window.onRemoteDataUpdated = function(remoteData) {&#10;    if (!remoteData || typeof remoteData !== 'object') return;&#10;&#10;    // Store current editing context to restore after update&#10;    const wasEditing = isEditing;&#10;    const editingContext = currentEditingContext;&#10;&#10;    data = remoteData;&#10;    data.lists = data.lists || [];&#10;    data.globalItems = data.globalItems || [];&#10;    data.categories = data.categories || [];&#10;    data.archivedLists = data.archivedLists || [];&#10;    data.receipts = data.receipts || [];&#10;    lastSavedData = clone(data);&#10;    undoStack = [];&#10;    redoStack = [];&#10;&#10;    // Update UI&#10;    renderLists();&#10;    renderSummary();&#10;    renderGlobalItems();&#10;    renderArchive();&#10;    renderCategories();&#10;    updateGlobalItemSuggestions();&#10;&#10;    // Restore editing context if we were editing&#10;    if (wasEditing &amp;&amp; editingContext &amp;&amp; editingItemListId) {&#10;        const listArr = editingContext.isArchive ? data.archivedLists : data.lists;&#10;        const current = listArr.find(l =&gt; l.id === editingItemListId);&#10;        if (current) {&#10;            renderItems(current);&#10;        }&#10;    }&#10;&#10;    // Show conflict notification if needed&#10;    if (remoteData._conflicts &amp;&amp; remoteData._conflicts.length &gt; 0) {&#10;        window.DataService.showConflictNotification();&#10;    }&#10;};&#10;&#10;// New presence update handler&#10;window.onPresenceUpdated = function(users, editors) {&#10;    connectedUsers = users || [];&#10;    activeEditors = editors || {};&#10;&#10;    showPresenceIndicators();&#10;    clearEditingBadges(); // Clear all existing badges&#10;&#10;    // Show editing indicators for currently active editors&#10;    Object.entries(activeEditors).forEach(([key, editor]) =&gt; {&#10;        if (editor.clientId !== window.DataService.clientId) {&#10;            const [listId, itemId] = key.split('/');&#10;            showEditingIndicators(listId, itemId);&#10;        }&#10;    });&#10;};&#10;&#10;// Enhanced render functions with collaboration indicators&#10;function renderLists() {&#10;    const container = document.getElementById('list-container');&#10;    container.innerHTML = '';&#10;&#10;    data.lists.forEach(list =&gt; {&#10;        const li = document.createElement('li');&#10;        li.className = 'list-group-item d-flex align-items-start justify-content-between gap-2';&#10;        li.setAttribute('data-list-id', list.id);&#10;        const t = translations[currentLanguage];&#10;        // List name and stats&#10;        const info = document.createElement('div');&#10;        info.className = 'flex-grow-1';&#10;        const nameSpan = document.createElement('strong');&#10;        nameSpan.textContent = list.name;&#10;        info.appendChild(nameSpan);&#10;        // Stats: purchased/total&#10;        const total = list.items.length;&#10;        const purchased = list.items.filter(i =&gt; i.isChecked).length;&#10;        const stats = document.createElement('div');&#10;        stats.className = 'small text-muted';&#10;        stats.textContent = `${t.purchased}: ${purchased}/${total}`;&#10;        info.appendChild(stats);&#10;        li.appendChild(info);&#10;        const btnGroup = document.createElement('div');&#10;        btnGroup.className = 'btn-group btn-group-sm';&#10;        // Manage Items button&#10;        const manageBtn = document.createElement('button');&#10;        manageBtn.className = 'btn btn-outline-primary';&#10;        manageBtn.innerHTML = '&lt;i class=&quot;bi bi-list-task&quot;&gt;&lt;/i&gt;';&#10;        manageBtn.title = t.manage_items;&#10;        manageBtn.addEventListener('click', () =&gt; openListDetails(list.id));&#10;        btnGroup.appendChild(manageBtn);&#10;        // Rename button&#10;        const renameBtn = document.createElement('button');&#10;        renameBtn.className = 'btn btn-outline-secondary';&#10;        renameBtn.innerHTML = '&lt;i class=&quot;bi bi-pencil&quot;&gt;&lt;/i&gt;';&#10;        renameBtn.title = t.rename_list;&#10;        renameBtn.addEventListener('click', () =&gt; openListModal(list.id));&#10;        btnGroup.appendChild(renameBtn);&#10;        // Share link button&#10;        const linkBtn = document.createElement('button');&#10;        linkBtn.className = 'btn btn-outline-secondary';&#10;        linkBtn.innerHTML = '&lt;i class=&quot;bi bi-link-45deg&quot;&gt;&lt;/i&gt;';&#10;        linkBtn.title = t.share_link;&#10;        linkBtn.addEventListener('click', () =&gt; {&#10;            const url = new URL(window.location);&#10;            url.searchParams.set('list', list.id);&#10;            navigator.clipboard.writeText(url.toString());&#10;            alert(t.share_link);&#10;        });&#10;        btnGroup.appendChild(linkBtn);&#10;        // Delete button&#10;        const deleteBtn = document.createElement('button');&#10;        deleteBtn.className = 'btn btn-outline-danger';&#10;        deleteBtn.innerHTML = '&lt;i class=&quot;bi bi-trash&quot;&gt;&lt;/i&gt;';&#10;        deleteBtn.title = t.delete_list;&#10;        deleteBtn.addEventListener('click', () =&gt; {&#10;            if (confirm('Delete list?')) {&#10;                data.lists = data.lists.filter(l =&gt; l.id !== list.id);&#10;                saveData();&#10;                renderLists();&#10;                renderSummary();&#10;            }&#10;        });&#10;        btnGroup.appendChild(deleteBtn);&#10;        li.appendChild(btnGroup);&#10;&#10;        // Check if list is being edited&#10;        if (window.DataService.isBeingEdited(list.id)) {&#10;            const editor = window.DataService.getActiveEditors(list.id);&#10;            showEditingBadge(editor.userId, list.id);&#10;        }&#10;&#10;        container.appendChild(li);&#10;    });&#10;}&#10;&#10;// Add real-time operation handlers&#10;window.onRemoteOperationsApplied = function(operations) {&#10;    // Handle batch operations from other clients&#10;    console.log('Remote operations applied:', operations);&#10;&#10;    // Show subtle notification&#10;    const notification = document.createElement('div');&#10;    notification.style.cssText = `&#10;        position: fixed;&#10;        bottom: 20px;&#10;        right: 20px;&#10;        background: #4caf50;&#10;        color: white;&#10;        padding: 8px 16px;&#10;        border-radius: 4px;&#10;        z-index: 9999;&#10;        font-size: 0.8rem;&#10;        opacity: 0.9;&#10;    `;&#10;    notification.textContent = `${operations.length} updates from other users`;&#10;    document.body.appendChild(notification);&#10;&#10;    setTimeout(() =&gt; notification.remove(), 3000);&#10;};&#10;&#10;window.onRemoteOperationReceived = function(operation) {&#10;    // Handle single real-time operation&#10;    console.log('Real-time operation received:', operation);&#10;&#10;    // Apply operation locally for instant feedback&#10;    // This would require implementing operation transforms on the client side&#10;    // For now, we'll just refresh the affected UI components&#10;&#10;    if (operation.path.startsWith('lists/')) {&#10;        renderLists();&#10;        if (isEditing &amp;&amp; currentEditingContext) {&#10;            const list = data.lists.find(l =&gt; l.id === currentEditingContext.listId);&#10;            if (list) renderItems(list);&#10;        }&#10;    }&#10;};&#10;&#10;// Enhanced beforeunload handler for presence cleanup&#10;window.addEventListener('beforeunload', () =&gt; {&#10;    if (currentEditingContext) {&#10;        window.DataService.updatePresence('editEnd', currentEditingContext.listId, editingItemId);&#10;    }&#10;    window.DataService.updatePresence('disconnect');&#10;});&#10;&#10;// Enhanced visibility change handler for better presence tracking&#10;document.addEventListener('visibilitychange', () =&gt; {&#10;    if (document.visibilityState === 'visible') {&#10;        window.DataService.updatePresence('active');&#10;        showPresenceIndicators();&#10;    } else {&#10;        window.DataService.updatePresence('idle');&#10;    }&#10;});&#10;&#10;// Enhanced setupEvents function with collaboration features&#10;function setupEvents() {&#10;    // Language selection&#10;    document.getElementById('language-select').addEventListener('change', (e) =&gt; {&#10;        currentLanguage = e.target.value;&#10;        localStorage.setItem('shopping-list-language', currentLanguage);&#10;        applyLanguage();&#10;    });&#10;&#10;    // Load saved language preference&#10;    const savedLang = localStorage.getItem('shopping-list-language');&#10;    if (savedLang &amp;&amp; translations[savedLang]) {&#10;        currentLanguage = savedLang;&#10;        document.getElementById('language-select').value = currentLanguage;&#10;    }&#10;&#10;    // Tab navigation&#10;    document.getElementById('tab-lists').addEventListener('click', () =&gt; showPage('lists'));&#10;    document.getElementById('tab-summary').addEventListener('click', () =&gt; showPage('summary'));&#10;    document.getElementById('tab-items').addEventListener('click', () =&gt; showPage('items'));&#10;    document.getElementById('tab-archive').addEventListener('click', () =&gt; showPage('archive'));&#10;    document.getElementById('tab-settings').addEventListener('click', () =&gt; showPage('settings'));&#10;&#10;    // List management&#10;    document.getElementById('add-list-button').addEventListener('click', () =&gt; openListModal());&#10;    document.getElementById('save-list').addEventListener('click', saveList);&#10;    document.getElementById('cancel-modal').addEventListener('click', closeListModal);&#10;&#10;    // Item management&#10;    document.getElementById('add-item-button').addEventListener('click', () =&gt; {&#10;        if (editingItemListId) {&#10;            openItemModal(editingItemListId);&#10;        }&#10;    });&#10;    document.getElementById('save-item').addEventListener('click', saveItem);&#10;    document.getElementById('cancel-item-modal').addEventListener('click', closeItemModal);&#10;&#10;    // List details management&#10;    document.getElementById('close-list-details').addEventListener('click', closeListDetails);&#10;    document.getElementById('complete-list-button').addEventListener('click', () =&gt; {&#10;        if (editingItemListId) {&#10;            completeList(editingItemListId);&#10;        }&#10;    });&#10;&#10;    // Undo/Redo functionality&#10;    document.getElementById('undo-button').addEventListener('click', undo);&#10;    document.getElementById('redo-button').addEventListener('click', redo);&#10;&#10;    // Fullscreen toggle&#10;    document.getElementById('toggle-fullscreen').addEventListener('click', toggleListFullscreen);&#10;&#10;    // Global item management&#10;    document.getElementById('add-global-item-button').addEventListener('click', () =&gt; openGlobalItemModal());&#10;    document.getElementById('save-global-item').addEventListener('click', saveGlobalItem);&#10;    document.getElementById('cancel-global-item-modal').addEventListener('click', closeGlobalItemModal);&#10;&#10;    // Settings and categories&#10;    document.getElementById('add-category-button').addEventListener('click', addCategory);&#10;    document.getElementById('new-category-input').addEventListener('keydown', (e) =&gt; {&#10;        if (e.key === 'Enter') {&#10;            addCategory();&#10;        }&#10;    });&#10;&#10;    // Import/Export functionality&#10;    document.getElementById('import-button').addEventListener('click', importFromKeep);&#10;    document.getElementById('export-csv-button').addEventListener('click', exportToCSV);&#10;&#10;    // Clear data functionality&#10;    document.getElementById('clear-data-button').addEventListener('click', clearAllData);&#10;&#10;    // Item search functionality&#10;    const searchInput = document.getElementById('item-search');&#10;    if (searchInput) {&#10;        searchInput.addEventListener('input', (e) =&gt; {&#10;            itemSearchTerm = e.target.value;&#10;            if (editingItemListId) {&#10;                const list = (editingArchive ? data.archivedLists : data.lists).find(l =&gt; l.id === editingItemListId);&#10;                if (list) renderItems(list);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Item name input with autocomplete&#10;    const itemNameInput = document.getElementById('item-name-input');&#10;    if (itemNameInput) {&#10;        itemNameInput.addEventListener('input', handleItemNameInput);&#10;        itemNameInput.addEventListener('focus', handleItemNameInput);&#10;        itemNameInput.addEventListener('blur', () =&gt; {&#10;            setTimeout(() =&gt; {&#10;                const suggestions = document.getElementById('item-suggestions');&#10;                if (suggestions) suggestions.classList.add('hidden');&#10;            }, 200);&#10;        });&#10;    }&#10;&#10;    // Receipt upload handling&#10;    const receiptInput = document.getElementById('receipt-input');&#10;    if (receiptInput) {&#10;        receiptInput.addEventListener('change', (e) =&gt; {&#10;            const files = Array.from(e.target.files);&#10;            files.forEach(file =&gt; {&#10;                data.receipts = data.receipts || [];&#10;                data.receipts.push({ name: file.name, size: file.size, type: file.type });&#10;            });&#10;            saveData();&#10;            displayReceipts();&#10;        });&#10;    }&#10;&#10;    // Keyboard shortcuts&#10;    document.addEventListener('keydown', (e) =&gt; {&#10;        // Only handle shortcuts when not in input fields&#10;        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;&#10;&#10;        if (e.ctrlKey || e.metaKey) {&#10;            switch (e.key) {&#10;                case 'z':&#10;                    e.preventDefault();&#10;                    if (e.shiftKey) {&#10;                        redo();&#10;                    } else {&#10;                        undo();&#10;                    }&#10;                    break;&#10;                case 'n':&#10;                    e.preventDefault();&#10;                    if (document.getElementById('page-lists').classList.contains('active')) {&#10;                        openListModal();&#10;                    } else if (document.getElementById('page-items').classList.contains('active')) {&#10;                        openGlobalItemModal();&#10;                    }&#10;                    break;&#10;                case 'f':&#10;                    e.preventDefault();&#10;                    if (!document.getElementById('list-details-overlay').classList.contains('hidden')) {&#10;                        toggleListFullscreen();&#10;                    }&#10;                    break;&#10;            }&#10;        }&#10;&#10;        // ESC key to close modals&#10;        if (e.key === 'Escape') {&#10;            if (!document.getElementById('modal-overlay').classList.contains('hidden')) {&#10;                closeListModal();&#10;            } else if (!document.getElementById('item-modal-overlay').classList.contains('hidden')) {&#10;                closeItemModal();&#10;            } else if (!document.getElementById('global-item-modal-overlay').classList.contains('hidden')) {&#10;                closeGlobalItemModal();&#10;            } else if (!document.getElementById('list-details-overlay').classList.contains('hidden')) {&#10;                closeListDetails();&#10;            }&#10;        }&#10;    });&#10;&#10;    // Enhanced modal handling with enter key support&#10;    document.getElementById('list-name-input').addEventListener('keydown', (e) =&gt; {&#10;        if (e.key === 'Enter') {&#10;            saveList();&#10;        }&#10;    });&#10;&#10;    // Prevent form submission on enter in item modal inputs&#10;    ['item-name-input', 'item-quantity-input', 'item-price-input', 'item-price-basis-input'].forEach(id =&gt; {&#10;        const input = document.getElementById(id);&#10;        if (input) {&#10;            input.addEventListener('keydown', (e) =&gt; {&#10;                if (e.key === 'Enter') {&#10;                    e.preventDefault();&#10;                    saveItem();&#10;                }&#10;            });&#10;        }&#10;    });&#10;&#10;    // Global item modal enter key support&#10;    ['global-name-input', 'global-price-input'].forEach(id =&gt; {&#10;        const input = document.getElementById(id);&#10;        if (input) {&#10;            input.addEventListener('keydown', (e) =&gt; {&#10;                if (e.key === 'Enter') {&#10;                    e.preventDefault();&#10;                    saveGlobalItem();&#10;                }&#10;            });&#10;        }&#10;    });&#10;&#10;    // Enhanced presence tracking&#10;    setupPresenceTracking();&#10;&#10;    // Enhanced error handling for collaboration&#10;    setupCollaborationErrorHandling();&#10;}&#10;&#10;function setupPresenceTracking() {&#10;    // Track user activity for presence&#10;    let activityTimer;&#10;    &#10;    const updateActivity = () =&gt; {&#10;        if (window.DataService &amp;&amp; window.DataService.isConnected) {&#10;            window.DataService.updatePresence('active');&#10;        }&#10;        &#10;        clearTimeout(activityTimer);&#10;        activityTimer = setTimeout(() =&gt; {&#10;            if (window.DataService &amp;&amp; window.DataService.isConnected) {&#10;                window.DataService.updatePresence('idle');&#10;            }&#10;        }, 5 * 60 * 1000); // 5 minutes idle timeout&#10;    };&#10;&#10;    // Track various user activities&#10;    ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event =&gt; {&#10;        document.addEventListener(event, updateActivity, true);&#10;    });&#10;&#10;    // Initial activity&#10;    updateActivity();&#10;}&#10;&#10;function setupCollaborationErrorHandling() {&#10;    // Handle network errors gracefully&#10;    window.addEventListener('online', () =&gt; {&#10;        console.log('Connection restored');&#10;        if (window.DataService &amp;&amp; !window.DataService.isConnected) {&#10;            window.DataService.scheduleReconnect();&#10;        }&#10;        showConnectionStatus('online');&#10;    });&#10;&#10;    window.addEventListener('offline', () =&gt; {&#10;        console.log('Connection lost');&#10;        showConnectionStatus('offline');&#10;    });&#10;&#10;    // Enhanced error recovery&#10;    window.addEventListener('unhandledrejection', (event) =&gt; {&#10;        console.error('Unhandled promise rejection:', event.reason);&#10;        &#10;        // Handle specific collaboration errors&#10;        if (event.reason &amp;&amp; event.reason.message) {&#10;            if (event.reason.message.includes('conflict') || event.reason.message.includes('revision')) {&#10;                showConflictNotification('A conflict was detected and resolved automatically.');&#10;            } else if (event.reason.message.includes('network') || event.reason.message.includes('fetch')) {&#10;                showConnectionStatus('error');&#10;            }&#10;        }&#10;    });&#10;}&#10;&#10;function showConnectionStatus(status) {&#10;    // Remove existing status indicators&#10;    const existing = document.querySelector('.connection-status');&#10;    if (existing) existing.remove();&#10;&#10;    const indicator = document.createElement('div');&#10;    indicator.className = 'connection-status';&#10;    indicator.style.cssText = `&#10;        position: fixed;&#10;        top: 20px;&#10;        left: 20px;&#10;        padding: 8px 16px;&#10;        border-radius: 4px;&#10;        font-size: 0.9rem;&#10;        z-index: 10000;&#10;        display: flex;&#10;        align-items: center;&#10;        gap: 0.5rem;&#10;    `;&#10;&#10;    switch (status) {&#10;        case 'online':&#10;            indicator.style.background = '#4caf50';&#10;            indicator.style.color = 'white';&#10;            indicator.innerHTML = '&lt;i class=&quot;bi bi-wifi&quot;&gt;&lt;/i&gt;Connected';&#10;            break;&#10;        case 'offline':&#10;            indicator.style.background = '#f44336';&#10;            indicator.style.color = 'white';&#10;            indicator.innerHTML = '&lt;i class=&quot;bi bi-wifi-off&quot;&gt;&lt;/i&gt;Offline - Changes saved locally';&#10;            break;&#10;        case 'error':&#10;            indicator.style.background = '#ff9800';&#10;            indicator.style.color = 'white';&#10;            indicator.innerHTML = '&lt;i class=&quot;bi bi-exclamation-triangle&quot;&gt;&lt;/i&gt;Connection issues - Retrying...';&#10;            break;&#10;    }&#10;&#10;    document.body.appendChild(indicator);&#10;&#10;    // Auto-remove after delay&#10;    setTimeout(() =&gt; {&#10;        if (indicator.parentNode) {&#10;            indicator.remove();&#10;        }&#10;    }, status === 'offline' ? 10000 : 5000);&#10;}&#10;&#10;function showConflictNotification(message) {&#10;    const notification = document.createElement('div');&#10;    notification.style.cssText = `&#10;        position: fixed;&#10;        top: 20px;&#10;        right: 20px;&#10;        background: linear-gradient(135deg, #ff9800, #f57c00);&#10;        color: white;&#10;        padding: 16px 20px;&#10;        border-radius: 8px;&#10;        z-index: 10000;&#10;        box-shadow: 0 4px 20px rgba(0,0,0,0.3);&#10;        max-width: 350px;&#10;        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;&#10;    `;&#10;    &#10;    notification.innerHTML = `&#10;        &lt;div style=&quot;display: flex; align-items: flex-start; gap: 12px;&quot;&gt;&#10;            &lt;div style=&quot;flex-shrink: 0; font-size: 20px;&quot;&gt;⚠️&lt;/div&gt;&#10;            &lt;div style=&quot;flex: 1;&quot;&gt;&#10;                &lt;div style=&quot;font-weight: 600; margin-bottom: 4px;&quot;&gt;Collaboration Update&lt;/div&gt;&#10;                &lt;div style=&quot;font-size: 14px; opacity: 0.9; line-height: 1.4;&quot;&gt;&#10;                    ${message}&#10;                &lt;/div&gt;&#10;                &lt;button onclick=&quot;this.parentElement.parentElement.parentElement.remove()&quot; &#10;                        style=&quot;margin-top: 8px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;&quot;&gt;&#10;                    Dismiss&#10;                &lt;/button&gt;&#10;            &lt;/div&gt;&#10;            &lt;button onclick=&quot;this.parentElement.parentElement.remove()&quot; &#10;                    style=&quot;background: none; border: none; color: white; cursor: pointer; font-size: 18px; line-height: 1;&quot;&gt;×&lt;/button&gt;&#10;        &lt;/div&gt;&#10;    `;&#10;    &#10;    document.body.appendChild(notification);&#10;    &#10;    // Auto-dismiss after 8 seconds&#10;    setTimeout(() =&gt; {&#10;        if (notification.parentNode) {&#10;            notification.remove();&#10;        }&#10;    }, 8000);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>