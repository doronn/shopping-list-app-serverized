<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/shopping-list-app/dataService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/shopping-list-app/dataService.js" />
              <option name="originalContent" value="// DataService provides an abstraction layer over data persistence.  In phase 1&#10;// we use localStorage to store the entire application state.  Methods are&#10;// asynchronous to allow seamless migration to a remote server in the future.&#10;&#10;const STORAGE_KEY = 'shoppingListData';&#10;&#10;/*&#10; * DataService provides an abstraction layer over data persistence.  In phase 1&#10; * we store everything in localStorage.  To prepare for phase 2 (server&#10; * synchronisation), DataService exposes a `useServer` flag and a&#10; * `serverBaseUrl` property.  When `useServer` is set to true, all&#10; * operations will be proxied to a remote API rather than localStorage.  The&#10; * remote API is expected to expose endpoints like `/data` (GET/PUT) and&#10; * `/data/clear` (POST).  This design allows the rest of the application to&#10; * remain agnostic to where data lives.&#10; */&#10;&#10;const DataService = {&#10;    // If true, use the remote server; otherwise fall back to localStorage.&#10;    useServer: true,&#10;    // Base URL for the remote API.  For a self‑hosted server this might be&#10;    // something like 'http://localhost:3000/api'.  Keep trailing slash off.&#10;    serverBaseUrl: 'https://shopping-list-app-serverized.onrender.com',&#10;&#10;    /**&#10;     * Socket.IO client instance.  When using the server, this will be&#10;     * initialised by initSocket() to receive real‑time updates.&#10;     */&#10;    socket: null,&#10;&#10;    /**&#10;     * Load the application data from persistent storage or the remote API.&#10;     * Returns an object containing lists, globalItems, categories,&#10;     * archivedLists and receipts.  If no data exists, returns null.&#10;     * @returns {Promise&lt;Object|null&gt;}&#10;     */&#10;    async loadData() {&#10;        try {&#10;            if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data`);&#10;                if (!resp.ok) throw new Error('Server returned ' + resp.status);&#10;                const json = await resp.json();&#10;                return json;&#10;            }&#10;            const jsonStr = window.localStorage.getItem(STORAGE_KEY);&#10;            if (!jsonStr) return null;&#10;            return JSON.parse(jsonStr);&#10;        } catch (err) {&#10;            console.error('Failed to load data', err);&#10;            return null;&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Save the provided data object to persistent storage or the remote API.&#10;     * @param {Object} dataObj&#10;     * @returns {Promise&lt;void&gt;}&#10;     */&#10;    async saveData(dataObj) {&#10;        try {&#10;            if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;                await fetch(`${this.serverBaseUrl}/data`, {&#10;                    method: 'PUT',&#10;                    headers: { 'Content-Type': 'application/json' },&#10;                    body: JSON.stringify(dataObj)&#10;                });&#10;                return;&#10;            }&#10;            const json = JSON.stringify(dataObj);&#10;            window.localStorage.setItem(STORAGE_KEY, json);&#10;        } catch (err) {&#10;            console.error('Failed to save data', err);&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Initialise a WebSocket connection to the server for real‑time&#10;     * synchronisation.  When the server broadcasts updated data, we update&#10;     * localStorage and call an optional global callback (onRemoteDataUpdated)&#10;     * so the UI can re‑render without a full page reload.  Only call this&#10;     * if useServer is true.&#10;     */&#10;    initSocket() {&#10;        if (!this.useServer || !this.serverBaseUrl || this.socket) return;&#10;        if (typeof io === 'undefined') {&#10;            console.warn('Socket.io client library not loaded');&#10;            return;&#10;        }&#10;        this.socket = io(this.serverBaseUrl);&#10;        this.socket.on('connect', () =&gt; {&#10;            console.log('Connected to shopping list server');&#10;        });&#10;        this.socket.on('dataUpdated', (remoteData) =&gt; {&#10;            try {&#10;                // Persist remote data locally for offline usage&#10;                window.localStorage.setItem(STORAGE_KEY, JSON.stringify(remoteData));&#10;            } catch (err) {&#10;                console.error('Failed to update localStorage from server', err);&#10;            }&#10;            if (typeof window.onRemoteDataUpdated === 'function') {&#10;                window.onRemoteDataUpdated(remoteData);&#10;            } else {&#10;                // As a fallback, reload the page to reflect remote changes&#10;                console.log('Remote data updated, reload to apply changes');&#10;            }&#10;        });&#10;    },&#10;&#10;    /**&#10;     * Clear all persisted data locally or via the remote API.  Useful for&#10;     * debugging or resetting the application state.&#10;     * @returns {Promise&lt;void&gt;}&#10;     */&#10;    async clearData() {&#10;        try {&#10;            if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;                await fetch(`${this.serverBaseUrl}/data/clear`, { method: 'POST' });&#10;                return;&#10;            }&#10;            window.localStorage.removeItem(STORAGE_KEY);&#10;        } catch (err) {&#10;            console.error('Failed to clear data', err);&#10;        }&#10;    }&#10;};&#10;&#10;// Expose DataService globally so script.js can access it without modules.&#10;window.DataService = DataService;" />
              <option name="updatedContent" value="// DataService provides an abstraction layer over data persistence.  In phase 1&#10;// we use localStorage to store the entire application state.  Methods are&#10;// asynchronous to allow seamless migration to a remote server in the future.&#10;&#10;const STORAGE_KEY = 'shoppingListData';&#10;&#10;/*&#10; * DataService provides an abstraction layer over data persistence.  In phase 1&#10; * we store everything in localStorage.  To prepare for phase 2 (server&#10; * synchronisation), DataService exposes a `useServer` flag and a&#10; * `serverBaseUrl` property.  When `useServer` is set to true, all&#10; * operations will be proxied to a remote API rather than localStorage.  The&#10; * remote API is expected to expose endpoints like `/data` (GET/PUT) and&#10; * `/data/clear` (POST).  This design allows the rest of the application to&#10; * remain agnostic to where data lives.&#10; */&#10;&#10;const DataService = {&#10;    // Default to localStorage; set this to true to use the remote server.&#10;    // The flag may be toggled at runtime if server requests fail.&#10;    useServer: false,&#10;    // Base URL for the remote API.  For a self‑hosted server this might be&#10;    // something like 'http://localhost:3000/api'.  Keep trailing slash off.&#10;    serverBaseUrl: 'https://shopping-list-app-serverized.onrender.com',&#10;&#10;    /**&#10;     * Socket.IO client instance.  When using the server, this will be&#10;     * initialised by initSocket() to receive real‑time updates.&#10;     */&#10;    socket: null,&#10;&#10;    /**&#10;     * Load the application data from persistent storage or the remote API.&#10;     * Returns an object containing lists, globalItems, categories,&#10;     * archivedLists and receipts.  If no data exists, returns null.&#10;     * @returns {Promise&lt;Object|null&gt;}&#10;     */&#10;    async loadData() {&#10;        // Attempt to load data from the remote API when useServer is enabled.&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data`);&#10;                if (resp.ok) {&#10;                    return await resp.json();&#10;                }&#10;                // Non‑OK responses cause a fallback to localStorage.&#10;                console.warn('Remote load failed with status', resp.status, '- falling back to localStorage');&#10;                this.useServer = false;&#10;            } catch (err) {&#10;                console.error('Failed to load data from server:', err);&#10;                this.useServer = false;&#10;            }&#10;        }&#10;        // Fallback: read from localStorage.&#10;        try {&#10;            const jsonStr = window.localStorage.getItem(STORAGE_KEY);&#10;            if (!jsonStr) return null;&#10;            return JSON.parse(jsonStr);&#10;        } catch (err) {&#10;            console.error('Failed to load data from localStorage', err);&#10;            return null;&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Save the provided data object to persistent storage or the remote API.&#10;     * @param {Object} dataObj&#10;     * @returns {Promise&lt;void&gt;}&#10;     */&#10;    async saveData(dataObj) {&#10;        // Try saving to the server when useServer is true.&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data`, {&#10;                    method: 'PUT',&#10;                    headers: { 'Content-Type': 'application/json' },&#10;                    body: JSON.stringify(dataObj)&#10;                });&#10;                if (resp.ok) {&#10;                    return;&#10;                }&#10;                // Non‑OK responses trigger fallback to localStorage.&#10;                console.warn('Remote save failed with status', resp.status, '- falling back to localStorage');&#10;                this.useServer = false;&#10;            } catch (err) {&#10;                console.error('Failed to save data to server:', err);&#10;                this.useServer = false;&#10;            }&#10;        }&#10;        // Fallback: store data in localStorage.&#10;        try {&#10;            const json = JSON.stringify(dataObj);&#10;            window.localStorage.setItem(STORAGE_KEY, json);&#10;        } catch (err) {&#10;            console.error('Failed to save data to localStorage', err);&#10;        }&#10;    },&#10;&#10;    /**&#10;     * Initialise a WebSocket connection to the server for real‑time&#10;     * synchronisation.  When the server broadcasts updated data, we update&#10;     * localStorage and call an optional global callback (onRemoteDataUpdated)&#10;     * so the UI can re‑render without a full page reload.  Only call this&#10;     * if useServer is true.&#10;     */&#10;    initSocket() {&#10;        if (!this.useServer || !this.serverBaseUrl || this.socket) return;&#10;        if (typeof io === 'undefined') {&#10;            console.warn('Socket.io client library not loaded');&#10;            return;&#10;        }&#10;        this.socket = io(this.serverBaseUrl);&#10;        this.socket.on('connect', () =&gt; {&#10;            console.log('Connected to shopping list server');&#10;        });&#10;        this.socket.on('dataUpdated', (remoteData) =&gt; {&#10;            try {&#10;                // Persist remote data locally for offline usage&#10;                window.localStorage.setItem(STORAGE_KEY, JSON.stringify(remoteData));&#10;            } catch (err) {&#10;                console.error('Failed to update localStorage from server', err);&#10;            }&#10;            if (typeof window.onRemoteDataUpdated === 'function') {&#10;                window.onRemoteDataUpdated(remoteData);&#10;            } else {&#10;                // As a fallback, reload the page to reflect remote changes&#10;                console.log('Remote data updated, reload to apply changes');&#10;            }&#10;        });&#10;    },&#10;&#10;    /**&#10;     * Clear all persisted data locally or via the remote API.  Useful for&#10;     * debugging or resetting the application state.&#10;     * @returns {Promise&lt;void&gt;}&#10;     */&#10;    async clearData() {&#10;        // Attempt to clear data via the server when useServer is enabled.&#10;        if (this.useServer &amp;&amp; this.serverBaseUrl) {&#10;            try {&#10;                const resp = await fetch(`${this.serverBaseUrl}/data/clear`, { method: 'POST' });&#10;                if (resp.ok) {&#10;                    return;&#10;                }&#10;                console.warn('Remote clear failed with status', resp.status, '- falling back to localStorage');&#10;                this.useServer = false;&#10;            } catch (err) {&#10;                console.error('Failed to clear data via server:', err);&#10;                this.useServer = false;&#10;            }&#10;        }&#10;        // Fallback: remove data from localStorage.&#10;        try {&#10;            window.localStorage.removeItem(STORAGE_KEY);&#10;        } catch (err) {&#10;            console.error('Failed to clear localStorage', err);&#10;        }&#10;    }&#10;};&#10;&#10;// Expose DataService globally so script.js can access it without modules.&#10;window.DataService = DataService;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>